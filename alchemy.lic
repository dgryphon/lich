=begin

	slightly faster alchemy script of doom!!!1!one

	;alchemy help

	tillmen@lichproject.org

=end


# fixme: run outta money
# fixme: full containers
# fixme: jars with unneeded ingredients ;e GameObj['bag'].contents.find_all { |obj| obj.noun == 'jar' }.each { |jar| echo jar.after_name unless jar.after_name.sub(/^containing /, '') =~ /#{UserVars.needed_reagents.gsub('$|^', 's?$|^').gsub('tooth', '(?:tooth|teeth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').gsub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').gsub(' ', 's? ')}/ }
# fixme: forage some mushrooms only certain times of day
# fixme: Khelorof says, "To rise to the top, you must diversify.  You need to learn 2 rank(s) of other skills before I can promote you in this skill again."
# fixme: recast haste on armor hindrance
# fixme: option to use symbol of dreams when waiting for spirit
# fixme: pick the best npc to kill in travel range instead of the closest
# fixme: wrong note when running to a different town to buy

silence_me

unless defined?($alchemy_recipes) and ($alchemy_recipes.class == Array) and not $alchemy_recipes.empty?
	unless Script.exists?('alchemy-recipes')
		start_script 'repository', [ 'download', 'alchemy-recipes' ]
		wait_while { running?('repository') }
		unless Script.exists?('alchemy-recipes')
			echo 'failed to download alchemy-recipes.lic'
			exit
		end
	end
	start_script 'alchemy-recipes'
	wait_while { running?('alchemy-recipes') }
	unless defined?($alchemy_recipes)
		echo 'no recipes'
		exit
	end
	$alchemy_recipes.delete_if { |recipe| !recipe[:for].nil? and !recipe[:for].include?(Char.prof) }
end

CharSettings['hide-gld-check']     = true  if CharSettings['hide-gld-check'].nil?
CharSettings['hide-bundle-check']  = true  if CharSettings['hide-bundle-check'].nil?
CharSettings['hide-jar-check']     = true  if CharSettings['hide-jar-check'].nil?
CharSettings['cast-sanctuary']     = true  if CharSettings['cast-sanctuary'].nil?
CharSettings['buy-crap']           = false if CharSettings['buy-crap'].nil?
CharSettings['throw-away-crap']    = false if CharSettings['throw-away-crap'].nil?
CharSettings['sell-crap']          = false if CharSettings['sell-crap'].nil?
CharSettings['max-travel-time']  ||=   90
CharSettings['max-hunt-time']    ||=  300
CharSettings['max-forage-time']  ||=  300
CharSettings['cost-per-second']  ||=   15
CharSettings['favorite-recipes'] ||= Array.new

elusive_reagent_cost = {
	'cluster of ayanad crystals'        =>   64,
	'ayanad crystal'                    =>  128,
	'crystal core'                      =>  128,
	'elemental core'                    =>  255,
	"cluster of s'ayanad crystals"      =>  255,
	'cracked soulstone'                 =>  300, # fixme
	"s'ayanad crystal"                  =>  510,
	'some essence of air'               =>  510,
	'some essence of earth'             =>  510,
	'some essence of fire'              =>  510,
	'some essence of water'             =>  510,
	"pristine nymph's hair"             =>  510,
	'small troll tooth'                 =>  638,
	'glimmering blue essence shard'     =>  638,
	'some glimmering blue essence dust' =>  765,
	'glimmering blue mote of essence'   =>  765,
	"cluster of t'ayanad crystals"      =>  892,
	'glowing violet essence shard'      => 1275,
	'crystalline globe'                 => 1530,
	"t'ayanad crystal"                  => 1785,
	"pristine sprite's hair"            => 1785,
	'glowing violet mote of essence'    => 2295,
	'some glowing violet essence dust'  => 2295,
	'perfect myklian belly scale'       => 2550,
	'large troll tooth'                 => 2550,
	'vial of farlook vitreous humor'    => 2550,
	'inky necrotic core'                => 2550,
	'tiny golden seed'                  => 2550,
	'radiant crimson essence shard'     => 3825,
	"pristine siren's hair"             => 4080,
	"n'ayanad crystal"                  => 5355,
	'some radiant crimson essence dust' => 6885,
	'radiant crimson mote of essence'   => 6885,
}

equivalent = [
	[ 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root' ],
	[ "ayana'al leaf", "ayana'al lichen", "ayana'al weed", "ayana'al berry", "ayana'al root" ],
	[ 'some ground ayana', 'some ground ayana leaf', 'some ground ayana lichen', 'some ground ayana weed', 'some ground ayana berry', 'some ground ayana root' ],
	[ 'myklian scale', 'orange myklian scale', 'red myklian scale', 'yellow myklian scale', 'green myklian scale' ],
	[ 'white pearl', 'large white pearl', 'medium white pearl', 'small white pearl', 'tiny white pearl' ],
	[ 'black pearl', 'large black pearl', 'medium black pearl', 'small black pearl', 'tiny black pearl' ],
	[ 'pink pearl', 'tiny pink pearl', 'small pink pearl', 'medium pink pearl', 'large pink pearl' ],
	[ 'stick', 'thick stick', 'stained stick', 'slender stick', 'pointed stick', 'twisted stick', 'long stick', 'slim stick', 'charred stick', 'flexible stick', 'sturdy stick', 'dark stick', 'hefty stick', 'cracked stick', 'thin stick', 'small stick', 'bent stick', 'short stick', 'heavy stick' ],
	[ 'vial of concentrated firethorn essence', 'vial concentrated firethorn essence' ],
	[ 'some powdered rhodochrosite stone', 'some powdered pink rhodochrosite stone' ],
	[ 'some powdered chrysoberyl gem', 'some powdered bright chrysoberyl gem' ],
	[ 'some powdered malachite stone', 'some powdered green malachite stone' ],
	[ 'some powdered spessartine garnet', 'some powdered orange spessartine garnet' ],
	[ 'some powdered pink coral', 'some powdered polished pink coral' ],
	[ 'some powdered blue coral', 'some powdered polished blue coral' ],
	[ 'some powdered red coral', 'some powdered polished red coral' ],
	[ 'some powdered water sapphire', 'some powdered pale water sapphire' ],
	[ 'some powdered fire pearl', 'some powdered billiant fire pearl' ],
	[ 'some powdered cowrie shell', 'some powdered snake-head cowrie shell' ],
	[ 'some powdered iridescent mother-of-pearl', 'some powdered iridescent piece of mother-of-pearl' ],
	[ 'some powdered silvery conch shell', 'some powdered sparkling silvery conch shell' ],
	[ 'some powdered imperial topaz', 'some powdered orange imperial topaz' ],
	[ 'some powdered green moonstone', 'some powdered pale green moonstone' ],
	[ 'some powdered pale blue moonstone', 'some powdered blue moonstone' ],
	[ 'some powdered beryl gem', 'some powdered golden beryl gem' ],
	[ 'crystalline globe', 'corked crystalline globe filled with glowing mineral water', ],
	[ 'tkaro root', 'shiny tkaro root' ],
	[ 'tufted hawk-owl ear', 'hawk-owl ear' ],
]

herb_doses = {
	'some acantha leaf' => 10,
	'some aloeas stem' => 2,
	'some haphip root' => 4,
	'some pothinir grass' => 2,
	'some basal moss' => 4,
	'some ephlox moss' => 4,
	'some ambrominas leaf' => 4,
	'some calamia fruit' => 2,
	'some cactacae spine' => 4,
	'some sovyn clove' => 1,
	'some wolifrew lichen' => 4,
	'some woth flower' => 2,
	'some torban leaf' => 3,
}

sea_water_flask = /^(?:small|faceted) crystal flask$|^dark sphene-inset flask$/
sea_water_vial  = /^(?:clouded|warped|chipped|tapered|smoky|thick|slender|clear|blackened) glass vial$|^polished glaes vial$/
bundled_herb    = /^some acantha leaf$|^some cactacae spine$|^some ambrominas leaf$|^some torban leaf$|^some wolifrew lichen$|^some sovyn clove$|^some ephlox moss$|^some pothinir grass$|^some haphip root$|^some calamia fruit$|^some aloeas stem$|^some basal moss$|^some woth flower$/

check_silvers = proc {
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("#{script.name}_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("#{script.name}_check_silvers", action)
	silence_me unless undo_silence = silence_me
	put 'info'
	silence_me if undo_silence
	wait_until { silvers }
	silvers
}

wander_room_order = Array.new
wander_room_list = Array.new
wander = proc {
	next_room_options = Room.current.wayto.keys & wander_room_list
	next_room = next_room_options.find_all { |r| not wander_room_order.include?(r) }
	if next_room.empty?
		next_room = wander_room_order.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	wander_room_order.delete(next_room)
	wander_room_order.push(next_room)
	way = Room.current.wayto[next_room]
	if way.class == String 
		move(way)
	else
		way.call
	end
}

gld_var = nil
gld = proc {
	if gld_var.nil?
		fix_type = { 'General Alchemy' => 'alchemy', 'Alchemic Potions' => 'potions', 'Alchemic Trinkets' => 'trinkets' }
		script.want_downstream = false
		script.want_downstream_xml = true
		gld_var = Hash.new
		type = nil
		if CharSettings['hide-gld-check']
			started = false
			action = proc { |server_string|
				if started
					if server_string =~ /<output/
						DownstreamHook.remove('hide_gld')
						server_string
					else
						nil
					end
				else
					if server_string =~ /^You are (?:a member|Guild Master)/
						started = true
						nil
					else
						server_string
					end
				end
			}
			DownstreamHook.add('hide_gld', action)
		end
		undo_silent = !script.silent
		script.silent = true
		result = dothistimeout 'gld', 15, /^You are (?:a member|Guild Master)|^You have no guild affiliation./
		script.silent = false if undo_silent
		if result =~ /^You have no guild affiliation./
			echo 'join a guild'
			exit
		elsif result.nil?
			echo 'fixme 20983238453'
		end
		while (line = get) and (line !~ /<prompt/)
			if line =~ /^You currently have no ranks in any guild skills./
				for type in fix_type.values
					gld_var[type] = Hash.new
					gld_var[type][:rank] = 0
					gld_var[type][:task] = 'no task'
					gld_var[type][:reps] = 0
				end
			elsif line =~ /^You have ([0-9]+|no) ranks? in the (General Alchemy|Alchemic Potions|Alchemic Trinkets) skill\.$/
				rank = $1
				type = fix_type[$2]
				gld_var[type] = Hash.new
				if rank =~ /^[0-9]+$/
					gld_var[type][:rank] = rank.to_i
				else
					gld_var[type][:rank] = 0
				end
			elsif line =~ /^You are a Master of (General Alchemy|Alchemic Potions|Alchemic Trinkets)\.$/
				type = fix_type[$1]
				gld_var[type] = Hash.new
				gld_var[type][:rank] = 63
			elsif line =~ /^The Training Administrator told you to (.*)\.$/
				gld_var[type][:task] = $1
			elsif line =~ /^You have earned enough training points for your next rank\./
				gld_var[type][:task] = 'promotion'
			elsif line =~ /^You are not currently training in this skill\.$|^You have not yet obtained your first task for this skill rank\.$|^You have not been assigned a current task for this skill\.$/
				gld_var[type][:task] = 'no task'
				gld_var[type][:reps] = 0
			elsif line == 'You have no repetitions remaining for this task.'
				gld_var[type][:reps] = 0
			elsif line =~ /^You have ([0-9]+) repetitions? remaining (?:for|to complete) this task\.$/
				gld_var[type][:reps] = $1.to_i
			end
		end
		script.want_downstream = true
		script.want_downstream_xml = false
	end
	gld_var
}

invalid_gld = proc {
	gld_var = nil
}

gld_suggestions = proc {
	gld.call
	if gld_var.values.any? { |hash| hash[:recipes].nil? }
		for type in gld_var.keys
			if gld_var[type][:task] =~ /(?:with your|that involve) (.*?)(?: ability| mana|ing spells|ing|ing mana|ing spirit)?$/
				required_step = $1
				if gld_var[type][:task] =~ /cauldron workshop/
					gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } and not recipe[:steps].any? { |step| step =~ /^refract/ } }.collect { |recipe| recipe[:product] }
				else
					gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } }.collect { |recipe| recipe[:product] }
				end
			elsif gld_var[type][:task] =~ /follow some tough recipes and create some items|visit a skilled master for a lesson/
				gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| (recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max }.collect { |recipe| recipe[:product] }
			elsif gld_var[type][:task] == 'practice distilling for reagents'
				gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:product] == 'flask of pure water' }.collect { |recipe| recipe[:product] }
			elsif gld_var[type][:task] == 'practice extracting for reagents'
				gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:product] == 'handful of sea salt' }.collect { |recipe| recipe[:product] }
			else
				gld_var[type][:recipes] = Array.new
			end
			gld_var[type][:recipes] = gld_var[type][:recipes] | gld_var[type][:recipes]
		end
	end
	gld_var
}

alchemy_sack_var = nil
close_alchemy_sack_var = false
alchemy_sack = proc {
	if alchemy_sack_var.nil?
		if UserVars.alchemysack.nil? or UserVars.alchemysack.empty? 
			echo 'warning: alchemysack is not set (;set change alchemysack <container name>)'
			sleep 1
		else
			alchemy_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack).sub(' ', ' .*')}/i }
			if alchemy_sack_var.nil?
				echo "warning: failed to find your alchemysack (#{UserVars.alchemysack})"
				sleep 1
			else
				if alchemy_sack_var.contents.nil?
					open_result = dothistimeout "open ##{alchemy_sack_var.id}", 10, /You open|already open/
					close_alchemy_sack_var = true if open_result =~ /You open/
					if alchemy_sack_var.contents.nil?
						dothistimeout "look in ##{alchemy_sack_var.id}", 10, /In the .* you see/
						if alchemy_sack_var.contents.nil?
							echo "warning: failed to find the contents of your alchemysack (#{UserVars.alchemysack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	alchemy_sack_var
}

loot_sack_var = nil
close_loot_sack_var = false
loot_sack = proc {
	if loot_sack_var.nil?
		if UserVars.lootsack.nil? or UserVars.lootsack.empty? 
			echo 'warning: lootsack is not set (;set change lootsack <container name>)'
			sleep 1
		else
			loot_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack).sub(' ', ' .*')}/i }
			if loot_sack_var.nil?
				echo "warning: failed to find your lootsack (#{UserVars.lootsack})"
				sleep 1
			else
				if loot_sack_var.contents.nil?
					open_result = dothistimeout "open ##{loot_sack_var.id}", 10, /You open|already open/
					close_loot_sack_var = true if open_result =~ /You open/
					if loot_sack_var.contents.nil?
						dothistimeout "look in ##{loot_sack_var.id}", 10, /In the .* you see/
						if loot_sack_var.contents.nil?
							echo "warning: failed to find the contents of your lootsack (#{UserVars.lootsack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	loot_sack_var
}

herb_sack_var = nil
close_herb_sack_var = false
herb_sack = proc {
	if herb_sack_var.nil?
		if UserVars.herbsack.nil? or UserVars.herbsack.empty? 
			echo 'warning: herbsack is not set (;set change herbsack <container name>)'
			sleep 1
		else
			herb_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}/i }
			if herb_sack_var.nil?
				echo "warning: failed to find your herbsack (#{UserVars.herbsack})"
				sleep 1
			else
				if herb_sack_var.contents.nil?
					open_result = dothistimeout "open ##{herb_sack_var.id}", 10, /You open|already open/
					close_herb_sack_var = true if open_result =~ /You open/
					if herb_sack_var.contents.nil?
						dothistimeout "look in ##{herb_sack_var.id}", 10, /In the .* you see/
						if herb_sack_var.contents.nil?
							echo "warning: failed to find the contents of your herbsack (#{UserVars.herbsack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	herb_sack_var
}

close_sacks = proc {
	if close_alchemy_sack_var
		fput "close ##{alchemy_sack_var.id}"
		close_alchemy_sack_var = false
	end
	if close_loot_sack_var
		fput "close ##{loot_sack_var.id}"
		close_loot_sack_var = false
	end
	if close_herb_sack_var
		fput "close ##{herb_sack_var.id}"
		close_herb_sack_var = false
	end
}

all_sack_contents = proc {
	(alchemy_sack.call.contents.to_a | loot_sack.call.contents.to_a | herb_sack.call.contents.to_a)
}

cauldron = nil
drop_cauldron = proc {
	error = false
	unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.find { |obj| obj.noun == 'cauldron' } or GameObj.loot.find { |obj| obj.noun =~ /^(?:cauldron|vat|kettle|boiler)$/ }
		unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ /^(?:cauldron|vat|kettle|boiler)$/ }
			echo 'error: missing cauldron'
			error = true
		end
		dothis "get ##{cauldron.id}", /^You remove|^You already have that|^You detach/
		# Upon further reflection, you decide it would be best if you just used the already present training cauldron.
		dothis "drop ##{cauldron.id}", /^You drop/
		put "drag #{cauldron.noun}"
	end
	!error
}

force_drop_cauldron = proc {
	error = false
	unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ /^(?:cauldron|vat|kettle|boiler)$/ }
		echo 'error: missing cauldron'
		error = true
	else
		dothis "get ##{cauldron.id}", /^You remove|^You already have that|^You detach/
		# Upon further reflection, you decide it would be best if you just used the already present training cauldron.
		dothis "drop ##{cauldron.id}", /^You drop/
		put "drag #{cauldron.noun}"
	end
	!error
}

get_cauldron = proc {
	if cauldron
		dothis "_drag ##{cauldron.id} ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		fput 'drag stop'
		cauldron = nil
	end
}

where_is_previous_var = nil
where_is_shortest_distances_var = nil
where_is = proc { |place|
	if where_is_previous_var.nil?
		if Room.current
			if home_room = Room.current.find_nearest_by_tag("#{Char.prof.downcase} alchemy administrator")
				home_room = Room[home_room]
				if (home_room == Room.current) or Map.estimate_time(Room.current.path_to(home_room)) <= CharSettings['max-travel-time']
					where_is_previous_var, where_is_shortest_distances_var = home_room.dijkstra
				else
					echo 'warning: nearest guild exceeds max travel time'
					where_is_previous_var = false
				end
			else
				echo 'warning: failed to find your guild'
				where_is_previous_var = false
			end
		else
			echo 'warning: your current room is not in the map database'
			where_is_previous_var = false
		end
	end
	if where_is_previous_var == false
		Array.new
	else
		results = Array.new
		Map.list.each { |room| results.push(room.id) if room.tags.include?(place) }
		results.delete_if { |room_id| where_is_shortest_distances_var[room_id].nil? or where_is_shortest_distances_var[room_id] > CharSettings['max-travel-time'] }
		# ignore the Caravansary
		results.delete_if { |room_id| Room[room_id].title.any? { |t| t =~ /^(?:\['Tain't Much Magic, Emporium\]|\['Tain't Much Magic, Consignment\]|\[Finders-Sellers Pawnshop\]|\[Clenchfist Bros. Banking, Lobby\])$/ } }
		results.sort { |a,b| where_is_shortest_distances_var[a] <=> where_is_shortest_distances_var[b] }
	end
}

go_empty_workshop = proc {
	room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
	unless room_list.empty? or room_list.include?(Room.current.id)
		get_cauldron.call
		for room_id in room_list
			break if where_is_shortest_distances_var[room_id] > 15
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			break unless checkpcs
		end
	end
}

is_workshop = proc {
	Room.current.tags.include?("#{Char.prof.downcase} alchemy workshop")
}

tavel_time = proc { |room_id|
	if where_is_shortest_distances_var.nil?
		where_is.call
	end
	where_is_shortest_distances_var[room_id]
}

note_name_var = nil
note_name = proc {
	if note_name_var.nil?
		if (room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first) and (location = Room[room_id].location)
			hash = {
				'the town of Icemule Trace' => 'Icemule promissory note',
				'Icemule Trace' => 'Icemule promissory note',
				'Kharam-Dzu' => 'Borthuum Mining Company scrip',
				"the town of Wehnimer's Landing" => "Wehnimer's promissory note",
				"Wehnimer's Landing" => "Wehnimer's promissory note",
				"the Coastal Cliffs" => "Wehnimer's promissory note",
				"River's Rest" => 'Torren promissory note',
				'Zul Logoth' => 'mining chit',
				"Ta'Illistim" => 'City-States promissory note',
				"Ta'Vaalor" => 'City-States promissory note',
				'the free port of Solhaven' => 'Vornavis promissory note',
				'Solhaven' => 'Vornavis promissory note',
				'Mist Harbor' => 'Mist Harbor promissory note',
			}
			note_name_var = hash[location]
		else
			note_name_var = false
		end
	else
		note_name_var
	end
}

note_name_from_place = proc { |place|
	# 'Mist Harbor promissory note'
	if place =~ /^Icemule/
		'Icemule promissory note'
	elsif place =~ /^Ta'Illistim|^Ta'Vaalor/
		'City-States promissory note'
	elsif place =~ /^River's Rest/
		'Torren promissory note'
	elsif place =~ /^Solhaven/
		'Vornavis promissory note'
	elsif place =~ /^Kharam-Dzu/
		'Borthuum Mining Company scrip'
	elsif place =~ /^Wehnimer's Landing/
		"Wehnimer's promissory note"
	elsif place =~ /^Zul Logoth/
		'mining chit'
	else
		nil
	end
}

is_sunlight = proc {
	# fixme: guessing times for light
	# mid-morning:     11:26 - 11:26
	# afternoon:       12:07 - 14:04 (sunlight)
	# late afternoon:  14:23 - 16:48 (sunlight)
	# evening twilight 16:49 - 17:33 (moonlight)
	# late evening:    18:20 - 23:20
	# after midnight:  00:01 - 04:33
	# May 13-14, 2011
		# late afternoon:       ? - 18:50 (sunlight)
		# evening twilight: 18:51 - 19:20 (moonlight)
		# late evening:     19:21 - 23:59 (moonlight)
		# after midnight:   00:00 - 04:37 (moonlight)
		# morning twilight: 04:38 - 05:07 
		# early morning:    05:08 - 08:33 (sunlight)
		# mid morning:      08:34 - 11:59 (sunlight)
		# afternoon:        12:00 -     ? (sunlight)

	# fixme: daylight savings time?

	time = Time.at(Time.now.to_i + XMLData.server_time_offset)
	time = time - (21600 + time.utc_offset)
	(time.hour > 5 or (time.hour == 5 and time.min > 7)) and (time.hour < 18 or (time.hour == 18 and time.min < 51))

	# (server_time.hour > 4 or (server_time.hour == 4 and server_time.min > 30)) and (server_time.hour < 16 or (server_time.hour == 16 and server_time.min < 30))
	# offset = -18000
	# if Time.now.dst?
	# 	offset += 3600
	# end
	# fixme: getlocal doesn't take an offset on Ruby 1.8
	# time = Time.at(Time.now.to_f + XMLData.server_time_offset.to_f).getlocal(offset)
	# (time.hour > 5 or (time.hour == 5 and time.min > 7)) and (time.hour < 18 or (time.hour == 18 and time.min < 51))
}

is_moonlight = proc { !is_sunlight.call }

set_needed_reagents = proc {
	ingredient_list = Array.new
	check_proc = proc { |recipe|
		for step in recipe[:steps]
			if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
				ingredient_name = $1
				ingredient_list.push(ingredient_name) unless ingredient_list.include?(ingredient_name)
				if equivalent_names = equivalent.find { |list| list.include?(ingredient_name) }
					for equivalent_name in equivalent_names
						ingredient_list.push(equivalent_name) unless ingredient_list.include?(equivalent_name)
					end
				end
				for sub_recipe in $alchemy_recipes.find_all { |r| r[:product] == ingredient_name }
					check_proc.call(sub_recipe)
				end
			end
		end
	}
	for type in gld.call.keys
		for recipe in $alchemy_recipes.find_all { |recipe| CharSettings['favorite-recipes'].include?(recipe[:product]) or ((recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and (gld.call[type][:rank] <= 62) and (gld.call[type][:rank] >= recipe[:rank].min) and (gld.call[type][:rank] <= recipe[:rank].max)) }
			check_proc.call(recipe)
		end
	end
	for product in CharSettings['favorite-recipes']
		ingredient_list.push(product) unless ingredient_list.include?(product)
	end
	if ingredient_list.empty?
		UserVars.delete('needed_reagents')
	else
		UserVars.needed_reagents = "^#{ingredient_list.join('$|^')}$"
	end
	nil
}

is_reagent_var = nil
is_reagent = proc { |test_name|
	unless is_reagent_var
		reagent_array = Array.new
		$alchemy_recipes.each { |recipe|
			recipe[:steps].each { |step|
				if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
					item = $1
					equivalent.find { |r| r.include?(item) }.each { |i| reagent_array.push(i) unless reagent_array.include?(i) }
					reagent_array.push(item) unless reagent_array.include?(item)
				end
			}
		}
		is_reagent_var = /^#{reagent_array.collect { |r| r.sub(/^some /, '(?:some )?').sub('faintly ', '(?:faintly )?') }.join('$|^')}$/
	end
	test_name =~ is_reagent_var
}

do_administrator = proc {
	if gld.call.any? { |type,info| (info[:task] =~ /^(?:no task|promotion|gather alchemy ingredients for the guild's supply)$/ or info[:reps] == 0) and ((type == 'alchemy') or (info[:rank] < gld.call['alchemy'][:rank])) }
		general_ranks = gld.call['alchemy'][:rank]
		loop {
			get_cauldron.call
			if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				did_something = false
				if gld.call['alchemy'].nil?
					dothistimeout "ask #{GameObj.npcs.last.noun} about training alchemy", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				if gld.call['potions'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
					dothistimeout "ask #{GameObj.npcs.last.noun} about training potions", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				if gld.call['trinkets'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
					dothistimeout "ask #{GameObj.npcs.last.noun} about training trinkets", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				for type,info in gld.call
					next if (type =~ /potions|trinkets/) and (info[:rank] == gld.call['alchemy'][:rank])
					if info[:task] == 'no task'
						result = dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						invalid_gld.call
						unless result =~ /your general alchemy skills are not quite up to snuff/
							did_something = true
						end
					elsif (info[:task] == 'promotion')
						if type != 'alchemy' or info[:rank].to_i != 5 or (gld.call['potions'][:rank].to_i >= 2 and gld.call['trinkets'][:rank].to_i >= 2)
							if type != 'alchemy' or info[:rank].to_i != 10 or (gld.call['potions'][:rank].to_i >= 3 and gld.call['trinkets'][:rank].to_i >= 3)
								if room_id = where_is.call("#{Char.prof.downcase} alchemy guildmaster").first
									start_script 'go2', [ room_id.to_s ]
									wait_while { running?('go2') }
									result = dothistimeout "ask #{GameObj.npcs.last.noun} about next #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
									unless result =~ /you must diversify/
										did_something = true
										invalid_gld.call
										set_needed_reagents.call
									end
									room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
									start_script 'go2', [ room_id.to_s ]
									wait_while { running?('go2') }
								else
									echo 'error: failed to find guildmaster'
								end
							end
						end
					elsif info[:reps] == 0
						dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						invalid_gld.call
						did_something = true
					elsif info[:task] == "gather alchemy ingredients for the guild's supply"
						invalid_gld.call
						dothistimeout "ask #{GameObj.npcs.last.noun} about trade #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						did_something = true
					end
				end
				break unless did_something
			else
				echo 'error: failed to find training administrator'
				break
			end
		}
	end
}

read_menu = proc {
	status_tags
	clear
	fput 'unhide' if hidden? or invisible?
	fput 'order'
	menu = Hash.new
	while (line = get) and (line !~ /ORDER|BUY/)
		for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
			menu[item[1].sub(/^a /, '')] = item[0]
		end
	end
	status_tags
	clear
	menu
}

check_channel_spirit = proc {
	needed_spirit = 3
	needed_spirit += 1 if Spell[9912].active?
	needed_spirit += 1 if Spell[9913].active?
	needed_spirit += 1 if Spell[9914].active?
	needed_spirit += 3 if Spell[9916].active?
	checkspirit(needed_spirit)
}

ingredient_count = Hash.new
correct_herb_count = Array.new

check_ingredient = proc { |ingredient_name,temp_claimed_ingredients,temp_ingredient_count|
	temp_claimed_ingredients ||= Array.new
	if temp_ingredient_count.nil? or temp_ingredient_count.empty?
		temp_ingredient_count = ingredient_count.dup
	end
	found = false
	equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
	if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) and not temp_claimed_ingredients.include?(obj.id) }
		temp_claimed_ingredients.push(ingredient.id)
		found = true
	elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[bundle.id].nil?
			empty_hand
			dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
			measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
			if measure_result =~ /1 bite/
				temp_ingredient_count[bundle.id] = 1
				ingredient_count[bundle.id] = 1
			elsif measure_result =~ /2 bites/
				temp_ingredient_count[bundle.id] = 2
				ingredient_count[bundle.id] = 2
			elsif measure_result =~ /a few bites/
				temp_ingredient_count[bundle.id] = 3
				ingredient_count[bundle.id] = 3
			elsif measure_result =~ /several bites/
				temp_ingredient_count[bundle.id] = 5
				ingredient_count[bundle.id] = 5
			elsif measure_result =~ /plenty of bites/
				temp_ingredient_count[bundle.id] = 11
				ingredient_count[bundle.id] = 11
			else
				temp_ingredient_count[bundle.id] = 1
				ingredient_count[bundle.id] = 1
				echo "error: unmatched measure result: #{measure_result.inspect}"
			end
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			fill_hand
		end
		temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
		found = true
	elsif jar = all_sack_contents.call.find { |obj| (obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[jar.id].nil?
			if CharSettings['hide-jar-check']
				action = proc { |server_string|
					if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
						DownstreamHook.remove('hide-jar-check')
						nil
					else
						server_string
					end
				}
				DownstreamHook.add('hide-jar-check', action)
			end
			look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
			temp_ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
			ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
		end
		temp_ingredient_count[jar.id] = temp_ingredient_count[jar.id] - 1
		found = true
	elsif bundle = all_sack_contents.call.find { |obj| (obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[bundle.id].nil?
			if CharSettings['hide-bundle-check']
				action = proc { |server_string|
					if server_string =~ /^You.*?total of [0-9]+/
						DownstreamHook.remove('hide-bundle-check')
						nil
					else
						server_string
					end
				}
				DownstreamHook.add('hide-bundle-check', action)
			end
			measure_result = dothis "measure ##{bundle.id}", /^You.*?total of [0-9]+/
			temp_ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
			ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
		end
		temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
		found = true
	end
	[ found, temp_claimed_ingredients, temp_ingredient_count ]
}

get_ingredient = proc { |ingredient_name|
	ingredient = nil
	equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
	if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) }
		dothistimeout "get ##{ingredient.id}", 10, /^You remove|^You already have that/
	elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) }
		dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
		bundle_remove_result = dothistimeout 'bundle remove', 10, /^You (?:carefully )?remove|^Those were the last two|^You only have one/
		if bundle_remove_result =~ /^You only have one/
			correct_herb_count.delete(bundle.id)
			ingredient_count.delete(bundle.id)
			ingredient = bundle
		elsif correct_herb_count.include?(bundle.id)
			ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			if checkleft
				ingredient = GameObj.left_hand
			else
				echo 'error: left hand unexpectedly empty'
			end
		else
			measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
			if measure_result =~ /1 bite/
				min_count = 1
				correct_herb_count.push(bundle.id)
			elsif measure_result =~ /2 bites/
				min_count = 2
				correct_herb_count.push(bundle.id)
			elsif measure_result =~ /a few bites/
				min_count = 3
				if ingredient_count[bundle.id].to_i > 4
					correct_herb_count.push(bundle.id)
				end
			elsif measure_result =~ /several bites/
				min_count = 5
				if ingredient_count[bundle.id].to_i > 10
					correct_herb_count.push(bundle.id)
				end
			elsif measure_result =~ /plenty of bites/
				min_count = 11
			else
				min_count = 0
				echo "error: unmatched measure result: #{measure_result.inspect}"
			end
			if ingredient_count[bundle.id].nil?
				ingredient_count[bundle.id] = min_count
			else
				ingredient_count[bundle.id] = [(ingredient_count[bundle.id] - 1), min_count].max
			end
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			if checkleft
				ingredient = GameObj.left_hand
			else
				echo 'error: left hand unexpectedly empty'
			end
		end
	elsif jar = all_sack_contents.call.find { |obj| obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/ }
		unless ingredient_count[jar.id].nil?
			ingredient_count[jar.id] = ingredient_count[jar.id] - 1
			ingredient_count.delete(jar.id) if ingredient_count[jar.id] < 1
		end
		dothistimeout "get ##{jar.id}", 10, /^You remove|^You already have that/
		dothistimeout "shake ##{jar.id}", 10, /^You .*shake/
		dothistimeout "put ##{jar.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		if checkleft
			ingredient = GameObj.left_hand
		else
			echo 'error: left hand unexpectedly empty'
		end
	elsif bundle = all_sack_contents.call.find { |obj| obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/ }
		unless ingredient_count[bundle.id].nil?
			ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
			ingredient_count.delete(bundle.id) if ingredient_count[bundle.id] < 2
		end
		dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
		unbundle_result = dothistimeout 'bundle remove', 10, /^You remove|^Those were the last two/
		dothistimeout "put ##{bundle.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		if checkleft
			ingredient = GameObj.left_hand
		else
			echo 'error: left hand unexpectedly empty'
		end
	end
	ingredient
}

put_crap_away = proc {
	if (GameObj.right_hand.name =~ /ayanad crystals$/) or (GameObj.left_hand.name =~ /ayanad crystals$/)
		dothis "get crystal from my crystals", /You separate/
		dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
	end
	if checkright
		if is_reagent.call(GameObj.right_hand.name)
			dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			dothis "put ##{GameObj.right_hand.id} in ##{loot_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
	if checkleft
		if is_reagent.call(GameObj.left_hand.name)
			dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			dothis "put ##{GameObj.left_hand.id} in ##{loot_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
}

recursive_check_recipe = proc { |recipe,tracker,top_level|
	recipe[:steps].each { |step|
		if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
			ingredient_name = $1
			if step =~ /^grind/
				unless all_sack_contents.call.any? { |obj| obj.noun == 'mortar' }
					tracker[:error]['mortar'] = 1
				end
				if Char.prof == 'Wizard'
					tracker[:time] += 5
				else
					tracker[:time] += 25
				end
			elsif step =~ /^extract/
				tracker[:time] += 40
			elsif step =~ /^distill/
				tracker[:time] += 40
			end
			if tracker[:extra_ingredients].include?(ingredient_name)
				tracker[:extra_ingredients].delete_at(tracker[:extra_ingredients].index(ingredient_name))
				tracker[:found][ingredient_name] = tracker[:found][ingredient_name].to_i + 1
			else
				found_this, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name, tracker[:claimed_ingredients].dup, tracker[:ingredient_count].dup)
				if found_this
					tracker[:claimed_ingredients] = temp_claimed_ingredients
					tracker[:ingredient_count] = temp_ingredient_count
					tracker[:found][ingredient_name] = tracker[:found][ingredient_name].to_i + 1
					tracker[:cost] += elusive_reagent_cost[ingredient_name].to_i
				else
					support_recipe_list = $alchemy_recipes.find_all { |r| r[:product] == ingredient_name }
					if support_recipe_list.length > 0
						tracker_list = Array.new
						for support_recipe in support_recipe_list
							temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time] }
							temp_tracker = recursive_check_recipe.call(support_recipe.dup, temp_tracker, _top_level=false)
							tracker_list.push(temp_tracker)
							ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
						end
						tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
						unless tracker = tracker_list.find { |t| t[:error].empty? }
							tracker_list.sort! { |a,b|
								ae = 0
								a[:error].values.each { |v| ae += v }
								be = 0
								b[:error].values.each { |v| be += v }
								ae <=> be
							}
							tracker = tracker_list.first
						end
					else
						tracker[:error][ingredient_name] = tracker[:error][ingredient_name].to_i + 1
					end
				end
			end
		elsif step =~ /^buy\s+.*?from\s+(.*)/
			place = $1
			room_list = where_is.call(place)
			if room_list.empty?
				tracker[:error][place] = 1
			else
				unless tracker[:buy].keys.any? { |key| key =~ /^#{place};/ }
					tracker[:time] += tavel_time.call(room_list.first) * 2
				end
				tracker[:cost] += recipe[:cost].to_i
				tracker[:buy]["#{place};#{recipe[:product]}"] = tracker[:buy]["#{place};#{recipe[:product]}"].to_i + 1
			end
		elsif step =~ /^forage/
			room_list = where_is.call(recipe[:product])
			if room_list.empty?
				tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
			else
				if tracker[:forage][recipe[:product]].nil?
					tracker[:time] += tavel_time.call(room_list.first) * 2
				end
				CharSettings['forage time'] ||= Hash.new
				if CharSettings['forage time'][recipe[:product]].nil?
					CharSettings['forage time'][recipe[:product]] = [ 1, 1 ]
				end
				tracker[:time] += CharSettings['forage time'][recipe[:product]][0] / CharSettings['forage time'][recipe[:product]][1].to_f
				tracker[:forage][recipe[:product]] = tracker[:forage][recipe[:product]].to_i + 1
			end
		elsif step =~ /^kill\s+(.*)/
			npc = $1
			room_list = where_is.call(npc)
			if room_list.empty?
				tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
				# tracker[:error][npc] = tracker[:error][npc].to_i + 1
			else
				if CharSettings['attack-script']
					if tracker[:kill_for][recipe[:product]].nil?
						tracker[:time] += tavel_time.call(room_list.first) * 2
					end
					CharSettings['kill time'] ||= Hash.new
					CharSettings['kill time'][npc] ||= Hash.new
					if CharSettings['kill time'][npc][recipe[:product]].nil?
						CharSettings['kill time'][npc][recipe[:product]] = [ 1, 1 ]
					end
					tracker[:time] += CharSettings['kill time'][npc][recipe[:product]][0] / CharSettings['kill time'][npc][recipe[:product]][1].to_f
					tracker[:kill_for][recipe[:product]] = tracker[:kill_for][recipe[:product]].to_i + 1
				else
					tracker[:error]['attack-script'] = 1
				end
			end
		elsif step =~ /^light/
#			unless top_level
#				tracker[:recipe_count][recipe[:product]] = tracker[:recipe_count][recipe[:product]].to_i + 1
#			end
			unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.any? { |obj| obj.noun == 'cauldron' } or GameObj.loot.any? { |obj| obj.noun =~ /^(?:cauldron|vat|kettle|boiler)$/ } or all_sack_contents.call.any? { |obj| obj.noun =~ /^(?:cauldron|vat|kettle|boiler)$/ }
				tracker[:error]['cauldron'] = 1
			end
		elsif step =~ /^special/
			if vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
				tracker[:found][vial.name] = 1
			else
				tracker[:error]['vial for sea water'] = 1
			end
			if flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
				tracker[:found][flask.name] = 1
			else
				tracker[:error]['flask for sea water'] = 1
			end
			tracker[:time] += 40
		elsif step =~ /^simmer/
			tracker[:time] += 20
		elsif step =~ /^boil/
			tracker[:time] += 20
		elsif step =~ /^chant/
			tracker[:time] += 30
		elsif step =~ /^infuse/
			tracker[:time] += 15
			unless gld.call['alchemy'][:rank].to_i >= 30
				tracker[:error]['alchemy infuse'] = 1
			end
		elsif step =~ /^channel/
			tracker[:time] += 30
		elsif step =~ /^seal/
			tracker[:time] += 26
		elsif step =~ /^refract (moonlight|sunlight) through (.* lens)$/
			light = $1
			lens = $2
			unless all_sack_contents.call.any? { |obj| obj.name == lens }
				tracker[:error][lens] = 1
			end
			if (light == 'sunlight') and is_moonlight.call
				tracker[:error]['sunlight'] = 1
			elsif (light == 'moonlight') and is_sunlight.call
				tracker[:error]['moonlight'] = 1
			end
			tracker[:time] += 10
		else
			echo "warning: unkown step: #{step}"
		end
	}
	if top_level
		tracker[:recipe_count][recipe[:product]] = tracker[:recipe_count][recipe[:product]].to_i + 1
		recipe[:steps].each { |step| tracker[:finish_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	else
		recipe[:steps].each { |step| tracker[:prepare_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	end
	recipe[:steps].each { |step| tracker[:steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	if recipe[:product] =~ /^(?:s'|t')?ayanad crystal$/
		tracker[:extra_ingredients].push(recipe[:product])
	end
	tracker
}

check_recipe = proc { |recipe_name,repetitions|
	tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0 }
	if recipe_name.class == Array
		recipe_list = $alchemy_recipes.find_all { |recipe| recipe_name.include?(recipe[:product]) }
	else
		recipe_list = $alchemy_recipes.find_all { |recipe| recipe[:product] == recipe_name }
	end
	repetitions.times {
		if recipe_list.length > 0
			tracker_list = Array.new
			for recipe in recipe_list
				temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time] }
				temp_tracker = recursive_check_recipe.call(recipe, temp_tracker, top_level=true)
				tracker_list.push(temp_tracker)
				ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
			end
			tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
			tracker = tracker_list.find { |t| t[:error].empty? } || tracker_list.first
		else
			tracker[:error][recipe_name] = tracker[:error][recipe_name].to_i + 1
		end
	}
	fixed_buy = Hash.new
	tracker[:buy].each_pair { |where_what,how_many|
		where, what = where_what.split(';')
		fixed_buy[where] ||= Hash.new
		fixed_buy[where][what] = how_many
	}
	tracker[:buy] = fixed_buy
	tracker.delete(:claimed_ingredients)
	tracker.delete(:ingredient_count)
	tracker.delete(:extra_ingredients)
	tracker
}

show_check = proc { |check_info|
	output = "\n"
	output.concat check_info[:recipe_count].collect { |n,c| if c == 1; n; else; "#{n} (#{c})"; end }.join(', ').to_s
	output.concat "\n"
	unless check_info[:found].empty?
		output.concat "   have:\n"
		check_info[:found].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:forage].empty?
		output.concat "   forage:\n"
		check_info[:forage].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:kill_for].empty?
		output.concat "   kill for:\n"
		check_info[:kill_for].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:buy].empty?
		output.concat "   buy:\n"
		check_info[:buy].values.each { |place|
			place.each_pair { |n,c|
				output.concat "      #{n.sub(/s*\#.*$/, '')}"
				output.concat " (#{c})" if c > 1
				output.concat "\n"
			}
		}
	end
	unless check_info[:error].empty?
		output.concat "   #{monsterbold_start}missing:#{monsterbold_end}\n"
		check_info[:error].each_pair { |n,c|
			output.concat "      #{n}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	output.concat "\ncost: #{check_info[:cost]}, time: #{(check_info[:time]/60.0).as_time}\n\n"
	if defined?(_respond)
		_respond output
	else
		$stdout.puts output rescue()
	end
}

do_steps = proc { |steps|
	error = false
	uber_return_room = nil
	while step = steps.shift
		if step == 'light'
			need_empty_flask = false
			wait_spirit = false
			temp_claimed_ingredients = Array.new
			temp_ingredient_count = ingredient_count.dup
			for sub_step in steps
				if sub_step =~ /^add\s+(.*)/
					ingredient_name = $1
					found, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name,temp_claimed_ingredients,temp_ingredient_count)
					unless found
						error = true
						echo "error: missing #{ingredient_name}"
					end
				elsif sub_step == 'channel'
					wait_spirit = true
				elsif sub_step =~ /^(?:buy|forage|kill)/
					echo 'error: out of cheese'
					error = true
					break
				elsif sub_step == 'seal'
					break
				elsif sub_step =~ /^refract (moonlight|sunlight)/
					light = $1
					if (light == 'sunlight') and is_moonlight.call
						echo 'error: missing sunlight'
						error = true
						break
					elsif (light == 'moonlight') and is_sunlight.call
						echo 'error: missing moonlight'
						error = true
						break
					end
					unless is_workshop.call
						uber_return_room = Room.current
						get_cauldron.call
						go_empty_workshop.call
					end
				end
			end
			if error
				break
			else
				if wait_spirit
					unless check_channel_spirit.call
						echo 'waiting for spirit...'
						sleep 0.3 until check_channel_spirit.call
					end
				end
				drop_cauldron.call
				unless mana >= 1
					echo 'waiting for mana...'
					wait_until { mana >= 1 }
				end
				light_result = dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
				if light_result =~ /^But that is already lit!$/
					force_drop_cauldron.call
					dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
				end
			end
		elsif step =~ /^(add|grind|extract|distill|separate)\s+(.*)/
			action = $1
			ingredient_name = $2
			unless ingredient = get_ingredient.call(ingredient_name)
				echo "error: missing #{ingredient_name}"
				error = true
				break
			end
			if action == 'add'
				dothis "put ##{ingredient.id} in #{cauldron.noun || 'cauldron'}", /^You place|^You pour/
				if GameObj.right_hand.name == 'empty flask'
					dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					need_empty_flask = true
				elsif GameObj.left_hand.name == 'empty flask'
					dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					need_empty_flask = true
				end
			elsif action == 'grind'
				if checkright
					dothis 'swap', /^You swap/
				end
				mortar = all_sack_contents.call.find { |obj| obj.noun == 'mortar' }
				dothis "get ##{mortar.id}", /^You remove|^You already have that/
				dothis "put ##{ingredient.id} in ##{mortar.id}", /^You put|^I could not find what you were referring to\./
				loop {
					haste = Spell[506]
					haste.cast if haste.known? and haste.affordable? and not haste.active?
					waitrt?
					grind_result = dothis "grind #{ingredient.noun} from my mortar", /^Roundtime. [0-9]+ sec\.$|appears to be as ground as it'?s going to get|^Grind what|^With what do you intend to grind/
					waitrt?
					if grind_result =~ /^With what do you intend to grind/
						unless pestle = all_sack_contents.call.find { |obj| obj.noun == 'pestle' }
							echo "error: missing pestle"
							error = true
							break
						end
						dothis "_drag ##{pestle.id} ##{mortar.id}", /^You put|^I could not find what you were referring to\./
					elsif grind_result =~ /appears to be as ground as it'?s going to get|^Grind what/
						break
					end
				}
				break if error
				if mortar.contents.nil?
					dothis "look in ##{mortar.id}", /^In the .*? you see/
				end
				for item in mortar.contents
					next if item.noun == 'pestle'
					dothis "_drag ##{item.id} ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				end
				dothis "put ##{mortar.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
			elsif action == 'extract'
				unless checkright
					dothis 'swap', /^You swap/
				end
				return_room = nil
				unless is_workshop.call
					return_room = Room.current
					get_cauldron.call
					go_empty_workshop.call
				end
				if is_workshop.call
					unless mana >= 10
						echo 'waiting for mana...'
						wait_until { mana >= 10 }
					end
					dothis 'alchemy extract', /^You carefully (?:pour|place)/
					result = nil
					900.times { 
						sleep 0.1
						break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
					}
					sleep 1
					waitrt?
					put_crap_away.call
					if return_room
						start_script 'go2', [ return_room.id.to_s ]
						wait_while { running?('go2') }
					end
					if result.nil?
						echo "error: extract failed (game bug)"
						error = true
						break
					end
				else
					echo "error: failed to find workshop"
					error = true
					break
				end
			elsif action == 'distill'
				unless checkright
					dothis 'swap', /^You swap/
				end
				return_room = nil
				unless is_workshop.call
					return_room = Room.current
					get_cauldron.call
					go_empty_workshop.call
				end
				if is_workshop.call
					dothis 'alchemy distill', /^You select an unused/
					waitfor 'Sensing the process nearing its end'
					sleep 1
					waitrt?
					put_crap_away.call
					if return_room
						start_script 'go2', [ return_room.id.to_s ]
						wait_while { running?('go2') }
					end
				else
					echo "error: failed to find workshop"
					error = true
					break
				end
			elsif action == 'separate'
				noun = GameObj.right_hand.noun || GameObj.left_hand.noun
				dothis "get 1 #{noun.sub(/s$/, '')} from my #{noun}", /^You separate/
				put_crap_away.call
			end
		elsif step == 'boil'
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				boil_result = dothis 'alchemy boil', /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and push mana into it.  The flame beneath it (flickers briefly, but then dies down|quickly flares up wildly, bringing the contents to a rolling boil)\.$/
				waitrt?
				break if boil_result =~ /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and push mana into it.  The flame beneath it quickly flares up wildly, bringing the contents to a rolling boil\.$/
			}
		elsif step == 'simmer'
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				# simmer_result = dothis 'alchemy simmer', /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and gently push mana into it\.  The flame beneath it (flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer)\.$/
				simmer_result = dothis 'alchemy simmer', /flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer/
				waitrt?
				break if simmer_result =~ /quickly flares to life, bringing the contents to a slow simmer/
			}
		elsif step =~ /^chant /
			loop {
				# fixme: variable mana cost based on spell num?
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				chant_result = dothis "alchemy #{step}", /^You extend/
				waitrt?
				break if chant_result =~ /^You extend your hands.*vanish into the solution/
			}
		elsif step =~ /^infuse/
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				dothis 'alchemy infuse', /^You focus/
				infuse_result = waitfor 'The translucent thread fades away.  You feel slightly drained from the ordeal.', 'Your concentration lapses and the translucent thread connecting you to the solution fades away.'
				waitrt?
				break if infuse_result == 'The translucent thread fades away.  You feel slightly drained from the ordeal.'
			}
		elsif step == 'channel'
			loop {
				unless check_channel_spirit.call
					echo 'waiting for spirit...'
					sleep 0.3 until check_channel_spirit.call
				end
				channel_result = dothis 'alchemy channel', /^You focus .*? and link your spirit|^You attempt to channel/
				waitrt?
				break if channel_result =~ /^You focus .*? and link your spirit/
			}
		elsif step =~ /^refract (?:moonlight|sunlight) through (.* lens)$/
			# >alchemy refract
			# You select an unused gem lens assembly and set it up on the brushed steel workbench.
			# You carefully set the sapphire lens within the assembly and adjust it, aiming the refracted sunlight into your iron cauldron.
			# The surface of the solution in the iron cauldron shimmers in response!
			lens_name = $1
			unless lens = all_sack_contents.call.find { |obj| obj.name == lens_name }
				echo "error: failed to find #{lens_name}"
				error = true
				break
			end
			dothistimeout "get ##{lens.id}", 10, /^You remove|^You already have that/
			dothistimeout 'alchemy refract', 10, /^The surface of the solution in .* shimmers in response!/
			waitrt?
			dothistimeout "put ##{lens.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		elsif step == 'seal'
			unless mana >= 20
				echo 'waiting for mana...'
				wait_until { mana >= 20 }
			end
			if need_empty_flask
				dothis "get empty flask from ##{alchemy_sack.call.id}", /^You remove|^Get what\?/
			end
			fput "look in #{cauldron.noun || 'cauldron'}"
			dothis 'alchemy seal', /^You hold your hands over/
			nil until get =~ /You sense (?:that the ritual is complete|something amiss with the solution)/
			sleep 0.5
			waitrt?
			sleep 0.5
			put_crap_away.call
		elsif step == 'special'
			vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
			flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
			dothis "get ##{vial.id}", /^You remove|^You already have that/
			dothis "get ##{flask.id}", /^You remove|^You already have that/
			dothis "open ##{flask.id}", /^You gently twist the stopper on the flask|^It's already open\.$/
			pour_result = dothis "pour ##{flask.id} in ##{vial.id}", /^You pour|^It looks like your glass vial is already full\.$|^But your crystal flask is empty!$/
			if pour_result == 'But your crystal flask is empty!'
				dothis "put ##{vial.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				get_cauldron.call
				if room_id = where_is.call('alchemy sea water').first
					return_room = Room.current
					start_script 'go2', [ room_id.to_s ]
					wait_while { running?('go2') }
					dothis "collect water with ##{flask.id}", /under water until it is filled|is already filled/
					dothis "get ##{vial.id}", /^You remove|^You already have that/
					dothis "collect water with ##{vial.id}", /under water until it is filled|is already filled/
					start_script 'go2', [ return_room.id.to_s ]
					wait_while { running?('go2') }
				else
					echo 'error: failed to find a place to collect sea water'
					error = true
					break
				end
			end
			dothis "close ##{flask.id}", /^You draw up the slick crystal cork|^It's already corked\.$/
			dothis "put ##{flask.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
			unless is_workshop.call
				return_room = Room.current
				get_cauldron.call
				go_empty_workshop.call
			end
			if is_workshop.call
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				dothis 'alchemy extract', /^You carefully (?:pour|place)/
				result = nil
				900.times { 
					sleep 0.1
					break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
				}
				sleep 1
				waitrt?
				dothistimeout "put ##{vial.id} in ##{alchemy_sack.call.id}", 3, /^You put|^I could not find what you were referring to\./
				put_crap_away.call
				if return_room
					start_script 'go2', [ return_room.id.to_s ]
					wait_while { running?('go2') }
				end
				if result.nil?
					echo "error: extract failed (game bug)"
					error = true
					break
				end
			else
				echo "error: failed to find workshop"
				error = true
				break
			end
		end
	end
	if uber_return_room
		get_cauldron.call
		start_script 'go2', [ uber_return_room.id.to_s ]
		wait_while { running?('go2') }
	end
	invalid_gld.call
	!error
}

forage = proc { |forage_list|
	get_cauldron.call
	if CharSettings['before-forage-script']
		start_script(CharSettings['before-forage-script'])
		wait_while { running?(CharSettings['before-forage-script']) }
	end
	start_forage_time = Time.now
	used_rooms = Array.new
	forage_result = nil
	sanct = Spell[213]
	for name,num in forage_list.dup
		break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
		for room_num in where_is.call(name)
			break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
			start_script 'go2', [ room_num.to_s ]
			wait_while { running? 'go2' }
			unless checkpcs
				start_time = Time.now
				found_count = 0
				sanct.cast if CharSettings['cast-sanctuary'] and sanct.known? and sanct.affordable?
				fput 'kneel'
				empty_hands
				loop {
					break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
					if haste = Spell[506]
						haste.cast if haste.known? and haste.affordable? and not haste.active?
					end
					if presence = Spell[402]
						presence.cast if presence.known? and presence.affordable? and not presence.active?
					end
					if (id = GameObj.right_hand.id)
						dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
					end
					if (id = GameObj.left_hand.id)
						dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
					end
					forage_result = dothistimeout "forage for #{name.sub(/^(?:cluster|layer|mass|sprig|handful) of |^luminescent |^black\-tipped /, '').sub(/^(?:some fetid )/, 'some ')}", 10, /^You forage|^You make so much noise that only the dead would not notice you thrashing about in your unsuccessful search\.$|^You stumble about in a fruitless attempt at foraging\.$|you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\.|^You begin to forage around when your hand comes into contact with something that stabs you in the finger\.$|^As you forage around you suddenly feel a sharp pain in your right hand!|^You begin to forage around when suddenly you feel a burning sensation in your hand\.$|^You fumble about so badly in your search that you can only hope no one was watching you\.$/
					sleep 0.5
					waitrt?
					if forage_result =~ /^You forage briefly and manage to find/
						if id = GameObj.right_hand.id
							dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
						end
						if id = GameObj.left_hand.id
							dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
						end
						if herb_doses[name]
							forage_list[name] = forage_list[name] - herb_doses[name]
							found_count += herb_doses[name]
						else
							forage_list[name] = forage_list[name] - 1
							found_count += 1
						end
						if forage_list[name] < 1
							break
						end
					elsif forage_result =~ /^You begin to forage around when your hand comes into contact with something that stabs you in the finger./
						waitrt?
						unpoison = Spell[114]
						unpoison.cast if unpoison.known? and unpoison.affordable?
					elsif forage_result =~ /^As you forage around you suddenly feel a sharp pain in your right hand!/
						start_script 'useherbs'
						wait_while { running? 'useherbs' }
					elsif forage_result.nil?  or (forage_result =~ /you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\./)
						break
					end
				}
				fill_hands
				end_time = Time.now
				CharSettings['forage time'] ||= Hash.new
				if CharSettings['forage time'][name].nil?
					CharSettings['forage time'][name] = [ 1, 1 ]
				end
				CharSettings['forage time'][name][1] += found_count
				CharSettings['forage time'][name][0] += end_time - start_time
				fput 'stand'
				if forage_list[name] < 1
					forage_list.delete(name)
					break
				end
				break if forage_result =~ /though you are fairly certain this is where it can be found/
			end
			break if forage_result =~ /though you are fairly certain this is where it can be found/
		end
	end
	if CharSettings['after-forage-script']
		if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
		end
		start_script(CharSettings['after-forage-script'])
		wait_while { running?(CharSettings['after-forage-script']) }
	end
	forage_list
}

buy = proc { |shopping_list|
	empty_hands
	get_cauldron.call
	for place,hash in shopping_list.dup
		the_note_name = note_name_from_place.call(place) || note_name.call
		unless note = all_sack_contents.call.find { |obj| obj.name == the_note_name }
			echo "error: missing #{the_note_name}"
			break
		end
		unless room_id = where_is.call(place).first
			echo "error: don't know where #{place} is"
			break
		end
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		if place =~ /^(?:Icemule|River's Rest) empath guild entrance$/
			get_result = dothis "get ##{note.id}", /^You remove|^You already have that|^Get what\?/
			for name,num in hash.dup
				if name == 'vial of faintly glowing aelotoi tears'
					num.times {
						dothis 'buy aelotoi tears', /^A sales clerk .* Handing it to you/
						dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					}
					shopping_list[place].delete(name)
				end
			end
			dothis "put ##{note.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			menu = read_menu.call
			get_result = dothis "get ##{note.id}", /^You remove|^You already have that|^Get what\?/
			if get_result =~ /^Get what\?/
				echo "error: can't find bank note"
				break
			end
			for name,num in hash.dup
				unless order_number = menu[name].sub(/s*\#.*$/, '')
					if equivalent_names = equivalent.find { |list| list.include?(name) }
						for ingredient_name in equivalent_names
							break if order_number = menu[ingredient_name].sub(/s*\#.*$/, '')
						end
					end
					unless order_number
						echo "error: failed to find #{name} in the menu"
						next
					end
				end
				if herb_doses[name]
					num = (num/herb_doses[name].to_f).ceil
				end
				(num/10).times {
					dothis "order #{10} of #{order_number}", /BUY/
					fput 'buy'
					dothis 'open my package', /^You open|^That is already open/
					# fixme: but nothing will fit
					# fixme: leaving the rest in the package.
					dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
					waitrt?
					dothis 'throw my package', /^You throw away/
					if herb_doses[name]
						shopping_list[place][name] -= (herb_doses[name] * 10)
					else
						shopping_list[place][name] -= 10
					end
				}
				num = num % 10
				if num > 1
					dothis "order #{num} of #{order_number}", /BUY/
					fput 'buy'
					dothis 'open my package', /^You open|^That is already open/
					dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
					waitrt?
					dothis 'throw my package', /^You throw away/
					if herb_doses[name]
						shopping_list[place][name] -= (herb_doses[name] * num)
					else
						shopping_list[place][name] -= num
					end
				elsif num == 1
					dothis "order #{order_number}", /BUY/
					fput 'buy'
					100.times { break if checkleft; sleep 0.1 }
					dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					if herb_doses[name]
						shopping_list[place][name] -= (herb_doses[name] * 1)
					else
						shopping_list[place][name] -= 1
					end
				end
				shopping_list[place].delete(name) if shopping_list[place][name] < 1
			end
			dothis "put ##{note.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
		shopping_list.delete(place) if shopping_list[place].empty?
	end
	fill_hands
	shopping_list
}

kill_for = proc { |kill_for_list|
	get_cauldron.call
	if CharSettings['attack-script'].nil?
		echo 'error: no attack script is set up'
	elsif not kill_for_list.empty?
		if CharSettings['before-hunt-script']
			start_script(CharSettings['before-hunt-script'])
			wait_while { running?(CharSettings['before-hunt-script']) }
		end
		for ingredient_name,count in kill_for_list.dup
			recipe_list = $alchemy_recipes.find_all { |r| (r[:product] == ingredient_name) and (r[:steps].first =~ /^kill/) }
			target_list = recipe_list.collect { |r| /^kill\s+(.+)/.match(r[:steps].first).captures.first }
			wander_room_list = Array.new
			target_list.each { |t| wander_room_list.concat(where_is.call(t).collect { |num| num.to_s }) }
			seen_targets = Array.new
			start_kill_room = wander_room_list.first
			if start_kill_room
				current_ingredient_count = start_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
				start_script 'go2', [ start_kill_room.to_s ]
				wait_while { running?('go2') }
				start_time = Time.now
				$alchemy_abort_room = false
				$alchemy_abort_hunt = false
				start_hunt_time = Time.now
				while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
					sleep 0.1
					wander.call
					next if checkpcs
					next if GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{Char.name}/) }
					while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
						target_ids = GameObj.npcs.find_all { |npc| target_list.include?(npc.name) and (npc.status !~ /dead/) }.collect { |npc| npc.id }
						if target_ids.length > 0
							if checkrt > 0 or checkcastrt > 0
								sleep 0.1
							else
								seen_targets = (seen_targets | (GameObj.npcs.to_a.collect { |npc| npc.name } & target_list))
								start_script(CharSettings['attack-script'], target_ids)
								wait_while { running?(CharSettings['attack-script']) }
								if $alchemy_abort_room or $alchemy_abort_hunt
									$alchemy_abort_room = false
									break
								end
							end
						else
							break
						end
						if $alchemy_abort_hunt
							$alchemy_abort_hunt = false
							break
						end
					end
					current_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
					break unless current_ingredient_count < start_ingredient_count + count
					break if Time.now - start_time > CharSettings['max-hunt-time']
				end
				end_time = Time.now
				CharSettings['kill time'] ||= Hash.new
				for npc in seen_targets
					CharSettings['kill time'][npc] ||= Hash.new
					if CharSettings['kill time'][npc][ingredient_name].nil?
						CharSettings['kill time'][npc][ingredient_name] = [ 1, 1 ]
					end
					CharSettings['kill time'][npc][ingredient_name][0] += (end_time - start_time) / seen_targets.length.to_f
					CharSettings['kill time'][npc][ingredient_name][1] += (current_ingredient_count - start_ingredient_count) / seen_targets.length.to_f
				end
				kill_for_list[ingredient_name] = kill_for_list[ingredient_name] - (current_ingredient_count - start_ingredient_count)
				kill_for_list.delete(ingredient_name) if kill_for_list[ingredient_name] < 1
			else
				echo 'error: kill: failed to find starting room'
			end
		end
		if CharSettings['after-hunt-script']
			if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
			end
			start_script(CharSettings['after-hunt-script'])
			wait_while { running?(CharSettings['after-hunt-script']) }
		end
	end
	kill_for_list
}

go_get_crap = proc { |check_info|
	error = false
	unless check_info[:forage].empty? and check_info[:kill_for].empty? and check_info[:buy].empty?
		unless check_info[:kill_for].empty?
			check_info[:kill_for] = kill_for.call(check_info[:kill_for])
			unless check_info[:kill_for].empty?
#				echo "error: failed to find: #{check_info[:kill_for].keys.join(', ')}"
				echo "error: failed to find: #{check_info[:kill_for].inspect}"
				error = true
			end
		end
		unless error or check_info[:forage].empty?
			check_info[:forage] = forage.call(check_info[:forage])
			unless check_info[:forage].empty?
#				echo "error: failed to find: #{check_info[:forage].keys.join(', ')}"
				echo "error: failed to find: #{check_info[:forage].inspect}"
				error = true
			end
		end
		unless error or check_info[:buy].empty?
			check_info[:buy] = buy.call(check_info[:buy])
			unless check_info[:buy].empty?
#				echo "error: failed to buy: #{check_info[:buy].keys.join(', ')}"
				echo "error: failed to buy: #{check_info[:buy].inspect}"
				error = true
			end
		end
	end
	!error
}

do_task_assembly = proc {
	error = false
	return_room = Room.current
	empty_hands
	get_cauldron.call
	if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		dothis 'get cloth', /^You take/
	else
		echo 'error: failed to find cleaning supplies'
		error = true
	end
	unless error
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			haste = Spell[506]
			for room_id in room_list
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				haste.cast if haste.known? and haste.affordable? and not haste.active?
				clean_result = dothis 'polish ass', /You have|Perhaps you should check another workshop/
				waitrt?
				break if clean_result =~ /You have completed/
			end
			fput 'put cloth'
		else
			echo 'error: failed to find workshop'
			error = true
		end
	end
	fill_hands
	unless Room.current == return_room
		start_script 'go2', [ return_room.id.to_s ]
		wait_while { running?('go2') }
	end
	invalid_gld.call
	!error
}

do_task_distill = proc {
	room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
	if room_list.length > 0
		if room_list.include?(Room.current.id)
			return_room = nil
		else
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ room_list.first.to_s ]
			wait_while { running?('go2') }
		end
		haste = Spell[506]
		loop {
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "pour alembic", /^You collect/
			sleep 2
			waitrt?
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "light alembic", /^You focus/
			waitfor "pressure within it builds"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "turn alembic", /^Turning a mithril lever/
			waitfor "pressure within it builds"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "turn alembic", /^Turning a mithril lever/
			waitfor "the flame beneath it suddenly dies down"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "clean alembic", /^Using a barrel of water/
			sleep 2
			waitrt?
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "get alembic", /^Having cleaned the/
			line = waitfor "You have"
			waitrt?
			break if line == "[You have completed your training task.]"
		}
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		invalid_gld.call
		true
	else
		echo 'error: failed to find workshop'
		false
	end
}

do_task_crucible = proc {
	error = false
	if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		if Room.current.id == room_id
			return_room = nil
		else
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
		end
		empty_hands
		dothistimeout 'get rag', 10, /^You take/
		haste = Spell[506]
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			for room_id in room_list
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				haste.cast if haste.known? and haste.affordable? and not haste.active?
				clean_result = dothistimeout 'clean crucible', 10, /You have|Perhaps you should check another workshop/
				waitrt?
				sleep 0.5
				break if clean_result =~ /You have completed/
			end
		else
			echo 'error: failed to find workshop'
			error = true
		end
		fput 'drop rag'
		fill_hands
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
	else
		echo 'error: failed to find cleaning supplies room'
		error = true
	end
	invalid_gld.call
	!error
}

do_task_sweep = proc {
	error = false
	if cleaning_supplies_room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ cleaning_supplies_room_id.to_s ]
			wait_while { running?('go2') }
			empty_hands
			dothis 'get broom', /^You take/
			dothis 'get pan', /^You take/
			room_count = 0
			haste = Spell[506]
			location = Room[room_list.first].location
			room_list.delete_if { |room_id| Room[room_id].location != location }
			sweep_result = nil
			loop {
				for room_id in room_list
					start_script 'go2', [ room_id.to_s ]
					wait_while { running?('go2') }
					loop {
						haste.cast if haste.known? and haste.affordable? and not haste.active?
						sweep_result = dothis 'sweep dust', /^Roundtime|^Sweep what|^Your dust pan appears to be full\.|^But your dust pan is already full|^Someone else is already sweeping that pile of dust|^\.\.\.wait|^What did the dust ever do to you\?$/
						sleep 0.5
						waitrt?
						break if sweep_result =~ /^Sweep what|^Your dust pan appears to be full\.$|^But your dust pan is already full|^Someone else is already sweeping that pile of dust|^What did the dust ever do to you\?$/
					}
					break if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
				end
				start_script 'go2', [ cleaning_supplies_room_id.to_s ]
				wait_while { running?('go2') }
				if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
					put_result = dothis 'put my pan in bin', /^.You have/
					fput 'put broom'
					if put_result == '[You have completed your training task.]'
						fput 'put pan'
						break
					end
					dothis 'get broom', /^You take/
				else
					fput 'put broom'
					fput 'get broom'
				end
			}
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
			fill_hands
		else
			echo 'error: failed to find workshop'
			error = true
		end
	else
		echo 'error: failed to find cleaning supplies' 
		error = true
	end
	invalid_gld.call
	!error
}

do_task_grind = proc {
	if room_id = where_is.call("#{Char.prof.downcase} alchemy shop").first
		return_room = Room.current
		get_cauldron.call
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		haste = Spell[506]
		clerk = checknpcs.find { |npc_name| npc_name =~ /^clerk$|acolyte$|^hobgoblin$|^gnome$|^apothecary$|^apprentice$/ } || 'clerk'
		empty_hands
		result = dothis 'get mortars', /^You take|^You already have a stone mortar|^Get what\?/
		if result =~ /^Get what\?/
			result = dothis 'get stone mortar', /^You take|^You already have a stone mortar/
		end
		shelf = GameObj.room_desc.find { |obj| obj.noun == 'shelf' } || GameObj.loot.find { |obj| obj.noun == 'shelf' }
		loop {
			script.want_downstream = false
			script.want_downstream_xml = true
			contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there\./
			if contents_line =~ /There is nothing on there\./
				script.want_downstream = true
				script.want_downstream_xml = false
				dothistimeout "ask #{clerk} about ingredients", 10, /^You ask the .*? about ingredients\.$/
				script.want_downstream = false
				script.want_downstream_xml = true
				contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there$/
			end
			script.want_downstream = true
			script.want_downstream_xml = false
			grindable_id, grindable_noun = /you see .*?<a exist="(.*?)" noun="(.*?)"/.match(contents_line).captures[0..1]
			get_result = dothistimeout "get ##{grindable_id}", 10, /^You take/
			if get_result
				loop {			
					haste.cast if haste.known? and haste.affordable? and not haste.active?
					grind_result = dothistimeout "grind my #{grindable_noun}", 10, /^You take the stone pestle into your free hand and grind|ground as much as possible|as ground as it'?s going to get|^Grind what/
					waitrt?
					break if grind_result =~ /ground as much as possible|as ground as it'?s going to get|^Grind what/
				}
			end
			give_result = dothistimeout "give my mortar to #{clerk}", 10, /^\[You have/
			break unless give_result =~ /\[You have [0-9]+ repetitions? remaining\.\]/
		}
		fput 'put mortar'
		fill_hands
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		invalid_gld.call
		true
	else
		echo 'error: failed to find alchemy shop'
		false
	end
}

do_task_grind_mine = proc {
	$alchemy_grind_history ||= Hash.new
	$alchemy_grind_history.delete_if { |recipe,time| time > Time.now + 600 }
	check_list = Array.new
	recipe_list = $alchemy_recipes.find_all { |recipe| (recipe[:steps].first =~ /^grind/) and not $alchemy_grind_history.keys.include?(recipe[:product]) }
	for recipe in recipe_list
		tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0 }
		tracker = recursive_check_recipe.call(recipe, tracker, top_level=true)
		fixed_buy = Hash.new
		tracker[:buy].each_pair { |where_what,how_many|
			where, what = where_what.split(';')
			fixed_buy[where] ||= Hash.new
			fixed_buy[where][what] = how_many
		}
		tracker[:buy] = fixed_buy
		tracker.delete(:claimed_ingredients)
		tracker.delete(:ingredient_count)
		tracker.delete(:extra_ingredients)
		check_list.push(tracker)
	end
	check_list.delete_if { |check| !check[:error].empty? or check[:steps].first !~ /^grind/ }
	check_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
	result = nil
	empty_hands
	for check_info in check_list
		return_room = Room.current
		show_check.call(check_info)
		got_crap = go_get_crap.call(check_info)
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		if got_crap
			do_steps.call(check_info[:steps])
			$alchemy_grind_history[check_info[:recipe_count].keys.first] = Time.now
			result = reget.reverse.find { |line| line =~ /^\[You have|as ground as it'?s going to get/ }
			break unless result =~ /remaining/
		end
	end
	fill_hands
	invalid_gld.call
	if result =~ /You have completed/
		true
	else
		false
	end
}

do_task = proc { |type|
	error = false
	if gld.call[type][:reps] > 0
		empty_hands
		if gld.call[type][:task] == 'visit a skilled master for a lesson'
			if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				if checkpoison # fixme: failed
					echo "masters won't talk to you while you're poisoned..."
					wait_while { checkpoison }
					start_script 'go2', [ room_id.to_s ]
					wait_while { running?('go2') }
				end
				dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
				while line = get
					if line =~ /First, we light the cauldron\.  Go ahead\.|Please #{XMLData.name}, LIGHT the cauldron/
						fput 'light cauldron'
					elsif line =~ /Excellent, now try to extinguish it\.|Please #{XMLData.name}, EXTINGUISH the cauldron\./
						fput 'extinguish cauldron'
					elsif line =~ /\[Use the ALCHEMY SEAL command to seal the solution inside the training cauldron\.\]|\[You can use the ALCHEMY verb to SEAL the mixture in the cauldron\.\]/
						fput 'alchemy seal'
					elsif line =~ /try a recipe with (.*?) as a component/
						required_step = $1.downcase
						recipe_list = gld_suggestions.call[type][:recipes]
						recipe_list.delete_if { |recipe_name| !$alchemy_recipes.any? { |recipe| (recipe[:product] == recipe_name) and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } } }
						check_info = check_recipe.call(recipe_list, 1)
						if !check_info[:error].empty? or check_info[:steps].any? { |step| step =~ /^extract|^distill|^special/ } or not check_info[:buy].empty? or not check_info[:forage].empty? or not check_info[:kill_for].empty?
							move 'out'
							reps = gld.call[type][:reps]
							while reps > 0
								check_info = check_recipe.call(recipe_list, reps)
								break if check_info[:error].empty?
								reps -= 1
							end
							if reps < 1
								echo 'error: failed to find a decent recipe'
								sleep 0.5
								error = true
								break
							end
							show_check.call(check_info)
							break unless go_get_crap.call(check_info)
							go_empty_workshop.call
							unless is_workshop.call
								echo 'error: failed to find a workshop'
								error = true
								break
							end
							do_steps.call(check_info[:prepare_steps])
							get_cauldron.call
							if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
								start_script 'go2', [ room_id.to_s ]
								wait_while { running?('go2') }
								dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
							else
								echo 'error: failed to find alchemy masters'
								error = true
								break
							end
						else
							show_check.call(check_info)
							do_steps.call(check_info[:steps])
						end
					elsif line == '[You have completed your training task.]'
						invalid_gld.call
						move 'out'
						break
					end
				end
			else
				echo 'error: failed to find alchemy masters'
				error = true
			end
		elsif gld.call[type][:task] =~ /^practice creating tough solutions|follow some tough recipes and create some items|^practice (?:distilling|extracting) for reagents/
			check_info = check_recipe.call(gld_suggestions.call[type][:recipes], gld_suggestions.call[type][:reps])
			if check_info[:error].empty?
				get_cauldron.call
				show_check.call(check_info)
				if go_get_crap.call(check_info)
					go_empty_workshop.call
					if is_workshop.call
						do_steps.call(check_info[:steps])
						get_cauldron.call
					else
						echo "error: failed to find workshop"
						error = true
					end
				else
					error = true
				end
			else
				echo "warning: failed to find a decent recipe"
				error = true
			end
		elsif gld.call[type][:task] =~ /^visit the cauldron workshop and practice making solutions/
			check_info = check_recipe.call(gld_suggestions.call[type][:recipes], gld_suggestions.call[type][:reps])
			if check_info[:error].empty?
				if cauldron_room_id = where_is.call("#{Char.prof.downcase} alchemy training cauldron").first
					get_cauldron.call
					show_check.call(check_info)
					if go_get_crap.call(check_info)
						if check_info[:prepare_steps]
							go_empty_workshop.call
							do_steps.call(check_info[:prepare_steps])
							get_cauldron.call
							start_script 'go2', [ cauldron_room_id.to_s ]
							wait_while { running?('go2') }
							do_steps.call(check_info[:finish_steps])
						else
							start_script 'go2', [ cauldron_room_id.to_s ]
							wait_while { running?('go2') }
							show_check.call(check_info)
							fput 'stance offensive' unless stance =~ /offensive/
							do_steps.call(check_info[:steps])
						end
					else
						error = true
					end
				else
					echo "error: failed to find training cauldron"
					error = true
				end
			else
				echo "warning: failed to find a decent recipe"
				error = true
			end
		elsif gld.call[type][:task] == 'practice grinding various ingredients with a mortar and pestle'
			get_cauldron.call
			go_empty_workshop.call
			result = do_task_grind_mine.call
			error = !result
		elsif gld.call[type][:task] == 'polish tarnished lens assemblies and any nearby lenses in alchemy labs'
			result = do_task_assembly.call
			error = !result
		elsif gld.call[type][:task] == "grind some ingredients for the guild's supply"
			result = do_task_grind.call
			error = !result
		elsif gld.call[type][:task] == "distill water for the guild's supply"
			result = do_task_distill.call
			error = !result
		elsif gld.call[type][:task] == 'clean alchemic equipment in the labs'
			result = do_task_crucible.call
			error = !result
		elsif gld.call[type][:task] == 'sweep the alchemy labs'
			result = do_task_sweep.call
			error = !result
		end
		fill_hands
	end
	!error
}

top_off_jars = proc {
	empty_hands
	for jar in alchemy_sack.call.contents.find_all { |obj| obj.after_name =~ /^containing / }
		next if jar.after_name == 'containing fine white powder'
		got_jar = false
		for item in all_sack_contents.call.find_all { |obj| jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
			unless got_jar
				dothis "get ##{jar.id}", /^You remove|^You already have that/
				got_jar = true
			end
			result = dothis "_drag ##{item.id} ##{jar.id}", /^You add|is full/
			if result =~ /is full/
				dothis "put ##{item.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				break
			else
				ingredient_count[jar.id] = ingredient_count[jar.id] + 1 unless ingredient_count[jar.id].nil?
			end
		end
		if got_jar
			dothis "put ##{jar.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
	fill_hands
}

look_in_jars = proc {
	for jar in all_sack_contents.call.find_all { |obj| obj.after_name =~ /^containing / }
		next if jar.after_name == 'containing fine white powder'
		fput "look in ##{jar.id}"
	end
}

throw_away = proc {
	if room_id = where_is.call('trash').first
#		trash_items = loot_sack.call.contents.to_a.find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras|yabathilium|talneo)$|silvery potion|^flask of pure water$|^grot t'kel potion$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
		trash_items = [ loot_sack.call.contents.to_a + alchemy_sack.call.contents.to_a ].find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras|yabathilium|talneo)$|silvery potion|^flask of pure water$|^grot t'kel potion$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
		unless trash_items.empty?
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			if trash_container = GameObj.loot.find { |obj| obj.noun =~ /^(?:receptacle|bin|barrel|trashcan)$/ }
				empty_hand
				for item in trash_items
					dothistimeout "get ##{item.id}", 3, /^You remove/
					dothistimeout "put ##{item.id} in ##{trash_container.id}", 3, /^You put|^As you place|^There appears .*? significant value|^Are you crazy\?!\?  Do you know what that's worth!\?!/
					if (GameObj.right_hand.id == item.id) or (GameObj.left_hand.id == item.id)
						dothistimeout "put ##{item.id} in ##{lootsack.call.id}", 3, /^You put/
					end
				end
				fill_hand
			end
		end
	else
		echo 'error: failed to find trash room'
	end
}

sell = proc {
	sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:iron wand|polished bloodwood wand)$/ }
	unless sell_items.empty?
		if room_id = where_is.call('pawnshop').first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			empty_hand
			for item in sell_items
				fput "get ##{item.id}"
				fput "sell ##{item.id}"
				sleep 0.2
			end
			fill_hand
		else
			echo 'warning: failed to find a pawnshop within max-travel-time'
		end
	end
	sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:pale green potion|dark shimmering oil|iridescent opal wand|some dull silvery dust|rohnuru potion|minor mana potion|sarmoc potion|minor mana potion|lesser mana potion|smooth crystalline wand|lesser health potion|glowing blue potion|clear potion|lesser mana regeneration potion|hazy glass vial|silvery potion|pale sea\-green potion|lesser mana potion|some pale glimmering dust|scintillating pale blue potion|smooth stone talisman|lesser mana-well potion|crystalline vial)$/ or (obj.noun == 'vial' and obj.after_name == 'containing fine white powder') }
	unless sell_items.empty?
		if room_id = where_is.call('consignment').first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			empty_hand
			for item in sell_items
				fput "get ##{item.id}"
				fput "sell ##{item.id}"
				sleep 0.2
			end
			fill_hand
		else
			echo 'warning: failed to find a consignment shop within max-travel-time'
		end
	end
}

buy_elusive = proc {
	unless UserVars.needed_reagents.nil? or UserVars.needed_reagents.empty?
		if note = all_sack_contents.call.find { |obj| obj.name == note_name.call }
			if room_id = where_is.call('reagent shop').first and (adj_room_id = Room[room_id].wayto.keys.first) and (way = Room[adj_room_id].wayto[room_id.to_s]) and (way.class == String)
				start_script 'go2', [ adj_room_id ]
				wait_while { running?('go2') }
				move way
				if table = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun == 'table' }
					count = Hash.new
					script.want_downstream_xml = true
					result = dothistimeout "look on ##{table.id}", 3, /^(?:<.*?>)?On the.*?you see/
					script.want_downstream_xml = false
					if table.contents.empty?
						table_contents = Array.new
						results = result.sub(/^.*?you see /, '')
						while str = results.slice!(/.*?<a.*?\/a>/)
							if str.sub(/^(?:, | and )/, '') =~ /^(.*?)<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>(.*)$/
								table_contents.push GameObj.new($2, $3, $4, $1.strip, $5.strip)
							end
						end
					else
						table_contents = table.contents
					end
					unless table_contents.empty?
						if table_contents.any? { |obj| obj.name =~ /#{UserVars.needed_reagents}/ }
							empty_hands
							dothistimeout "get ##{note.id}", 10, /^You remove|^You already have that\./
							for obj in table_contents
								if obj.name =~ /#{UserVars.needed_reagents}/
									unless count[obj.name]
										count[obj.name] = all_sack_contents.call.find_all { |o| o.name == obj.name }.length
										jar_list = all_sack_contents.call.find_all { |o| o.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
										for jar in jar_list
											if CharSettings['hide-jar-check']
												action = proc { |server_string|
													if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
														DownstreamHook.remove('hide-jar-check')
														nil
													else
														server_string
													end
												}
												DownstreamHook.add('hide-jar-check', action)
											end
											look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
											count[obj.name] += look_result.slice(/[0-9]+/).to_i
										end
									end
									if count[obj.name] < 20
										did_something = true
										count[obj.name] = count[obj.name].to_i + 1
										fput 'unhide' if invisible?
										fput "buy ##{obj.id}"
										dothistimeout "put my #{obj.noun} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
									end
								end
							end
							dothistimeout "put ##{note.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
							sleep 0.05
							top_off_jars.call
							empty_jar_list = alchemy_sack.call.contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ and obj.after_name.nil? }
							unless empty_jar_list.empty?
								important_stuff = all_sack_contents.call.find_all { |obj| elusive_reagent_cost.keys.include?(obj.name) and not all_sack_contents.call.any? { |jar| jar.noun =~ /^(?:jar|beaker|bottle)$/ and jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ } }
								important_stuff_count = Hash.new
								important_stuff.each { |stuff| important_stuff_count[stuff.name] = important_stuff_count[stuff.name].to_i + 1 }
								important_stuff_count = important_stuff_count.sort { |a,b| b[1] <=> a[1] }.collect { |n| n[0] }
								for empty_jar in empty_jar_list
									if name = important_stuff_count.pop
										dothistimeout "get ##{empty_jar.id}", 10, /^You remove|^You already have that/
										for obj in all_sack_contents.call
											if obj.name == name
												result = dothistimeout "_drag ##{obj.id} ##{empty_jar.id}", 10, /^You add|^You put|is full/
												if result =~ /is full/
													dothistimeout "put ##{obj.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
													break
												end
											end
										end
										dothistimeout "put ##{empty_jar.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
									end
								end
							end
							fill_hands
						end
					end
				else
					echo 'error: no table'
				end
			else
				echo 'error: failed to find a reagent shop'
			end
		else
			echo "error: missing #{note_name.call}"
		end
	end
}

if script.vars[1].downcase == 'set'
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	if (script.vars[2] =~ /^(?:hide\-gld\-check|hide\-bundle\-check|hide\-jar\-check|cast\-sanctuary|buy\-crap|throw\-away\-crap|sell\-crap)$/i) and (script.vars[3] =~ /^(?:on|off|yes|no|true|false)$/i)
		CharSettings[script.vars[2].downcase] = fix_option[script.vars[3].downcase]
		echo 'setting saved'
	elsif (script.vars[2] =~ /^(?:max\-travel\-time|max\-hunt\-time|max\-forage\-time|cost\-per\-second)$/i) and (script.vars[3] =~ /^[0-9]+$/)
		CharSettings[script.vars[2].downcase] = script.vars[3].to_i
		echo 'setting saved'
	elsif (script.vars[2] =~ /^(?:attack\-script|before\-hunt\-script|after\-hunt\-script|before\-forage\-script|after\-forage\-script)$/i) and script.vars[3]
		CharSettings[script.vars[2].downcase] = script.vars[3]
		echo 'setting saved'
	else
		echo "you're doing it wrong"
	end		
elsif script.vars[1].downcase == 'add'
	if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
		matching_recipes = $alchemy_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
				if matching_recipes.empty?
					matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
				end
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
			if CharSettings['favorite-recipes'].include?(recipe_name)
				echo "#{recipe_name} is already a favorite recipe."
			else
				CharSettings['favorite-recipes'].push(recipe_name)
				set_needed_reagents.call
				echo "#{recipe_name} is now a favorite recipe."
			end
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
		else
			echo 'no matching recipe found.'
		end
	else
		echo "you're doing it wrong"
	end
elsif script.vars[1].downcase == 'del'
	if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
		matching_recipes = $alchemy_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
				if matching_recipes.empty?
					matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
				end
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
			if CharSettings['favorite-recipes'].include?(recipe_name)
				CharSettings['favorite-recipes'].delete(recipe_name)
				set_needed_reagents.call
				echo "#{recipe_name} is no longer a favorite recipe."
			else
				echo "#{recipe_name} is not favorite recipe."
			end
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
		else
			echo 'no matching recipe found.'
		end
	else
		echo "you're doing it wrong"
	end
elsif script.vars[1].downcase == 'suggest'
	output = "\n"
	for type in [ 'alchemy', 'potions', 'trinkets' ]
		output.concat "\n#{type}:\n"
		if gld_suggestions.call[type][:recipes].nil? or gld_suggestions.call[type][:recipes].empty? or gld_suggestions.call[type][:reps].zero?
			output.concat "   (none)\n"
		else
			max_recipe_name = 0
			gld_suggestions.call[type][:recipes].each { |recipe_name| max_recipe_name = [max_recipe_name,recipe_name.length].max }
			for recipe_name in gld_suggestions.call[type][:recipes]
				recipe = $alchemy_recipes.find { |r| r[:product] == recipe_name }
				output.concat "   #{recipe_name.ljust(max_recipe_name)}   ranks: #{recipe[:rank][0].to_s.rjust(2)}-#{recipe[:rank][1].to_s.rjust(2)}"
				check = check_recipe.call(recipe_name, gld_suggestions.call[type][:reps])
				output.concat "   cost: #{check[:cost].to_i.to_s.rjust(5)}   time: #{(check[:time]/60.0).as_time}"
				has_step = Array.new
				recipe[:steps].each { |step| if step =~ /^(boil|infuse|simmer|chant|distill|extract|channel)/ and not has_step.include?($1); has_step.push($1); end }
				output.concat "   includes: #{has_step.join(', ')}" unless has_step.empty?
				unless check[:error].empty?
					missing = check[:error].collect { |a,b| "#{a} (#{b})" }
					output.concat "   #{monsterbold_start}missing:#{monsterbold_end} #{missing.join(', ')}"
				end
				output.concat "\n"
			end
		end
	end
	output.concat "\n"
	if defined?(_respond)
		_respond output
	else
		$stdout.puts output rescue()
	end
	close_sacks.call
elsif script.vars[1] =~ /^(check|make|prepare)$/i and not script.vars[2].nil?
	if $1.downcase == 'check'
		check_only = true
	else
		check_only = false
	end
	if $1.downcase == 'prepare'
		prepare_only = true
	else
		prepare_only = false
	end
	repetitions = (script.vars[2..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
	script.vars.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }
	search_string = script.vars[2..-1].join(' ')
	unless recipe_name = $alchemy_recipes.find { |r| r[:spell] == search_string }[:product]
		matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
			exit
		end
	end
	unless recipe_name
		echo 'no matching recipe'
		exit
	end
	check_info = check_recipe.call(recipe_name, repetitions)
	show_check.call(check_info)
	if check_info[:error].empty? and not check_only
		echo 'starting in 3 seconds...'
		sleep 3
		empty_hands
		return_room = Room.current
		exit unless go_get_crap.call(check_info)
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		if prepare_only
			do_steps.call(check_info[:prepare_steps])
		else
			do_steps.call(check_info[:steps])
		end
		get_cauldron.call
		fill_hands
		close_sacks.call
	end
	close_sacks.call
elsif script.vars[1].downcase == 'task' and not script.vars[2].nil?
	if script.vars[2].downcase == 'distill'
		do_task_distill.call
	elsif script.vars[2].downcase == 'assembly'
		do_task_assembly.call
	elsif script.vars[2].downcase == 'crucible'
		do_task_crucible.call
	elsif script.vars[2].downcase == 'grind'
		do_task_grind.call
	elsif script.vars[2].downcase == 'sweep'
		do_task_sweep.call
	elsif script.vars[2].downcase =~ /^grind\-?mine$/
		do_task_grind_mine.call
	elsif script.vars[2].downcase =~ /^(?:alchemy|potions|trinkets)$/
		do_administrator.call
		do_task.call(script.vars[2].downcase)
		do_administrator.call
	else
		echo 'unknown task'
	end
elsif script.vars[1].downcase == 'jar'
	top_off_jars.call
	look_in_jars.call
	close_sacks.call
elsif script.vars[1].downcase == 'buy'
	buy_elusive.call
	look_in_jars.call
	close_sacks.call
elsif script.vars[1].downcase == 'need'
	set_needed_reagents.call
elsif script.vars[1].downcase == 'test'
#	respond gld.call.inspect
#	exit
	all_reagents = Array.new
	$alchemy_recipes.each { |recipe|
		recipe[:steps].each { |step|
			if step =~ /^(?:add|extract|distill|grind) (.+)$/
				reagent = $1
				all_reagents.push(reagent) unless all_reagents.include?(reagent)
			end
		}
	}
	all_reagents.delete_if { |reagent|
		elusive_reagent_cost.keys.include?(reagent) or $alchemy_recipes.any? { |recipe| recipe[:product] == reagent } or (grind_recipe = $alchemy_recipes.find { |recipe| recipe[:steps].first == "grind #{reagent}" } and $alchemy_recipes.any? { |recipe| (recipe[:product] == grind_recipe[:product]) and (recipe[:steps].first !~ /^grind/) })
	}
	respond all_reagents
	exit
	results = check_recipe.call('dark translucent crystal', 1)
	show_check.call(results)
	echo results.inspect
elsif script.vars[1].downcase == 'auto'
	if script.vars[2].downcase =~ /^(alchemy|trinkets|potions)$/
		type_list = [ $1 ]
		if script.vars[3].downcase =~ /^(alchemy|trinkets|potions)$/
			type_list.push($1)
		end
	else
		type_list = [ 'alchemy', 'potions', 'trinkets' ]
	end
	set_needed_reagents.call if UserVars.needed_reagents.nil?
	empty_hands
	loop {
		do_administrator.call
		for type in type_list
			do_task.call(type)
		end
		get_cauldron.call
		sleep 0.5
		if CharSettings['throw-away-crap']
			throw_away.call
		end
		if CharSettings['sell-crap']
			sell.call
		end
		# fixme: not sure what the real limit is..
		$last_alchemy_buy ||= Time.now - 481
		if CharSettings['buy-crap'] and (Time.now - $last_alchemy_buy) > 480
			buy_elusive.call
			$last_alchemy_buy = Time.now
		end
		if ((silvers = check_silvers.call) > 0) and room_id = where_is.call('bank').first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			fput "deposit #{silvers}"
		end
		sleep 0.5
	}
elsif script.vars[1].downcase == 'list'
	fix_option = { false => 'off', true => 'on' }
	output = "\n"
	output.concat "   cost-per-second:      #{CharSettings['cost-per-second']}\n"
	output.concat "   max-travel-time:      #{CharSettings['max-travel-time']}\n"
	output.concat "   max-hunt-time:        #{CharSettings['max-hunt-time']}\n"
	output.concat "   max-forage-time:      #{CharSettings['max-forage-time']}\n"
	output.concat "   hide-gld-check:       #{fix_option[CharSettings['hide-gld-check']]}\n"
	output.concat "   hide-bundle-check:    #{fix_option[CharSettings['hide-bundle-check']]}\n"
	output.concat "   hide-jar-check:       #{fix_option[CharSettings['hide-jar-check']]}\n"
	output.concat "   cast-sanctuary:       #{fix_option[CharSettings['cast-sanctuary']]}\n"
	output.concat "   buy-crap:             #{fix_option[CharSettings['buy-crap']]}\n"
	output.concat "   trow-away-crap:       #{fix_option[CharSettings['throw-away-crap']]}\n"
	output.concat "   sell-crap:            #{fix_option[CharSettings['sell-crap']]}\n"
	output.concat "   attack-script:        #{CharSettings['attack-script']}\n"
	output.concat "   before-hunt-script:   #{CharSettings['before-hunt-script']}\n"
	output.concat "   after-hunt-script:    #{CharSettings['after-hunt-script']}\n"
	output.concat "   before-forage-script: #{CharSettings['before-forage-script']}\n"
	output.concat "   after-forage-script:  #{CharSettings['after-forage-script']}\n"
	output.concat "\n"
	unless CharSettings['favorite-recipes'].empty?
		output.concat "   favorite-recipes:\n"
		for recipe_name in CharSettings['favorite-recipes']
			output.concat "      #{recipe_name}\n"
		end
		output.concat "\n"
	end
	respond output
else
	output = "\n"
	output.concat "Setup:\n"
	output.concat "   #{$clean_lich_char}set change alchemysack <container>\n"
	output.concat "   #{$clean_lich_char}set change lootsack <container>\n"
	output.concat "   #{$clean_lich_char}set change herbsack <container>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} set cost-per-second <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set max-travel-time <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set max-hunt-time <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-gld-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-bundle-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-jar-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set cast-sanctuary <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set buy-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set throw-away-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set sell-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set attack-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set before-hunt-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set after-hunt-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set before-forage-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set after-forage-script <scriptname>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} add fav <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} del fav <scriptname>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list\n"
	output.concat "\n"
	output.concat "Usage:\n"
	output.concat "   #{$clean_lich_char}#{script.name} make <recipe>\n"
	output.concat "   #{$clean_lich_char}#{script.name} make <recipe> x<repetitions>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe>                  buys, forages, and makes all the requirements, so you\n"
	output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe> x<repetitions>     can make the recipe later without having to run around\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} check <recipe>                    gives the same summary as make, but does nothing\n"
	output.concat "   #{$clean_lich_char}#{script.name} check <recipe> x<repetitions>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} suggest                           attempts to list the recipes you'll get ranks for\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} jar                               fills your jars with loose items of the same type\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} buy\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} need\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} task alchemy\n"
	output.concat "   #{$clean_lich_char}#{script.name} task potions\n"
	output.concat "   #{$clean_lich_char}#{script.name} task trinkets\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} task distill\n"
	output.concat "   #{$clean_lich_char}#{script.name} task assembly\n"
	output.concat "   #{$clean_lich_char}#{script.name} task grind\n"
	output.concat "   #{$clean_lich_char}#{script.name} task grind-mine\n"
	output.concat "   #{$clean_lich_char}#{script.name} task crucible\n"
	output.concat "   #{$clean_lich_char}#{script.name} task sweep\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} auto                              gain ranks afk (somewhat buggy)\n"
	output.concat "   #{$clean_lich_char}#{script.name} auto <alchemy|potions|trinkets>   only work on the given area\n"
	output.concat "\n"
	respond output 
end

=begin
	The surface of the solution in the iron cauldron shimmers in response!
	The diamond lens shatters!
=end
