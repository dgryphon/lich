##quiet
=begin

	SpiffyLooter by SpiffyJr (spiffyjr@gmail.com)

=end

@@version = 4.10122010

unless defined?(GameObj.load_data)
	echo "this script requires an update to lich (;updater update)"
	exit
end

################################################################################
# Variable declaration
################################################################################
# Character Settings
settings 					= CharSettings.to_hash
settings['skin_exclude'] 	||= Array.new

# Globals
$sloot_has_disk		||= false
$sloot_disk_full	||= false
$sloot_hooks 		= Array.new

# Common vars
closed_sacks		= Array.new
found_sacks			= Hash.new	# cache for found sacks (save those cycles!)
invalid_ammo 		= LimitedArray.new; invalid_ammo.max_size = 25
prev_stance			= checkstance
prev_stance_percent	= percentstance
skin_prepared		= false
stored_item			= nil
stored_result		= nil

################################################################################
# Procedures
################################################################################
# Uses go2 to run to a room
go2 = proc { |room|
	next if Room.current.id.to_s == room.to_s

	wait_while{ running?('go2') }
	start_script('go2', [ room.to_s, '_disable_confirm_' ]);
	wait_while{ running?('go2') }
}
	
# Log some useful stuffs
write_log = proc { |msg| Script.log("[#{Time.now.strftime('%Y-%m-%d %I:%M:%S %p')}] (#{Char.name}) #{msg}\n") }

# Hooray for perdy messages!
msg = proc { |str,type|
	start_string = ""
	end_string = ""

	if type == :bold || type == :all
		start_string += "#{monsterbold_start}"
		end_string += "\n#{monsterbold_end}"
	end
	
	if (type == :mono || type == :all) && !$fake_stormfront
		start_string += "<output class=\"mono\"/>"
		end_string += "\r\n<output class=\"\"/>"
	end
	
	puts sprintf '%s%s%s', start_string, str, end_string
}

# Setup GUI for sloot
setup = proc {
	gtk_globals = Hash.new
	gtk_locals = Hash.new

	window = window_action = nil
	
	Gtk.queue {
		ttips = Gtk::Tooltips.new.enable
		ttips_text = { 
			'enable_close_sacks' => "Checking this will attempt to keep your sacks closed.",
			'overflowsack' => "Enter your overflow sack(s) to place loot into when your regular sack is full.\ne.g., \"pack,sack,cloak,hat\"",
			'enable_search_all' => "Checking this enables searching all dead critters rather than one at a time.",
			'enable_disking' => "Checking this enables disking of boxes if you have a disk.",
			'enable_phasing' => "Checking this enables phasing of boxes if you meet the requirements.\nRequires: level 4 Sorcerer with 704 learned",
			'enable_gather' => "Checking this enables gathering of ammunition after looting.",
			'ammo_name' => "Enter the full name of your ammunition here.",
			'enable_safe_hiding' => "Checking this enables looting only if not hiding or there are no creatures present.",
			'safe_ignore' => "Enter the name of any creatures you want to ignore when safe hiding.\nThis field is a regular expression so use \"|\" to separate names.",
			'enable_stow_left' => "Checking this will store your left hand to loot if your hands are full.",
			'enable_self_drops' => "Checking this enables looting of items that were dropped from creatures you searched.",
			'enable_skinning' => "Checking this enables all skinning functionality.",
			'enable_skin_alternate' => "Checking this enables an alternate weapon for skinning.",
			'enable_skin_offensive' => "Checking this enables skinning in offensive for a slight success increase (not proven).",
			'enable_skin_kneel' => "Checking this enables skinning while kneeling for a slight success increase.",
			'enable_skin_safe_mode' => "Checking this enables safe mode and will only stance/kneel if there are no alive critters present.",
			'enable_skin_604' => "Checking this enables the use of 604 (Skinning) if you meet the requirements.\nRequires: level 6 Ranger with 606 learned",
			'enable_skin_sigil' => "Checking this enables the use of Sigil of Resolve if you meet the requirements.\nRequires: GoS member with Sigil of Resolve learned",
			'enable_skin_stats' => "Checking this enables skinning statistics. You can view them by using ;sloot stats.",
			'enable_skin_stance_first' => "Checking this enables stancing to previous stance before standing. This is disabled by default to prevent incuring additional roundtime from standing in defensive.",
			'skin_stand_verb' => "Enter the stand verb if you don't want to use the default STAND verb.\ne.g., \"rgambit tumble left\"",
			'enable_sell_chronomage' => "Checking this enables giving gold rings to the Chronomage during the sell process for credit towards a Chronomage ride.",
			'enable_sell_share_silvers' => "Checking this enables sharing all silvers with the group before depositing and gives them a few seconds to deposit their coins.",
			'sell_withdraw' => "Enter an amount to withdraw after the sell process completes. This is useful for towns with gate fees such as Icemule Trace.",
			'enable_sell_locksmith' => "Checking this enables the use the NPC locksmith to open your boxes.",
			'enable_sell_wait_line' => "Checking this enables waiting at the locksmith if another person is present.",
			'enable_sell_stockpile' => "Checking this enables stockpiling of gems so that they can be turned in later for bounties. This requires you to have empty jars from the alchemist available in your locker.",
			'enable_sell_force_bounty_gems' => "Checking this enables selling of gems for bounties even if you normally have gem selling disabled.",
		}
		
		gtk_globals['ammosack'] = Gtk::Entry.new.set_text(UserVars.ammosack)
		gtk_globals['boxsack'] = Gtk::Entry.new.set_text(UserVars.boxsack)
		gtk_globals['foragesack'] = Gtk::Entry.new.set_text(UserVars.foragesack)
		gtk_globals['gemsack'] = Gtk::Entry.new.set_text(UserVars.gemsack)
		gtk_globals['herbsack'] = Gtk::Entry.new.set_text(UserVars.herbsack)
		gtk_globals['jewelrysack'] = Gtk::Entry.new.set_text(UserVars.jewelrysack)
		gtk_globals['lockpicksack'] = Gtk::Entry.new.set_text(UserVars.lockpicksack)
		gtk_globals['magicsack'] = Gtk::Entry.new.set_text(UserVars.magicsack)
		gtk_globals['reagentsack'] = Gtk::Entry.new.set_text(UserVars.reagentsack)
		gtk_globals['scrollsack'] = Gtk::Entry.new.set_text(UserVars.scrollsack)
		gtk_globals['skinsack'] = Gtk::Entry.new.set_text(UserVars.skinsack)
		gtk_globals['uncommonsack'] = Gtk::Entry.new.set_text(UserVars.uncommonsack)
		gtk_globals['wandsack'] = Gtk::Entry.new.set_text(UserVars.wandsack)
		gtk_globals['stowsack'] = Gtk::Entry.new.set_text(UserVars.stowsack)
		gtk_globals['skinweapon'] = Gtk::Entry.new.set_text(UserVars.skinweapon)
		gtk_globals['skinweaponsack'] = Gtk::Entry.new.set_text(UserVars.skinweaponsack)
		
		gtk_locals['enable_close_sacks'] = Gtk::CheckButton.new('(?) Keep sacks shut').set_active(settings['enable_close_sacks'])
		gtk_locals['overflowsack'] = Gtk::Entry.new.set_text(settings['overflowsack'])
		gtk_locals['enable_search_all'] = Gtk::CheckButton.new('(?) Search all dead').set_active(settings['enable_search_all'])
		gtk_locals['enable_loot_box'] = Gtk::CheckButton.new('Boxes').set_active(settings['enable_loot_box'])
		gtk_locals['enable_loot_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_loot_gem'])
		gtk_locals['enable_loot_herb'] = Gtk::CheckButton.new('Herbs').set_active(settings['enable_loot_herb'])
		gtk_locals['enable_loot_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_loot_jewelry'])
		gtk_locals['enable_loot_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_loot_lockpick'])
		gtk_locals['enable_loot_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_loot_magic'])
		gtk_locals['enable_loot_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_loot_reagent'])
		gtk_locals['enable_loot_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_loot_scroll'])
		gtk_locals['enable_loot_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_loot_skin'])
		gtk_locals['enable_loot_uncommon'] = Gtk::CheckButton.new('Uncommon').set_active(settings['enable_loot_uncommon'])
		gtk_locals['enable_loot_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_loot_wand'])
		gtk_locals['enable_disking'] = Gtk::CheckButton.new('(?) Disking').set_active(settings['enable_disking'])
		gtk_locals['enable_phasing'] = Gtk::CheckButton.new('(?) Phasing').set_active(settings['enable_phasing'])
		gtk_locals['enable_gather'] = Gtk::CheckButton.new('(?) Gather ammo').set_active(settings['enable_gather'])
		gtk_locals['ammo_name'] = Gtk::Entry.new.set_text(settings['ammo_name'])
		gtk_locals['enable_safe_hiding'] = Gtk::CheckButton.new('(?) Safe hiding').set_active(settings['enable_safe_hiding'])
		gtk_locals['safe_ignore'] = Gtk::Entry.new.set_text(settings['safe_ignore'])
		gtk_locals['enable_stow_left'] = Gtk::CheckButton.new('(?) Stow left hand').set_active(settings['enable_stow_left'])
		gtk_locals['enable_self_drops'] = Gtk::CheckButton.new('(?) Self loot only').set_active(settings['enable_self_drops'])
		gtk_locals['enable_skinning'] = Gtk::CheckButton.new('(?) Enable skinning').set_active(settings['enable_skinning'])
		gtk_locals['enable_skin_alternate'] = Gtk::CheckButton.new('(?) Enable alternate').set_active(settings['enable_skin_alternate'])
		gtk_locals['enable_skin_offensive'] = Gtk::CheckButton.new('(?) Skin in offensive').set_active(settings['enable_skin_offensive'])
		gtk_locals['enable_skin_kneel'] = Gtk::CheckButton.new('(?) Kneel to skin').set_active(settings['enable_skin_kneel'])
		gtk_locals['enable_skin_safe_mode'] = Gtk::CheckButton.new('(?) Safe mode').set_active(settings['enable_skin_safe_mode'])
		gtk_locals['enable_skin_stance_first'] = Gtk::CheckButton.new('(?) Stance first').set_active(settings['enable_skin_stance_first'])
		gtk_locals['enable_skin_604'] = Gtk::CheckButton.new('(?) Use 604').set_active(settings['enable_skin_604'])
		gtk_locals['enable_skin_sigil'] = Gtk::CheckButton.new('(?) Use Sigil of Resolve').set_active(settings['enable_skin_sigil'])
		gtk_locals['enable_skin_stats'] = Gtk::CheckButton.new('(?) Track statistics').set_active(settings['enable_skin_stats']).set_sensitive(false)
		gtk_locals['skin_stand_verb'] = Gtk::Entry.new.set_text(settings['skin_stand_verb'])
		gtk_locals['enable_sell_type_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_sell_type_gem'])
		gtk_locals['enable_sell_type_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_sell_type_jewelry'])
		gtk_locals['enable_sell_type_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_sell_type_lockpick'])
		gtk_locals['enable_sell_type_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_sell_type_magic'])
		gtk_locals['enable_sell_type_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_sell_type_reagent'])
		gtk_locals['enable_sell_type_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_sell_type_scroll'])
		gtk_locals['enable_sell_type_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_sell_type_skin'])
		gtk_locals['enable_sell_type_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_sell_type_wand'])
		gtk_locals['enable_sell_chronomage'] = Gtk::CheckButton.new('(?) Rings -> Chrono').set_active(settings['enable_sell_chronomage'])
		gtk_locals['enable_sell_share_silvers'] = Gtk::CheckButton.new('(?) Share silvers').set_active(settings['enable_sell_share_silvers'])
		gtk_locals['sell_withdraw'] = Gtk::Entry.new.set_text(settings['sell_withdraw'])
		gtk_locals['enable_sell_locksmith'] = Gtk::CheckButton.new('(?) Enable locksmith').set_active(settings['enable_sell_locksmith'])
		gtk_locals['enable_sell_wait_line'] = Gtk::CheckButton.new('(?) Wait in line').set_active(settings['enable_sell_wait_line']).set_sensitive(false)
		gtk_locals['enable_sell_stockpile'] = Gtk::CheckButton.new('(?) Stockpile gems').set_active(settings['enable_sell_stockpile']).set_sensitive(false)
		gtk_locals['enable_sell_force_bounty_gems'] = Gtk::CheckButton.new('(?) Force sell gems').set_active(settings['enable_sell_force_bounty_gems']).set_sensitive(false)
		
		# Signals		
		gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active?
		gtk_locals['enable_gather'].signal_connect('toggled') { gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active? }
		
		gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active?
		gtk_locals['enable_safe_hiding'].signal_connect('toggled') { gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active? }
		
		# Add tooltips
		ttips_text.each_pair { |widget,tip|
			if widget = gtk_globals[widget] || gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}
		
		# Primary Window
		window = Gtk::Window.new
		window.title = "SLoot v#{@@version} configuration for #{Char.name}"
		window.border_width = 3
		window.resizable = false
		window.resize(450, 300)
				
		# Notebooks for tabs at the top
		nb = Gtk::Notebook.new.set_show_border(true).set_tab_border(3)
		
		#
		# Notebook Page 1 - Sacks
		#
		vb_pg1 = Gtk::VBox.new(false,1).set_border_width(3)
		
		#
		# Page 1, Frame 1 - Sacks
		#
		vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Sacks</b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		vb_pg1.pack_start(fr_pg1_1,false)

		lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
			"a sack for each type of loot. Use the fields below to set the sack(s) for " +
			"each loot type.")
		lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		vb_pg1_1.pack_start(lbl,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammunition:')).set_width_request(100))
		hb.pack_start(gtk_globals['ammosack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Boxes:')).set_width_request(100))
		hb.pack_start(gtk_globals['boxsack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Gems:')).set_width_request(100))
		hb.pack_start(gtk_globals['gemsack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Herbs:')).set_width_request(100))
		hb.pack_start(gtk_globals['herbsack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Jewelry:')).set_width_request(100))
		hb.pack_start(gtk_globals['jewelrysack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Lockpicks:')).set_width_request(100))
		hb.pack_start(gtk_globals['lockpicksack'],false)
		vb_pg1_1.pack_start(hb,false)

		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Magical:')).set_width_request(100))
		hb.pack_start(gtk_globals['magicsack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Reagents:')).set_width_request(100))
		hb.pack_start(gtk_globals['reagentsack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Scrolls:')).set_width_request(100))
		hb.pack_start(gtk_globals['scrollsack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Skins:')).set_width_request(100))
		hb.pack_start(gtk_globals['skinsack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Uncommon:')).set_width_request(100))
		hb.pack_start(gtk_globals['uncommonsack'],false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wands:')).set_width_request(100))
		hb.pack_start(gtk_globals['wandsack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Stow:')).set_width_request(100),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['stowsack']))
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Overflow:')).set_width_request(100),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['overflowsack'].set_width_request(419)))
		vb_pg1_1.pack_start(hb,false)
		
		#
		# Page 1, Frame 2 - Advanced Options
		#
		vb_pg1_2 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
		fr_pg1_2.add(vb_pg1_2)
		vb_pg1.pack_start(fr_pg1_2,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_close_sacks'].set_width_request(129)),false)
		vb_pg1_2.pack_start(hb,false)
		
		lbl = Gtk::Label.new.set_markup("<span color=\"blue\" weight=\"bold\">Tip: (?) " +
			"in front of any option means you can hover over it for additional information.</span>")
		lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		vb_pg1_1.pack_start(lbl,false)

		nb.append_page(vb_pg1,Gtk::Label.new('Sacks'))
		
		#
		# Notebook Page 2 - Looting
		#
		vb_pg2 = Gtk::VBox.new(false,1).set_border_width(3)
		
		#
		# Page 2, Frame 1 - Looting
		#
		vb_pg2_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Looting</b></big>'))
		fr_pg2_1.add(vb_pg2_1)
		vb_pg2.pack_start(fr_pg2_1,false)
		
		lbl = Gtk::Label.new.set_markup("Use the options below to specify how " +
		"SLoot behaves when looting. Each checkbox represents a loot category which SLoot will only " + 
		"pickup if checked. You can also enabled advanced features such as autolooting, disking/phasing " +
		"of boxes, and looting drops from critters you search.")
		lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		vb_pg2_1.pack_start(lbl,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_search_all'].set_width_request(129)),false)
		vb_pg2_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_box'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_gem'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_herb'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_jewelry'].set_width_request(129)),false)
		vb_pg2_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_lockpick'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_magic'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_reagent'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_scroll'].set_width_request(129)),false)
		vb_pg2_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_skin'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_wand'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_uncommon'].set_width_request(129)),false)
		vb_pg2_1.pack_start(hb,false)
		
		#
		# Page 2, Frame 1 - Looting
		#
		vb_pg2_2 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
		fr_pg2_1.add(vb_pg2_2)
		vb_pg2.pack_start(fr_pg2_1,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_disking'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stow_left'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_self_drops'].set_width_request(129)),false)
		
		if Char.prof == 'Sorcerer' && Char.level > 3 && Spell[704].known?
			hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_phasing'].set_width_request(129)),false)
		end
		
		vb_pg2_2.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_safe_hiding'].set_width_request(129)),false)
		hb.pack_start(gtk_locals['safe_ignore'],false)
		vb_pg2_2.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_gather'].set_width_request(129)),false)
		hb.pack_start(gtk_locals['ammo_name'],false)
		vb_pg2_2.pack_start(hb,false)
		
		nb.append_page(vb_pg2, Gtk::Label.new('Looting'))
		
		#
		# Notebook Page 3 - Skinning
		#
		vb_pg3 = Gtk::VBox.new(false,1).set_border_width(3)
		
		#
		# Page 3, Frame 1 - Skinning
		#
		vb_pg3_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg3_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Skinning</b></big>'))
		fr_pg3_1.add(vb_pg3_1)
		vb_pg3.pack_start(fr_pg3_1,false)
		
		lbl = Gtk::Label.new.set_markup("The options below give you absolute control over skinning critters. " +
			"You can use your current weapon, an alternate weapon, left or right hand, and advanced enhancements " +
			"such as kneeling, stancing to offensive, Skinning (604) and Sigil of Resolve.")
		lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		vb_pg3_1.pack_start(lbl,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skinning'].set_width_request(129)),false)
		vb_pg3_1.pack_start(hb,false)
		
		#
		# Page 3, Frame 2 - Alternate Weapon
		#
		vb_pg3_2 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg3_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Alternate Skinning Weapon</b></big>'))
		fr_pg3_2.add(vb_pg3_2)
		vb_pg3.pack_start(fr_pg3_2,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_alternate'].set_width_request(129)),false)
		vb_pg3_2.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Weapon:')),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['skinweapon']),false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Sack:')),false)
		hb.pack_start(gtk_globals['skinweaponsack'],false)
		vb_pg3_2.pack_start(hb,false)
		
		#
		# Page 3, Frame 3 - Enhancements
		#
		vb_pg3_3 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg3_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Enhancements</b></big>'))
		fr_pg3_3.add(vb_pg3_3)
		vb_pg3.pack_start(fr_pg3_3,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_offensive'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_kneel'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_safe_mode'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stance_first'].set_width_request(129)),false)
		vb_pg3_3.pack_start(hb,false)
		
		if (Char.prof == 'Ranger' && Char.level > 3 && Spell[604].known?) || (Spell[9704].known?)
			hb = Gtk::HBox.new(false,1)
			
			if Char.prof == 'Ranger' && Char.level > 3 && Spell[604].known?
				hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_604'].set_width_request(129)),false)
			end
			
			if Spell[9704].known?
				hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_sigil'].set_width_request(129)),false)
			end
			
			vb_pg3_3.pack_start(hb,false)
		end
		
		#
		# Page 3, Frame 4 - Advanced Options
		#
		vb_pg3_4 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg3_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
		fr_pg3_4.add(vb_pg3_4)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stats'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Stand verb:')).set_width_request(100),false)
		hb.pack_start(gtk_locals['skin_stand_verb'],false)
		vb_pg3_4.pack_start(hb,false)
		
		vb_pg3.pack_start(fr_pg3_4,false)
		
		nb.append_page(vb_pg3, Gtk::Label.new('Skinning'))
		
		#
		# Notebook Page 4 - Skinning
		#
		vb_pg4 = Gtk::VBox.new(false,1).set_border_width(3)
		
		#
		# Page 4, Frame 1 - Selling
		#
		vb_pg4_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg4_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Selling</b></big>'))
		fr_pg4_1.add(vb_pg4_1)
		vb_pg4.pack_start(fr_pg4_1,false)
		
		lbl = Gtk::Label.new.set_markup("SLoot comes with a built in sell option that will sell all " +
		"loot and even open boxes at the town locksmith. Use the checkboxes to set what type of loot " +
		"you want to sell and the advanced options to customize exactly how selling operates.")
		lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
		vb_pg4_1.pack_start(lbl,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_gem'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_jewelry'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_lockpick'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_magic'].set_width_request(129)),false)
		vb_pg4_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_reagent'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_scroll'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_skin'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_wand'].set_width_request(129)),false)
		vb_pg4_1.pack_start(hb,false)
		
		#
		# Page 4, Frame 2 - Cleanup
		#
		vb_pg4_2 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg4_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Cleanup</b></big>'))
		fr_pg4_2.add(vb_pg4_2)
		vb_pg4.pack_start(fr_pg4_2,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_chronomage'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_share_silvers'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Withdraw:')).set_width_request(100),false)
		hb.pack_start(gtk_locals['sell_withdraw'],false)
		vb_pg4_2.pack_start(hb,false)
		
		#
		# Page 4, Frame 3 - Locksmith
		#
		vb_pg4_3 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg4_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Locksmith</b></big>'))
		fr_pg4_3.add(vb_pg4_3)
		vb_pg4.pack_start(fr_pg4_3,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_locksmith'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_wait_line'].set_width_request(129)),false)
		vb_pg4_3.pack_start(hb,false)
		
		#
		# Page 4, Frame 4 - Bounties
		#
		vb_pg4_4 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg4_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Bounties</b></big>'))
		fr_pg4_4.add(vb_pg4_4)
		vb_pg4.pack_start(fr_pg4_4,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_stockpile'].set_width_request(129)),false)
		hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_force_bounty_gems'].set_width_request(129)),false)
		vb_pg4_4.pack_start(hb,false)
		
		nb.append_page(vb_pg4, Gtk::Label.new('Selling'))
		
		# Save/Close buttons
		hb_saveclose = Gtk::HBox.new
		save = Gtk::Button.new('_Save & Close')
		close = Gtk::Button.new('E_xit')
		
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		
		# Primary VerticalBox to split up Notebook and Save/Close buttons
		vb_main = Gtk::VBox.new(false,5)
		vb_main.border_width = 3
		
		vb_main.pack_start(nb,false)
		vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose),false)
		
		window.signal_connect('delete_event') { respond window.allocation.width; window_action = :exit }
		
		window.add(vb_main)	
		window.show_all
		window.keep_above = true # On windows keep_above is required AFTER show_all
	}
	
	before_dying { Gtk.queue { window.destroy } }
	wait_while { window_action.nil? }
	undo_before_dying # Don't ask me what this does - I stripped it from Tillmen's code
	Gtk.queue { window.destroy }
	
	clean_entry = proc { |entry|
		entry.text = entry.text.strip
		if entry.text.empty?
			entry.text = nil
		end
		
		entry.text
	}
		
	if window_action == :save		
		gtk_globals.each_pair { |option,widget|
			if widget.class == Gtk::CheckButton
				UserVars.change(option,widget.active?,:char)
			elsif widget.class == Gtk::Entry
				UserVars.change(option,clean_entry.call(widget),:char)
			else
				echo "error: unknown global widget #{option} [#{widget.class}]"
			end
		}
		
		gtk_locals.each_pair { |option,widget|
			if widget.class == Gtk::CheckButton
				settings[option] = widget.active?
			elsif widget.class == Gtk::Entry
				settings[option] = clean_entry.call(widget)
			else
				echo "error: unknown local widget #{option} [#{widget.class}]"
			end
		}
		
		echo 'settings saved'
	else
		echo 'closed without saving'
	end
}

# Installs hooks that sloot uses to function. Will only install a hook 
# once in order to increase performance.
install_hooks = proc { |type|
	if settings['enable_disking']
		next if $sloot_hooks.include?(:disk)
		$sloot_hooks.push(:disk)
		
		hook = proc { |server_string|
			if server_string =~ /from in the <a exist="(?:\d+)" noun="disk">.*#{Char.name} disk<\/a>|You give your disk a flip/
				$sloot_has_disk = true
				$sloot_disk_full = false
			elsif server_string =~ /#{Char.name} disk in a dismissing gesture./
				$sloot_has_disk = false
				$sloot_disk_full = false
			elsif server_string =~ /^Your <a exist=".*" noun="disk">disk<\/a> arrives|^A small circular container suddenly appears/
				$sloot_has_disk = true
				$sloot_disk_full = false
			elsif server_string =~ /^Your .* won't fit in the .*disk.*$/
				$sloot_has_disk = true
				$sloot_disk_full = true
			end
			
			server_string
		}
		
		DownstreamHook.add('SLootDisk', hook)
	elsif $sloot_hooks.include?(:disk)
		DownstreamHook.remove('SLootDisk')
	end
}

# Gets a sack based on type
get_sack_from_type = proc { |type|
	if found_sacks.keys.include?(type)
		sack = found_sacks[type]
	else
		sack = GameObj[UserVars.send(UNTRUSTED_UNTAINT.call("#{type}sack"))]
	end
	
	unless sack
		echo "could not locate your #{type}sack: got #{sack.inspect}"
		sack = nil
	else
		found_sacks[type] = sack
	end
	
	sack
}

# Get dem silvers
checksilvers = proc {
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("slib_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("slib_check_silvers", action)
	$_SERVER_.puts "#{$cmd_prefix}info\n"
	wait_until { silvers }
	silvers
}

# Deposits coins in the bank
deposit_coins = proc {
	silvers = checksilvers.call.to_i
	withdraw = settings['sell_withdraw'].to_i
	
	if (silvers == 0 && withdraw == 0) || silvers == withdraw
		next
	end
	
	go2.call('bank')
	
	if settings['enable_sell_share_silvers'] and silvers > 1
		dothistimeout "share all", 5, /In order to share|share/
	end
	res = dothistimeout "deposit all", 5, /The teller carefully records the transaction|^You have no coins to deposit\.$/
		
	if (withdraw > 0)
		dothistimeout "withdraw #{withdraw} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers\.$/
	end
}

# Puts an item somewhere
put_item = proc { |item,sack|
	left_hand = GameObj.left_hand
	right_hand = GameObj.right_hand
	
	next nil unless right_hand.id == item || left_hand.id == item || checkleft =~ /#{item}/ || checkright =~ /#{item}/
	
	if item.class != GameObj && item.strip =~ /^\-?\d+$/
		item = "##{item}"
	end
	
	if sack.class == GameObj || sack = GameObj[sack]
		line = "put #{item} in ##{sack.id}"
	else
		line = "put #{item} in #{sack}"
	end
	
	res = dothistimeout line, 5, /^You put .* in .*\.$|^You can't put .* in .*\.  It's closed\!$|^Your? .* won't fit in .*\.$|^I could not find what you were referring to\.$|^As you place an/i
	case res
		when /^You put .* in .*\.$|^As you place an/
		when /not set|could not|^Your? .* won't fit in .*\.$|^I could not find what you were referring to\.$/,false,nil
			res = nil
		when /^You can't put .* in .*\.  It's closed\!$/
			open_sack.call(sack)
			next putitem(item,sack)
		else
			echo "fixme: unknown put_item result: #{res.inspect}"
			res = nil
	end
	
	res
}

# Gets an item
get_item = proc { |item,sack|
	left_hand = GameObj.left_hand
	right_hand = GameObj.right_hand
	
	next nil if right_hand.id == item || left_hand.id == item || checkleft =~ /#{item}/ || checkright =~ /#{item}/
	
	if item.class != GameObj && item.strip =~ /^\-?\d+$/
		item = "##{item}"
	end
	
	if sack.class == GameObj || inv_sack = GameObj[sack]
		sack = inv_sack unless sack.class == GameObj
		line = "get #{item} from ##{sack.id}"
	elsif sack.nil?
		line = "get #{item}"
	else
		line = "get #{item} from #{sack}"
	end
	res = dothistimeout line, 5, /^Get what\?$|^You pick up .*\.$|^You remove .* from (?:in|on) .*\.$|You gather the remaining/i
	case res
		when /^You pick up .*\.$|^You remove .* from (?:in|on) .*\.$/
		when /^Get what\?$/
			res = nil
		else
			echo "fixme: unknown get_item result: #{res.inspect}"
			res = nil
	end
	
	res	
}

# Waits until your disk is present or a timeout occurs
check_for_disk = proc {
	disk = nil
	notified = false
	25.times { 
		break if disk = GameObj[/^.*#{Char.name} disk$/]
		sleep 0.2
		unless notified
			msg.call("SLoot: waiting on your disk to arrive",:all)
			notified = true
		end
	}
	
	unless disk
		$sloot_has_disk = false
	end
	
	disk
}

# Withdraws coins from the bank, hooray!
withdraw_coins = proc { |amount|
	success = true
	room = Room.current.id
	
	coins = checksilvers.call
	if coins < amount
		go2.call('bank')
		
		dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
		res = dothistimeout "withdraw #{amount-coins} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers?\.$|I'm sorry, .*, you don't seem to have that much in the account\./
		case res
			when /I'm sorry/
				success = false
			when /^The teller carefully/
			else
				echo "unknown response for withdraw_coins: #{res}"
		end
	end
	
	go2.call(room)
	
	success
}

# Grabs loot!
grab_loot = proc { |loot,from|
	type = loot.type.split(',').first
	
	if type == 'box'
		disk = nil
		
		# Disk boxes if we can
		if settings['enable_disking'] && $sloot_has_disk && !$sloot_disk_full
			unless disk = check_for_disk.call
				msg.call("I can't seem to find your disk",:all)
				$sloot_has_disk = false
				
				if Char.prof == 'Wizard' && Spell[511].known? && Char.level > 10
					msg.call("Hooray! You're a Weezard!",:all)
					
					if Spell[511]
						Spell[511].cast
						disk = check_for_disk.call
					else
						msg.call("No mana, aborting.",:all)
					end
				end
			end
		end
		
		# Phasing for those Demon lovers
		if !disk && settings['enable_phasing'] && Spell[704].known? && Spell[704].affordable? && Char.level > 3 && loot.name !~ /mithril|enruned/
			right_hand = true
			right_hand = false if GameObj.left_hand.id == loot.id

			dothistimeout "prep 704", 5, /Phase/
			res = dothistimeout "cast ##{loot.id}", 5, /somewhat insubstantial|flickers in and out|becomes momentarily|resists the effects/
			
			# Phased items get a different id so refresh the loot GameObj
			if line =~ /becomes momentarily/
				if right_hand
					wait_while { GameObj.right_hand.noun.nil? }
					loot = GameObj.right_hand
				else
					wait_while { GameObj.left_hand.noun.nil? }
					loot = GameObj.left_hand
				end
			end
		end
	end
		
	unless sack = get_sack_from_type.call(type)
		msg.call("unable to find sack for \"#{loot.name}\" with type \"#{loot.type}\"",:all)
		next
	end
	
	unless get_item.call(loot,from)
		msg.call("failed to get item \"#{loot.name}\" from \"#{sack.name}\"",:all)
	else
		if disk and put_item.call(loot,disk)
			next
		end
		
		unless put_item.call(loot,sack)
			msg.call("failed to put item \"#{loot.name}\" in sack \"#{sack.name}\"",:all)
			fput "drop ##{loot.id}"
		end
	end
}

# Frees up the loot hand
free_hand = proc {
	next if !checkright || !checkleft
	next if !checkright && !settings['enable_stow_left']
	next if !checkleft && settings['enable_stow_left']
		
	stored_hand = nil
	if checkright && !settings['enable_stow_left']
		stored_item = GameObj.right_hand
		stored_hand = 'right'
	elsif checkleft && settings['enable_stow_left']
		stored_item = GameObj.left_hand
		stored_hand = 'left'
	else
		echo 'fixme: invalid condition for free_hand'
		exit
	end

	res = dothistimeout "store #{stored_hand}", 5, /^You can't put your .* in the .*\.  It's closed\!$|^You aren't holding any bundles of ammo in your hands\.$|^You put .* in your .*\.$|^You sling .* over your shoulder\.$|^You shift the focus of your voice and your .* moves from your .* hand to your shoulder\.$/
	case res
		when nil, /^You aren't holding any bundles of ammo in your hands\.$/
			res = dothistimeout "stow ##{stored_item.id}", 5, /^You put .*\.$|^You can't put your .* in the .*\.  It's closed\!$/
			
			if res =~ /^You can't put your .* in the (.*)\.  It's closed\!$/
				open_sack.call($1.strip)
				next free_hand.call
			end
		when /It's closed\!$/
			if res =~ /^You can't put your .* in the (.*)\.  It's closed\!$/
				open_sack.call($1.strip)
				next free_hand.call
			end
		when /^You put .* in your .*\.$|^You sling .* over your shoulder\.$|^You shift the focus of your voice and your .* moves from your .* hand to your shoulder\.$/
		else
			echo "fixme: unknown result for free_hand: #{res}"
			exit
	end
	
	stored_result = res
}

# Loots a single GameObj or an array of GameObjs
loot_it = proc { |array,exclude|
	next if array.nil?
	unless array.class == Array
		array = [ array ]
	end
	
	array.each { |loot|
		# Skip over any loot that is in the exclude array
		if exclude.include?(loot.id)
			exclude.delete(loot.id)
			next
		end
						
		# Make sure that the loot type is something we want to pickup
		if loot.type.split(',').any? { |type| settings["enable_loot_#{type}"] }
			free_hand.call
			grab_loot.call(loot,nil)
		elsif loot.name == 'some silver coins'
			dothistimeout "get ##{loot.id}", 5, /^You gather the remaining \d+ coins from inside your .*\.$|^You gather the remaining/
		else			
			# Log all missed loot to addd to gameobj-data.xml
			write_log.call("skipped #{loot.name}") if loot.type.nil?
		end
	}
}

# Checks a bundle for ammo type
check_bundle = proc { |id|
	ammo_name = settings['ammo_name'].strip
	result = nil
	
	action = proc { |server_string|
		line = server_string
		if server_string =~ /Individual projectiles from this bundle will have a (?:show|long) of "(.*)"|Each individual projectile will be "(.*)"/
			name_long = $1
			name_short = $2
			
			if name_long =~ /.*#{ammo_name}/ || name_short =~ /.*#{ammo_name}/
				result = server_string
			end
			nil
		elsif server_string =~ /^You carefully count|Individual/
			nil
		elsif server_string.strip.empty?
			nil
		elsif server_string =~ /<prompt time=/
			result = false if result.nil?
			DownstreamHook.remove("sloot_check_bundle")
			nil
		else
			server_string
		end
	}
	
	DownstreamHook.add("sloot_check_bundle", action)
	$_SERVER_.puts "#{$cmd_prefix}look at ##{id}\n"
	wait_while { result.nil? }
	
	result
}

# Get ammo from room description
get_ammo = proc {
	ammo_name = settings['ammo_name'].strip
	ammo_ids = [ ]
	
	items = $_SERVERBUFFER_.reverse.find { |line| line =~ /<(?:compDef|component) id='room objs'/ }.gsub(/<pushBold\/>|<popBold\/>|<b>|<\/b>/,'').scan(/(?:a |an |some |the ).*?<\/a>.*?(?=, | and |\.)/)
	items.each { |i|
		if i =~ /<a exist="(\d+)" noun="(arrow|bolt|dart)">(?:arrow|bolt|dart)<\/a>/
			id = $1
			
			if i.gsub(/(?:\b(?:a|an)\b\s|<a.*">|<\/a>)/,'') =~/#{ammo_name}/
				ammo_ids.push(id)
			end
		elsif i =~ /<a exist="(\d+)" noun="(arrow|bolt|dart)s">bundle of.*(?:arrow|bolt|dart)s<\/a>/
			id = $1

			unless invalid_ammo.include?(id)
				if check_bundle.call(id) =~ /#{ammo_name}/
					ammo_ids.push(id)
				else
					invalid_ammo.push(id)
				end
			end
		end
	}

	ammo_ids
}

# Gathers ammunition
gather_ammo = proc {
	next unless settings['enable_gather']
	ammo_name = settings['ammo_name'].strip
	sack = UserVars.ammosack
	
	if ammo_name.nil? or ammo_name.empty?
		echo "failed to gather: you must specify the ammo name to use this feature"
		next
	end
	
	if ammo_name =~ /\b(arrow|bolt|dart)\b/
		ammo_noun = $1
	else
		echo "failed to gather: invalid ammo type specified (use the full name)"
	end
	
	if sack.nil? or sack.empty?
		echo "failed to gather: you must specify an ammo container to use this feature"
		next
	end
	
	# Attempt to gather arrows first
	ammo_ids = get_ammo.call
	unless ammo_ids.empty? || !GameObj.loot.find { |l| l.name =~ /#{ammo_noun}s/ }
		empty_hand

		result = dothistimeout "gather #{ammo_noun}s", 5, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach/
		if result =~ /^You gather .* into a bundle on the ground\.$/
			get_item.call(GameObj.loot.find { |l| l.noun =~ /(?:arrow|bolt|dart)s?/ }.id,nil)
		end
			
		if result =~ /^You gather|^You pick up/ && hand = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.noun =~ /(?:arrow|bolt|dart)/ }
			fput "look at ##{hand.id}" if hand.noun =~ /(?:arrows|bolts|darts)s/
			if result =~ /#{ammo_name}/ || $_SERVERBUFFER_.reverse.find { |line| line =~ /Individual projectiles from this bundle will have a (?:long|show) of "(?:a|an) #{ammo_name}"/ }
				dothistimeout "put my #{hand.noun} in my #{hand.noun} in my #{sack}", 5, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/
				put_item.call(hand.id,sack) if [checkleft,checkright].include?(hand.noun)
			else
				fput "drop ##{hand.id}"
			end
		end
	end
	
	# Loop through remaining arrow ids and store manually
	ammo_ids = get_ammo.call
	unless ammo_ids.empty?
		empty_hand
	
		ammo_ids.each { |i|
			get_item.call(i,nil)
			
			if hand = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.noun =~ /(?:arrow|bolt|dart)/ }
				dothistimeout "put my #{hand.noun} in my #{hand.noun} in my #{sack}", 5, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/
				put_item.call(hand.id,sack) if [checkleft,checkright].include?(hand.noun)
			end
		}
	end
	
	fill_hand
}

# Locksmithing routine
locksmith = proc {
	unless boxsack = GameObj[UserVars.boxsack]
		msg.call('SLoot: failed to find boxsack', :all)
		next
	end
	
	unless boxsack.contents
		dothistimeout "look in ##{boxsack.id}", 5, /In the .*?/
		unless boxsack.contents
			msg.call("could not read contents of #{boxsack.name}",:all)
		end
	end
	
	boxes = boxsack.contents.find_all { |o| o.type.include?('box') }
	
	if settings['enable_disking'] && $sloot_has_disk
		unless disk = GameObj[/^.*#{Char.name} disk$/]
			unless disk = check_for_disk.call
				msg.call("failed to find a disk",:all)
			end
		end
		
		if disk
			unless disk.contents
				dothistimeout "look in ##{disk.id}", 5, /In the .*?/
				unless disk.contents
					msg.call("failed to find contents of your disk",:all)
				end
			end
			
			boxes += disk.contents.find_all { |o| o.type.include?('box') }.to_a if disk.contents
		end
	end
	
	if boxes.size == 0
		msg.call("SLoot: nothing for the locksmith",:all)
	else
		empty_hands
		withdraw_coins.call(10000)
		go2.call('locksmith')
				
		unless trash = GameObj[/crate|barrel|wastebarrel|casket/]
			msg.call('unable to locate trash',:all)
		end
		
		unless table = GameObj[/table|counter/]
			msg.call('unable to find table',:all)
			next
		end
		
		unless table.contents
			dothistimeout "look on ##{table.id}", 5, /On the .*? you see/
			
			unless table.contents
				msg.call("failed to find contents of #{table.name}",:all)
				next
			end
		end
		
		unless activator = table.contents.find { |o| o.noun =~ /bell|keys|chime/ }
			msg.call('unable to find activator',:all)
		end
		
		case activator.noun
			when /bell|chime/
				activator = "ring #{activator.noun}"
			when /keys/
				activator = 'pull keys'
		end
		
		open_box = proc { |box|	
			if disk && !GameObj[disk.name]
				msg.call("waiting on your disk to arrive",:all)
			end
			wait_until { GameObj[disk.name] } if disk
		
			get_item.call(box.id,nil)
			res = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^You should really/
			
			# Phasing for those Sorcerer types (evil bastards!)
			if res =~ /^You should really/
				dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/
				put_item.call(box.id,table.id)
			end
			
			dothistimeout activator, 5, /but it'll cost|so he can look at it/
			# fixme: check result
			res = dothistimeout "pay", 5, /accepts|have enough/
			if res =~ /have enough/
				loot_it.call(box,nil)
				withdraw_coins.call(10000)
				next open_box.call(box)
			end
			
			get_item.call(box.id,nil)
			
			dothistimeout "open ##{box.id}", 5, /open/				
			unless box.contents
				dothistimeout "look in ##{box.id}", 5, /^In the/
				
				unless box.contents 
					msg.call("failed to see contents of #{box.name}",:all)
					loot_it.call(box,nil)
					next
				end
			end
			
			loot_it.call(box.contents,nil)
			unless trash.nil?
				unless put_item.call(box.id,trash.id)
					dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
				end
			end
			
			dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
		}
		
		dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
		boxes.each { |b| open_box.call(b) }
	end
}

# Sell routine
sell = proc {
	cur_room = Room.current.id
	sacks = Array.new
	selling = Hash.new
	silver_breakdown = Hash.new
	start_silvers = checksilvers.call
	types = Array.new
		
	# Locksmith boxes first
	if settings['enable_sell_locksmith']
		locksmith.call
	end
	
	settings.keys.each { |key| 
		if key =~ /^enable_sell_type_(.*)$/
			type = $1
			types.push(type) if settings[key]
			
			if found_sack = GameObj[UserVars.send("#{type}sack")]
				sacks.push(found_sack) unless sacks.include?(found_sack)
			end
		end 
	}
	
	settings['overflowsack'].split(',').each { |sack|
		if found_sack = GameObj[sack]
			sacks.push(found_sack) unless sacks.include?(found_sack)
		end
	}
	
	sacks.each { |sack|
		unless sack.contents
			dothistimeout "look in ##{sack.id}", 5, /In the .*?/
			unless sack.contents
				echo "failed to find contents of sack: #{sack.name}"
				next
			end
		end
		
		sack.contents.each { |item|
			unless item.sellable.nil?
				if item.type.split(',').any? { |type| type =~ /^#{types.join('|')}$/ }
					selling[item.sellable] ||= Array.new
					selling[item.sellable].push(item)
				end
			end
		}
	}
	
	sell_item = proc { |item|
		if get_item.call(item.id,nil)
			dothistimeout "sell ##{item.id}", 5, /ask|offer/
			
			if checkleft == item.noun || checkright == item.noun
				unless put_item.call(item.id,UserVars.send(UNTRUSTED_UNTAINT.call("#{item.type}sack")))
					dothistimeout "drop ##{item.id}", 5, /drop/
					write_log.call("dropped item #{item.name} of type #{item.type}")
				end
			end
		end
	}
	
	if selling.size == 0
		msg.call("SLoot: nothing to sell", :all)
	else
		empty_hands
		
		selling.each_pair { |location,items|
			location = location.split(',').first
			go2.call(location)
			items.each { |item| sell_item.call(item) }
			
			cur_silver = checksilvers.call
			silver_breakdown[location] = cur_silver - start_silvers - (silver_breakdown.values.inject { |i,j| i + j }.to_i)
		}

		log_msg = "selling completed:"
		msg.call("SLoot: silver breakdown",:bold)
		silver_breakdown.each_pair { |location,silver|
			location = location.split(',').first
			msg.call(sprintf("  %10s: %-6s", location, silver),:mono)
			log_msg += " #{location} #{silver}"
		}
				
		total_made = silver_breakdown.values.inject { |i,j| i + j }
		respond
		msg.call(sprintf("  %10s: %-6s", 'total', total_made),:all)
		log_msg += " total #{total_made}"
		write_log.call(log_msg)
		
		go2.call(cur_room)
	end
	
	deposit_coins.call
	go2.call(cur_room)
	fill_hands
}

# Returns an array of all dead npcs using GameObj
find_dead = proc { |type| GameObj.npcs.find_all { |npc| npc.status == 'dead' } }

# Opens up a sack and keeps a record of it
open_sack = proc { |sack|
	unless sack.class == GameObj || sack = GameObj[sack]
		echo "fixme: open_sack failed to find #{sack}"
		exit
	end
	
	res = dothistimeout "open ##{sack.id}", 5, /^You open .*\.$/
	unless res
		echo "fixme: unknown open_sack result: #{res}"
		exit
	end
	
	closed_sacks.push(sack.id)
}

# Closes all opened sacks in closed_sacks
close_open_sacks = proc {
	next unless settings['enable_close_sacks']
	
	closed_sacks.each { |sack|
		res = dothistimeout "close ##{sack}", 5, /^You close .*\.$/
		unless res
			echo "fixme: unknown close_open_sacks result: #{res}"
			exit
		end
	}
}

# Checks if it's safe to enhance skinning by kneeling or stancing to offensive
safe_to_enhance = proc {
	next true unless settings['enable_skin_safe_mode']
	!GameObj.npcs.any? { |npc| npc.status !~ /dead/ }
}

# Prepares for skinning process
prepare_skinner = proc { |critter|
	next if settings['skin_exclude'].include?(critter.name)
	next if skin_prepared
	next unless GameObj.npcs.any? { |npc| npc.status =~ /dead/ }
	next unless settings['enable_skinning']
	
	# Sigil of Resolve
	if Spell[9704].known? && Spell[9704].affordable? && !Spell[9704].active? && settings['enable_skin_sigil']
		Spell[9704].cast 
	end
	
	# 604 - Skinning
	if Spell[604].known? && Spell[604].affordable? && settings['enable_skin_604']
		while !Spell[604].active? 
			Spell[604].cast 
		end
	end
	
	if settings['enable_skin_alternate']
		free_hand.call
		
		unless get_item.call(UserVars.skinweapon,UserVars.skinweaponsack)
			echo "failed to find #{UserVars.skinweapon} in #{UserVars.skinweaponsack}"
		end
	end
	
	if safe_to_enhance.call
		while settings['enable_skin_kneel'] && !checkkneeling
			dothistimeout "kneel", 5, /^You kneel down\.$/
		end
		
		while settings['enable_skin_offensive'] && percentstance > 0
			dothistimeout "stance offensive", 5, /^You are now in an offensive stance\.$|^You move into an offensive stance, ready for battle\.$/
		end
	end
	
	skin_prepared = true
}

# Get thee up!
stand_up = proc {
	if settings['skin_stand_verb'].nil? || settings['skin_stand_verb'].empty?
		until standing?
			dothistimeout "stand", 5, /^You stand back up\.$/
		end
	else
		until standing?
			fput settings['skin_stand_verb']
		end
	end
}

# Change back to previous stance
stance_back = proc {
	prev_stance_percent = 80 if prev_stance_percent > 80
	
	res = nil
	while percentstance < prev_stance_percent && res !~ /rage/
		res = dothistimeout "stance #{prev_stance}", 5, /rage|#{prev_stance}/
	end
}

# Finishes up skinning process
finish_skinner = proc {
	next unless skin_prepared
	next unless settings['enable_skinning']
	
	if settings['enable_skin_stance_first']
		stance_back.call
		stand_up.call
	else
		stand_up.call
		stance_back.call
	end
	
	if settings['enable_skin_alternate']		
		unless put_item(UserVars.skinweapon,UserVars.skinweaponsack)
			echo "failed to put #{UserVars.skinweapon} in #{UserVars.skinweaponsack}"
		end
	end
}

# Skins a critter
skin_critter = proc { |critter|	
	next if settings['skin_exclude'].include?(critter.name)
	
	cmd = "skin ##{critter.id}"
	cmd += " left" if settings['enable_stow_left']
	
	res = dothistimeout cmd, 5, /skinned|botched|already been|cannot skin|must be a member|can only skin/
	if res =~ /cannot skin/
		settings['skin_exclude'].push(critter.name)
	end
}

# Retrieves the previously stored item
get_stored = proc {
	next if stored_item.nil?
	
	if stored_result.nil?
		echo 'fixme: stored_item with no stored_result'
		exit
	end
	
	if stored_result =~ /^You sling .* over your shoulder\.$|^You shift the focus of your voice and your .* moves from your .* hand to your shoulder\.$/
		fput "remove ##{stored_item.id}"
	elsif stored_result =~ /^You put .* in your .*\.$/
		fput "get ##{stored_item.id}"
	else
		echo "fixme: unknown stored result: #{stored_result}"
		exit
	end
}

if script.vars[1] =~  /^resetgui$/i
	settings['window_height'] = nil
	settings['window_width'] = nil
	settings['window_position'] = nil
	
	echo "gui reset"
elsif script.vars[1] =~ /^deposit$/i
	deposit_coins.call
elsif script.vars[1] =~ /^sell$/i
	sell.call
elsif script.vars[1] =~  /^setup$/i
	setup.call
elsif script.vars[1] =~ /^version$/i
	echo "v#{@@version}"
elsif script.vars[1] =~ /^right$/i
	unless GameObj.right_hand.contents
		dothistimeout "look in ##{GameObj.right_hand.id}", 5, /^In the .*\.$/
		unless GameObj.right_hand.contents
			msg.call("failed to find contents of #{GameObj.right_hand.name}",:all)
		end
	end
	
	loot_it.call(GameObj.right_hand.contents,nil)
elsif script.vars[1] =~  /^(?:help|\?)$/
	msg.call( sprintf('SLoot v%f', @@version), :all)
	msg.call( sprintf('%17s: SpiffyJr &lt;spiffyjr@gmail.com&gt;', 'Author'), :mono)
	msg.call( sprintf('%17s: SLoot is designed to be the most versatile looter available!', 'Description'), :mono)
	msg.call( sprintf('%17s: ;sloot - runs the skin, search, and loot routine on the current room.', 'Usage'), :mono)
	respond
	msg.call( sprintf('%17s     %s', 'help, ?', 'show this help message'), :mono)
	msg.call( sprintf('%17s     %s', 'setup', 'run the GUI configuration'), :mono)
	respond
	msg.call( sprintf('%17s     %s', 'dump', 'dumps the current settings to the screen'), :mono)
	respond
	msg.call( sprintf('%17s     %s', 'sell', 'runs the automated selling routine'), :mono)
	msg.call( sprintf('%17s     %s', 'deposit', 'deposits your coins according to settings'), :mono)
	respond
	msg.call( sprintf('%17s     %s', 'sack', 'runs sloot on the sack specified'), :mono)
	msg.call( sprintf('%17s     %s', 'left', 'runs sloot on the sack in your left hand'), :mono)
	msg.call( sprintf('%17s     %s', 'right', 'runs sloot on the sack in your right hand'), :mono)
end

exit unless script.vars[1].nil?

# Hooks for disk tracking and statistics
install_hooks.call

# Is safe hiding enabled?
if settings['enable_safe_hiding'] && hiding?
	bad_npcs = GameObj.npcs.find_all { |npc| 
		npc.type !~ /escort/ && npc.status !~ /dead/ && npc.name !~ /^(?:#{settings['safe_ignore'].to_s})$/
	}
	exit if bad_npcs.length > 0
end

# Keep track of loot IDs in the current room if we're only looting our critter drops
previous_loot_ids = Array.new
if settings['enable_self_drops']
	previous_loot_ids = GameObj.loot.collect { |l| l.id }
end

critters = find_dead.call

if settings['enable_skinning']
	critters.each { |critter| 
		next if critter.name =~ /Grimswarm/ || critter.type =~ /bandit/
		prepare_skinner.call(critter)
		skin_critter.call(critter) 
	}
	finish_skinner.call
end

critters.each { |critter|
	dothistimeout "search ##{critter.id}", 5, /^You search the .*\.$|^What were you referring to/
	break unless settings['enable_search_all']
}

loot_it.call(GameObj.loot,previous_loot_ids)
gather_ammo.call

get_stored.call
close_open_sacks.call
