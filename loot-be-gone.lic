=begin

	This script gets rid of your loot.

	gives heirlooms to a guard
	gives bounty herbs to herbalist if the id's of the herbs are in the array $bounty_herbs
	opens boxes (off by default)
	bunldes herbs (off by default)
	gives gold rings to the chronomage
	stockpiles gems into jars in your locker (off by default)
	gets gems from the stockpile for bounties
	saves scrolls that have spells you choose (list is empty by default)
	appraise various types of items that you choose, and saves them if they're expensive
	might possibly avoid selling gems and skins that you have a bounty for in the wrong town
	sells stuff
	deposits monies

	;loot-be-gone help

	tillmen@lichproject.org

	# Author: Tillmen
	# Category: loot

=end

if defined?(GameObj.type_data)
	GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
	if GameObj.type_data.nil?
		wait_while { running?('updater') }
		wait_while { running?('repository') }
		start_script 'repository', [ 'download', 'gameobj-data.xml' ]
		wait_while { running?('repository') }
		wait_while { running?('updater') }
		start_script 'updater', [ 'add', 'gameobj-data.xml' ]
		wait_while { running?('updater') }
		GameObj.load_data
		exit if GameObj.type_data.nil?
	end
end

silence_me

withdraw_amount = 8000
close_lootsack  = false
appraise_types  = /jewelry|weapon|armor/
save_value = { 'gemshop' => 15000, 'pawnshop' => 35000 }

$loot_be_gone_ignore ||= Array.new

save_herb_list       = [ 'some torban leaf', 'some basal moss', 'some acantha leaf', 'some ambrominas leaf', 'some cactacae spine', 'some aloeas stem', 'some haphip root', 'some pothinir grass', 'some ephlox moss', 'some calamia fruit', 'some sovyn clove', 'some wolifrew lichen', 'some woth flower' ]
save_one_potion_list = [ 'white flask', 'bur-clover potion' ]
save_two_potion_list = [ 'rose-marrow potion', 'brostheras potion', 'wingstem potion', 'talneo potion', 'bolmara potion' ]

herbalist_rooms = [ 3824, 1851, 10396, 640, 5722, 2406 ]

CharSettings['keep scrolls'] = Array.new unless CharSettings['keep scrolls'].class == Array
CharSettings['exclude types'] = 'weapon|armor|scroll' if CharSettings['exclude types'].nil?
CharSettings['appraise types'] = 'jewelry|weapon|armor|uncommon' if CharSettings['appraise types'].nil?
notes = Array.new

if script.vars[1] =~ /^stockpile=(on|off|yes|no|true|false|forget)$/
	if $1 == 'forget'
		CharSettings[:jars] = nil
		echo 'stockpile tracking cleared'
	else
		fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
		CharSettings['stockpile'] = fix_option[$1]
		echo 'setting saved'
	end
	exit
elsif script.vars[1] =~ /^locker=([0-9]+|nil)$/
	if $1 == 'nil'
		CharSettings['locker'] = nil
	else
		CharSettings['locker'] = $1
	end
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^open(?:\-boxes)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['open boxes'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^bundle(?:\-herbs)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['bundle herbs'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^trash(?:\-herbs)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['trash herbs'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^(?:herb\-)?drop(?:\-room)?=(.+)$/
	if $1 == 'nil'
		CharSettings['herb drop room'] = nil
	else
		CharSettings['herb drop room'] = $1
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^exclude-names=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['exclude regex'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['exclude regex'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^exclude\-types=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['exclude types'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['exclude types'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^appraise\-types=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['appraise types'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['appraise types'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^(?:keep\-)?scrolls=(.+)$/
	option = $1
	if option.downcase == 'nil'
		CharSettings['keep scrolls'] = Array.new
		echo 'setting saved'
	elsif option =~ /^[0-9,]+$/
		CharSettings['keep scrolls'] = option.split(',').collect { |num| num.to_i }
		echo 'setting saved'
	else
		echo "You're doing it wrong."
	end
	exit
elsif script.vars[1] =~ /list/
	if script.vars[2] =~ /stockpile/
		output = "                           gem count  full\n"
		output.concat "                           --- -----  ----\n"
		for jar in CharSettings[:jars].sort { |a,b| b[:count] <=> a[:count] }
			output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
		end
		respond output
	else
		fix_option = { true => 'on', false => 'off', nil => 'off' }
		output = "\n"
		output.concat "     stockpile: #{fix_option[CharSettings['stockpile']]}\n"
		output.concat "        locker: #{CharSettings['locker'] || 'nil'}\n"
		output.concat "    open-boxes: #{fix_option[CharSettings['open boxes']]}\n"
		if CharSettings['keep scrolls'].empty?
			output.concat "  keep-scrolls: (none)\n"
		else
			output.concat "  keep-scrolls: #{CharSettings['keep scrolls'].join(',')}\n"
		end
		output.concat "  bundle-herbs: #{fix_option[CharSettings['bundle herbs']]}\n"
		output.concat "   trash-herbs: #{fix_option[CharSettings['trash herbs']]}\n"
		output.concat "herb-drop-room: #{CharSettings['herb drop room'] || '(none)'}\n"
		output.concat "\n"
		output.concat " exclude-names: #{CharSettings['exclude regex'] || '(none)'}\n"
		output.concat "\n"
		output.concat " exclude-types: #{CharSettings['exclude types'] || '(none)'}\n"
		output.concat "\n"
		output.concat "appraise-types: #{CharSettings['appraise types'] || '(none)'}\n"
		output.concat "\n"
		respond output
	end
	exit
elsif not script.vars[1].nil?
	output = "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list                           Shows current settings.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list stockpile                 Shows stockpile contents.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} stockpile=<on|off>             Stockpile gems in jars in your locker, and retrieve and sell them\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                when you have a gem bounty.\n"
	output.concat "   #{$clean_lich_char}#{script.name} locker=<room number>           Room number of the room with a curtain or opening to get to your locker.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} stockpile=forget               Clears the tracking info for the jars in your locker.  Needed\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                if you manually add or remove gems or jars from your locker.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} open-boxes=<on|off>            Uses the town npc locksmith to open boxes before selling.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=nil               Sell scrolls without reading them.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=<#,#,#>           Read scrolls and save them only if they have a spell that's in the\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                given comma separated list. (Use exclude-types to save all scrolls.)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} bundle-herbs=<on|off>          Bundles herbs commonly found in the loot system with those\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                found in your herbsack.  Keeps only one full bundle or two\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                full potions of each type, and drops the rest.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} trash-herbs=<on|off>           Throw away herbs found in boxes\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<room number>   Sets the room where extra herbs will be dropped.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<varname>       If <varname> is \"rest_room\", the script will look up the drop\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                room from rest_room as shown in the ;settings command.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=nil             Clears the setting.  Extra herbs will be dropped where ever you\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                happen to be standing (could be the room the script was started\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                in, the locksmith, the herbalist, or the town guard)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} types=<regex>                  Only sell items whose type matches the given regex. (does not\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                stop items marked as new loot from being sold or dropped)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-names=<regex>          Any item names matching the given regex will not be sold.\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-names=nil              Clears the setting.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-types=<regex>          Any item type matching the given regex will not be sold.\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                Meaningful types will change as gameobj-data.xml changes, but\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                here's a random list: gem, skin, reagent, jewelry, magic, uncommon,\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                herb, food, weapon, armor, clothing, alchemy product, cursed\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-types=nil              Clears the setting.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} appraise-types=<regex>         Any item type matching the given regex will be appraised first,\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                and saved if it's expensive.\n"
	output.concat "   #{$clean_lich_char}#{script.name} appriase-types=nil             Clears the setting.\n"
	respond output
	exit
end

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
	echo 'error: lootsack is not set. (;set change lootsack <container name>)'
	exit
end
unless lootsack = (GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.lootsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.lootsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.lootsack).sub(' ', ' .*')}/i })
	echo 'error: failed to find your lootsack'
	exit
end
close_lootsack = false
if lootsack.contents.nil?
	open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
	if open_result =~ /^You open/
		close_lootsack = true
	else
		dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
		if lootsack.contents.nil?
			echo 'error: failed to find lootsack contents'
			exit
		end
	end
end

if CharSettings['bundle herbs']
	if UserVars.herbsack.nil? or UserVars.herbsack.empty?
		echo 'herbsack is not set. (;set change herbsack <container name>)'
		exit
	end
	unless herbsack = (GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}$/i })
		echo 'error: failed to find your herbsack'
		exit
	end
end

check_silvers = proc {
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("#{script.name}_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("#{script.name}_check_silvers", action)
	save_silent = script.silent
	script.silent = true
	put 'info'
	script.silent = save_silent
	wait_until { silvers }
	silvers
}

need_to_open_boxes = proc {
	need = true
	unless (GameObj.right_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/) or (GameObj.left_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/) or lootsack.contents.find { |obj| obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/ }
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
			if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\.\r?$/ }
				50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
			end
		end
		if disk and disk.contents.nil?
			dothistimeout "look in ##{disk.id}", 2, /^In the|^There is nothing in there\.$/
		end
		unless disk.contents.any? { |obj| obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/ }
			need = false
		end
	end
	need
}

table = activator = trash = nil
open_box = proc { |box|
	unless (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
		dothistimeout "get ##{box.id}", 3, /^You remove|^Get what\?$/
	end
	if (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
		put_result = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^Your .*? won't fit on .*?\.$/
		if (put_result =~ /won't fit/) and table.contents.length > 1
			for obj in table.contents
				if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
					room_id = Room.current.id
					if room_id == 1881 # Teras
						move "drag ##{obj.id} out"
						move "go doorway"
					elsif room_id == 5724 # Solhaven
						move "drag ##{obj.id} north"
						move "south"
					elsif room_id == 5612 # Wehnimer's
						move "drag ##{obj.id} doorway"
						move "go doorway"
					elsif room_id == 4024
						move "drag ##{obj.id} out"
						move "go buildings"
					elsif room_id == 10943
						move "drag ##{obj.id} out"
						move "go lockworks"
					else
						fput "get ##{obj.id}"
						sleep 0.1
						fput "drop ##{obj.id}"
						sleep 0.1
					end
				end
			end
			put_result = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^Your .*? won't fit on .*?\.$|^You should really/
			if put_result =~ /^You should really/
				dothistimeout "drop ##{box.id}", 3, /flickers in and out of existence/
				dothistimeout "get ##{box.id}", 3, /^You pick up/
				put_result = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^Your .*? won't fit on .*?\.$/
			end
		end
		if put_result =~ /^You put/
			fput 'unhide' if invisible?
			activator_result = dothistimeout activator, 5, /^You .*? the .*? but .*? ignores you|I'm afraid that you can't pull that.|^You .*? the .*?, and ask .*?/
			if activator_result =~ /^You .*? the .*?, and ask .*?|^You .*? the .*? but .*? ignores you/
				if activator_result =~ /^You .*? the .*? but .*? ignores you/
					pay_result = 'accepts your silvers'
				else
					pay_result = dothistimeout 'pay', 5, /^But you don't have enough!|accepts your silvers/
				end
				if pay_result =~ /accepts your silvers/
					get_result = dothistimeout "get ##{box.id}", 5, /^Get what?|^You remove/
					if get_result =~ /^You remove/
						open_result = dothistimeout "open ##{box.id}", 5, /^You open|^That is already open\.|^It appears to be locked\./
						if open_result =~ /^You open|^That is already open\./
							get_result = dothistimeout "get coins from ##{box.id}", 5, /^You gather the remaining|^Get what\?/
							unless get_result =~ /^You gather the remaining/
								echo 'fixme (9)'
							end
							waitrt?
							drop_box = false
							for obj in box.contents
								if obj.type =~ /cursed/
									drop_box = true
									next
								elsif (obj.type =~ /junk|food/) or (CharSettings['trash herbs'] and obj.type =~ /herb/)
									dothistimeout "get ##{obj.id}", 3, /^You/
									if trash
										dothistimeout "put ##{obj.id} in ##{trash.id}", 3, /^You put|^As you place/
									else
										dothistimeout "drop ##{obj.id}", 3, /^You drop/
									end
								else
									dothistimeout "_drag ##{obj.id} ##{lootsack.id}", 3, /^You put/
								end
							end
							if drop_box
								dothistimeout "drop ##{box.id}", 3, /^You drop/
							else
								unless box.contents.empty?
									echo 'error: box is not empty'
									dothistimeout "put ##{box.id} in ##{lootsack.id}", 3, /^You put/
								end
								if trash
									dothistimeout "put ##{box.id} in ##{trash.id}", 3, /^You put|^As you place/
								else
									dothistimeout "drop ##{box.id}", 3, /^You drop/
								end
							end
							sleep 0.1
						elsif open_result =~ /^It appears to be locked\./
							echo 'fixme (2382)'
						else
							echo 'fixme (8)'
						end
					else
						echo 'fixme (7)'
					end
				elsif pay_result =~ /^But you don't have enough!/
					dothistimeout "get ##{box.id}", 5, /^You remove/
					start_script 'go2', [ 'bank', '--disable-confirm' ]
					wait_while { running?('go2') }
					fput "withdraw #{withdraw_amount} silvers"
					start_script 'go2', [ 'locksmith', '--disable-confirm' ]
					wait_while { running?('go2') }
					open_box.call(box)
				else
					echo 'fixme (6)'
				end
			else
				echo 'fixme (5)'
			end
		else
			echo 'fixme (4)'
			fput "drop ##{box.id}"
		end
	else
		echo 'fixme (3)'
	end
}

to_locker = proc {
	silvers = check_silvers.call
	if silvers < 526
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while { running?('go2') }
		fput 'unhide' if invisible?
		fput "withdraw #{526 - silvers}"
	end
	start_script 'go2', [ CharSettings['locker'] ]
	wait_while { running?('go2') }
	if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
		move "go #{way_in.noun}"
	else
		false
	end
}

from_locker = proc {
	if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
		move "go #{way_out.noun}"
	end
}

need_to_stockpile = proc {
	if CharSettings[:jars].any? { |jar| jar[:gem] =~ /large|medium|small|tiny/ }
		CharSettings[:jars] = nil
	end
	can_start_new_jar = (CharSettings[:empty_jar_count] > 0) && lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
	can_add_to_jar = CharSettings[:jars].any? { |jar| !jar[:full] && lootsack.contents.any? { |obj| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
	CharSettings[:jars].nil? || can_start_new_jar || can_add_to_jar
}

need_to_raid_stockpile = proc {
	if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
		gem = $1
		count = $2.to_i
		if checkbounty =~ /(Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)/
			target_town = $1
			gemshop = Room[Room[CharSettings['locker']].find_nearest_by_tag('gemshop')]
			if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (gemshop.location !~ /#{target_town}/)
				false
			else
				CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
			end
		else
			CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
		end
	else
		false
	end
}

stockpile = proc {
	status_tags
	open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
	status_tags
	if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
		locker_id = $1
		locker_contents = GameObj.containers[locker_id]
		unless locker_contents
			dothistimeout "look in ##{locker_id}", 3, /^In the/
			locker_contents = GameObj.containers[locker_id]
		end
		if locker_contents
			if CharSettings[:jars].nil?
				CharSettings[:jars] = Array.new
				CharSettings[:empty_jar_count] = 0
				locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
					if jar.after_name.nil?
						CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
					else
						look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 3, /^Inside .*? you see [0-9]+ portion/
						if look_result =~ /^Inside .*? you see ([0-9]+) portion/
							count = $1.to_i
							gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
							full = look_result.include?('It is full')
							CharSettings[:jars].push(h={ :gem => gem, :count => count, :full => full })
						end
					end
				}
			end
			empty_hands
			not_suitable = Array.new
			for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
				if jar.after_name =~ /^containing /
					gem_list = lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) }
					gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
					jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') }
					unless gem_list.empty? or jar_hash[:full]
						dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
						for gem in gem_list
							result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 3, /^You add|is full|does not appear to be a suitable container for/
							if result =~ /^You add .* filling it/
								jar_hash[:count] = jar_hash[:count] + 1
								jar_hash[:full] = true
							elsif result =~ /^You add/
								jar_hash[:count] = jar_hash[:count] + 1
							elsif result =~ /is full/
								jar_hash[:full] = true
								dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, /^You put/
								break
							elsif result =~ /does not appear to be a suitable container for/
								dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, /^You put/
								not_suitable.push(gem.id)
							else
								dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, /^You put/
							end
						end
						dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
					end
				else
					gem_count = Hash.new
					lootsack.contents.each { |obj|
						if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ and not not_suitable.include?(obj.id) }
							gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')].to_i + 1
						end
					}
					next if gem_count.empty?
					gem_name = nil
					gem_num = 0
					gem_count.each_pair { |name,num|
						if num > gem_num
							gem_name = name
							gem_num = num
						end
					}
					dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
					jar_hash = nil
					lootsack.contents.each { |obj|
						if obj.name.gsub(/large |medium |small |tiny |some /, '') == gem_name
							result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 3, /^You (?:add|put)|is full|does not appear to be a suitable container for/
							if result =~ /^You put/
								dothistimeout "put ##{jar.id} in ##{lootsack.id}", 3, /^You put/
								gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
								dothistimeout "get ##{jar.id}", 3, /^You remove/
								jar_hash = { :gem => gem, :count => 1, :full => false }
								CharSettings[:jars].push(jar_hash)
							elsif result =~ /^You add/
								jar_hash[:count] = jar_hash[:count] + 1
							elsif result =~ /is full/
								dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
								jar_hash[:full] = true
								break
							elsif result =~ /does not appear to be a suitable container for/
								not_suitable.push(obj.id)
								fput "put ##{obj.id} in ##{lootsack.id}"
							end
						end
					}
					dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
				end
			end
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			fill_hands
		else
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			echo 'error: failed to find locker contents'
		end
	else
		dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
		echo 'error: failed to find locker'
	end
}

raid_stockpile = proc {
	if bounty? =~ /gem dealer .* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
		gem = $1
		count = $2.to_i
		gem.gsub!(/large |medium |small |tiny |some /, '')
		status_tags
		open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
		status_tags
		if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
			locker_id = $1
			locker_contents = GameObj.containers[locker_id]
			unless locker_contents
				dothistimeout "look in ##{locker_id}", 3, /^In the/
				locker_contents = GameObj.containers[locker_id]
			end
			if locker_contents
				if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
					if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ }
						jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, '') }
						empty_hands
						dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
						count.times {
							dothistimeout "shake ##{jar.id}", 3, /^You .*shake/
							if GameObj.right_hand.id != jar.id
								obj = GameObj.right_hand
							elsif GameObj.left_hand.id != jar.id
								obj = GameObj.left_hand
							end
							dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
							jar_hash[:count] = jar_hash[:count] - 1
							jar_hash[:full] = false
						}
						dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
						if jar_hash[:count] < 1
							CharSettings[:jars].delete(jar_hash)
							CharSettings[:empty] = CharSettings[:empty] + 1
						end
						fill_hands
						dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
						true
					else
						dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
						false
					end
				else
					dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
					false
				end
			else
				dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
				echo 'error: failed to find locker contents'
				false
			end
		else
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			echo 'error: failed to find locker'
			false
		end
	else
		echo "error: you're doing it wrong"
		false
	end
}

# this variable isn't used anymore, but loot.lic is probably still adding to it, so clear it before it gets out of control
$new_loot = Array.new

did_something = false

if bounty? =~ /You have located the heirloom/
	did_something = true
	start_script 'go2', [ 'advguard', '--disable-confirm' ]
	wait_while { running?('go2') }
	unless (guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }) or (checkroom == "[River's Rest, Purser's Office]")
		start_script 'go2', [ 'advguard2', '--disable-confirm' ]
		wait_while { running?('go2') }
		guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }
	end
	if guard or (checkroom == "[River's Rest, Purser's Office]")
		close_lootsack = false
		for item in lootsack.contents
			look_result = dothistimeout "look ##{item.id}", 3, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
			if look_result =~ /^Engraved .* initials/
				fput 'unhide' if invisible?
				empty_hands
				fput "get ##{item.id}"
				if guard
					result = dothistimeout "give ##{guard.id}", 3, /I shall inform the Adventurer's Guild that you successfully completed your task|The guard is in no condition to receive your offer!/
					if result =~ /The guard is in no condition to receive your offer!/
						fput "put ##{item.id} in ##{lootsack.id}"
					end
				else
					fput "give purser"
				end
				fill_hands
				break
			end
		end
		fput "close ##{lootsack.id}" if close_lootsack
	end
end

$bounty_herbs ||= Array.new
unless $bounty_herbs.empty?
	did_something = true
	target = Room.current.find_nearest(herbalist_rooms)
	start_script 'go2', [ target.to_s ]
	wait_while { running?('go2') }
	empty_hands
	for herb_id in $bounty_herbs
		fput "get ##{herb_id}"
		fput 'unhide' if invisible?
		fput "give #{GameObj.npcs.last.noun}"
		25.times { break unless checkright; sleep 0.1 }
		fput "put ##{herb_id} in ##{lootsack.id}" if checkright
	end
	fill_hands
	$bounty_herbs.clear
end

if CharSettings['open boxes'] and need_to_open_boxes.call
	did_something = true
	silvers = check_silvers.call
	if silvers < withdraw_amount
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while { running?('go2') }
		fput 'unhide' if invisible?
		fput "withdraw #{withdraw_amount - silvers} silvers"
	end
	start_script 'go2', [ 'locksmith', '--disable-confirm' ]
	wait_while { running?('go2') }
	unless trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:crate|barrel|wastebarrel|casket)$/ } || trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun == 'coffer' }
		echo 'warning: failed to find a trash container'
	end
	if table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:table|counter)$/ }
		if table.contents.nil?
			dothistimeout "look on ##{table.id}", 5, /On the .*? you see/
			if not table.contents.nil?
				activator = nil
				if table.contents.any? { |obj| obj.noun == 'bell' }
					activator = 'ring bell'
				elsif table.contents.any? { |obj| obj.noun == 'keys' }
					activator = 'pull keys'
				elsif table.contents.any? { |obj| obj.noun == 'chime' } or GameObj.loot.any? { |obj| obj.noun == 'chime' }
					activator = 'ring chime'
				end
				if activator
					max_wait = Time.now + 120
					after = table.contents.collect { |obj| obj.id }
					while checkpcs
						before = after.dup
						100.times {
							sleep 0.2
							break unless checkpcs
							after = table.contents.collect { |obj| obj.id }
							break if before != after
						}
						break if (before == after) or (Time.now > max_wait)
					end
					empty_hands
					for obj in lootsack.contents
						if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
							open_box.call(obj)
						end
					end
					unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
						if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\./ }
							50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
							disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
						end
					end
					if disk
						if GameObj.loot.any? { |obj| obj.id == disk.id }
							if disk.contents.nil?
								dothistimeout "look in ##{disk.id}", 2, /^In the|^There is nothing in there\.$/
							end
							for obj in disk.contents
								if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
									open_box.call(obj)
								end
							end
							$disk_full = false
						end
					end
					dothistimeout "drop ##{GameObj.right_hand.id}", 3, /^You drop/ if GameObj.right_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
					dothistimeout "drop ##{GameObj.left_hand.id}", 3, /^You drop/ if GameObj.left_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
					fill_hands
					dothistimeout "drop ##{GameObj.right_hand.id}", 3, /^You drop/ if GameObj.right_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
					dothistimeout "drop ##{GameObj.left_hand.id}", 3, /^You drop/ if GameObj.left_hand.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
				else
					echo 'error: failed to find a bell, keys, or chime on the table'
				end
			else
				echo 'error: failed to find table contents'
			end
		end
	else
		echo 'error: failed to find a table'
	end
end

if CharSettings['bundle herbs'] and lootsack.contents.any? { |obj| save_herb_list.include?(obj.name) or save_one_potion_list.include?(obj.name) or save_two_potion_list.include?(obj.name) }
	# fixme: allow lootsack and herbsack to be the same
	did_something = true
	if CharSettings['herb drop room'].nil?
		herb_drop_room = nil
	elsif CharSettings['herb drop room'] =~ /^[0-9]+$/
		herb_drop_room = CharSettings['herb drop room'].to_i
	elsif (UserVars.send(CharSettings['herb drop room']).class == Fixnum) or (UserVars.send(CharSettings['herb drop room']) =~ /^[0-9]+$/)
		herb_drop_room = UserVars.send(CharSettings['herb drop room']).to_i
	else
		echo 'warning: bad herb-drop-room setting'
		herb_drop_room = nil
	end
	check_drop_room = proc {
		unless herb_drop_room.nil? or Room.current.id == herb_drop_room
			start_script 'go2', [ herb_drop_room.to_s ]
			wait_while { running?('go2') }
		end
	}
	if herbsack.contents.nil?
		open_result = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open\.$/
		if open_result =~ /^You open/
			close_herbsack = true
		else
			dothistimeout "look in ##{herbsack.id}", 5, /In .*? you see/
		end
	end
	if not herbsack.contents.nil?
		empty_hands
		while herb_name = lootsack.contents.find { |obj| save_herb_list.include?(obj.name) }.name
			if bundle = herbsack.contents.find { |obj| obj.name == herb_name }
				dothistimeout "get ##{bundle.id}", 3, /^You remove/
			end
			drop_herb = false
			while herb = lootsack.contents.find { |obj| obj.name == herb_name }
				dothistimeout "get ##{herb.id}", 3, /^You remove/
				if drop_herb
					check_drop_room.call
					dothistimeout "drop ##{herb.id}", 3, /^You drop/
				else
					while checkleft and checkright
						bundle_result = dothistimeout 'bundle', 3, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$/
						if bundle_result =~ /^If you add anything more to this bundle/
							drop_herb = true
							dothistimeout "eat ##{herb.id}", 3, /^You take a bite/
						elsif bundle_result.nil?
							break
						end
					end
				end
			end
			dothistimeout "put ##{GameObj.right_hand.id} in ##{herbsack.id}", 3, /^You put/ if checkright
			dothistimeout "put ##{GameObj.left_hand.id} in ##{herbsack.id}", 3, /^You put/ if checkleft
		end
		while potion_name = lootsack.contents.find { |obj| save_one_potion_list.include?(obj.name) or save_two_potion_list.include?(obj.name) }.name
			drop_potion = false
			while potion = lootsack.contents.find { |obj| obj.name == potion_name }
				dothistimeout "get ##{potion.id}", 3, /^You remove/
				herbsack_potion_list = herbsack.contents.find_all { |obj| obj.name == potion_name }
				for herbsack_potion in herbsack_potion_list
					pour_result = dothistimeout "pour ##{potion.id} in ##{herbsack_potion.id}", 3, /^You carefully pour|^You can't pour any more|^I can't find that\.$|^You can't pour that\.$/
					redo if pour_result =~ /^You carefully pour/
				end
				if (GameObj.right_hand.id == potion.id) or (GameObj.left_hand.id == potion.id)
					if herbsack_potion_list.nil? or (herbsack_potion_list.length < 2 and save_two_potion_list.include?(potion_name)) or (herbsack_potion_list.length < 1 and save_one_potion_list.include?(potion_name))
						dothistimeout "put ##{potion.id} in ##{herbsack.id}", 3, /^You put/
					else
						drop_potion = true
						check_drop_room.call
						dothistimeout "drop ##{potion.id}", 3, /^You drop/
					end
				end
			end
		end
		fill_hands
	else
		echo 'error: failed to find herbsack contents'
	end
	dothistimeout "close ##{herbsack.id}", 3, /^You close|^That is already closed\.$/ if close_herbsack
end

if XMLData.game =~ /^(?:GSF|GSIV)$/
	ring_list = lootsack.contents.to_a.find_all { |obj| obj.name =~ /gold ring$/ }
	unless ring_list.empty?
		did_something = true
		start_script('go2', [ 'chronomage', '--disable-confirm' ])
		wait_while { running?('go2') }
		empty_hand
		if npc = GameObj.npcs.last
			for ring in ring_list
				fput "get ##{ring.id}"
				fput 'unhide' if invisible?
				fput "give ##{ring.id} to #{npc.noun}"
				sleep 0.3
				fput "put ##{ring.id} in ##{lootsack.id}" if (GameObj.right_hand.id == ring.id) or (GameObj.left_hand.id == ring.id)
			end
		end
		fill_hand
	end
end

if CharSettings['stockpile'] and CharSettings['locker'].nil?
	echo 'warning: stockpiling is turned on but locker room is not set'
end

if CharSettings['stockpile'] and CharSettings['locker'] and (need_to_stockpile.call or need_to_raid_stockpile.call)
	did_something = true
	if to_locker.call
		stockpile.call if need_to_stockpile.call
		raid_stockpile.call if need_to_raid_stockpile.call
		from_locker.call
	end
end

for place in [ 'consignment', 'furrier', 'gemshop', 'pawnshop' ]
	sell_list = lootsack.contents.to_a.find_all { |obj| (!CharSettings['exclude regex'] or obj.name !~ /#{CharSettings['exclude regex']}/o) and (!CharSettings['exclude types'] or obj.type !~ /#{CharSettings['exclude types']}/o) and (UserVars.needed_reagents.nil? or UserVars.needed_reagents.empty? or obj.name !~ /#{UserVars.needed_reagents}/) and !$loot_be_gone_ignore.include?(obj.id) and (obj.sellable =~ /#{place}/) }
	if checkbounty =~ /gem dealer.*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor).*? requesting (?:a|an) (.*?)\. .* retrieve [0-9]+ (?:more )?of them\./
		target_town = $1
		gem = $2
		gemshop = Room[Room.current.find_nearest_by_tag('gemshop')]
		if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (gemshop.location !~ /#{target_town}/)
			sell_list.delete_if { |obj| obj.name.sub(/large |medium |small |tiny |some /, '') == gem }
		end
	end
	if checkbounty =~ /tasked to retrieve [0-9]+ (.*?) of at least .*? quality .*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)\./
		skin = $1
		target_town = $2
		skin.sub!(/s$/, '')
		furrier = Room[Room.current.find_nearest_by_tag('furrier')]
		if furrier.location and (furrier.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (furrier.location !~ /#{target_town}/)
			sell_list.delete_if { |obj| obj.name =~ /^(?:bundle of )?#{skin}\s?$/ }
		end
	end
	unless sell_list.empty?
		did_something = true
		start_script('go2', [ place, '--disable-confirm' ])
		wait_while { running?('go2') }
		empty_hands
		for obj in sell_list
			if (obj.type =~ /scroll/) and not CharSettings['keep scrolls'].empty?
				script.want_downstream = false
				script.want_downstream_xml = true
				result = dothistimeout "read ##{obj.id}", 5, /^On the/
				if result.nil?
					script.want_downstream = true
					script.want_downstream_xml = false
					echo "error: failed to read scroll"
					$loot_be_gone_ignore.push(obj.id)
					next
				end
				spell_list = Array.new
				while (line = get) and line !~ /<prompt/
					if line =~ /noun="([0-9]+)"/
						spell_list.push($1.to_i)
					end
				end
				script.want_downstream = true
				script.want_downstream_xml = false
				unless (CharSettings['keep scrolls'] & spell_list).empty?
					$loot_be_gone_ignore.push(obj.id)
					next
				end
			end
			dothistimeout "get ##{obj.id}", 2, /^You remove/
			fput 'unhide' if invisible?
			if CharSettings['appraise types'] and (obj.type =~ /#{CharSettings['appraise types']}/o) and save_value[place]
				result = dothistimeout "appraise ##{obj.id}", 5, /[0-9,]+ (?:silver|for it if you want to sell)|I'm not buying anything this valuable today|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?/
				if result.nil? or result =~ /not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?/
					dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
					next
				elsif (result =~ /([0-9,]+) (?:silver|for it if you want to sell)/ and $1.gsub(',', '').to_i >= save_value[place]) or result =~ /I'm not buying anything this valuable today/
					dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
					$loot_be_gone_ignore.push(obj.id)
					next
				end
			end
			fput 'unhide' if invisible?
			dothistimeout "sell ##{obj.id}", 2, /(?:pays|hands) you [0-9]+ silver/
			if GameObj.right_hand.noun =~ /^(?:note|scrip|chit)$/
				notes.push(GameObj.right_hand.id)
				dothistimeout "put ##{GameObj.right_hand.id} in ##{lootsack.id}", 3, /^You put/
			end
			if GameObj.left_hand.noun =~ /^(?:note|scrip|chit)$/
				notes.push(GameObj.left_hand.id)
				dothistimeout "put ##{GameObj.left_hand.id} in ##{lootsack.id}", 3, /^You put/
			end
			if (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id)
				fput "put ##{obj.id} in ##{lootsack.id}"
			end
		end
		fill_hands
	end
end

silvers = check_silvers.call
if (silvers > 0) or (notes.length > 0)
	did_something = true
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while { running?('go2') }
	fput 'unhide' if invisible?
	if silvers > 0
		dothistimeout "deposit #{silvers}", 2, /^You/
	end
	for note in notes
		dothistimeout "get ##{note}", 2, /^You/
		fput 'unhide' if invisible?
		dothistimeout "deposit ##{note}", 2, /^You/
	end
end

fput "close ##{lootsack.id}" if close_lootsack

if did_something
	echo 'done'
else
	echo 'nothing to do'
end

# fixme: There is no merchant here that can buy that
# fixme: The glass jar does not appear to be a suitable container for a black helmet shell.
