=begin

	alchemy script of doom!!!1!one

	;alchemy help

	tillmen@lichproject.org

=end

# fixme: run outta money
# fixme: full containers
# fixme: jars with unneeded ingredients ;e GameObj['bag'].contents.find_all { |obj| obj.noun == 'jar' }.each { |jar| echo jar.after_name unless jar.after_name.sub(/^containing /, '') =~ /#{UserVars.needed_reagents.gsub('$|^', 's?$|^').gsub('tooth', '(?:tooth|teeth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').gsub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').gsub(' ', 's? ')}/ }
# fixme: forage some mushrooms only certain times of day
# fixme: Khelorof says, "To rise to the top, you must diversify.  You need to learn 2 rank(s) of other skills before I can promote you in this skill again."

silence_me

CharSettings['hide-gld-check']     = true  if CharSettings['hide-gld-check'].nil?
CharSettings['hide-bundle-check']  = true  if CharSettings['hide-bundle-check'].nil?
CharSettings['hide-jar-check']     = true  if CharSettings['hide-jar-check'].nil?
CharSettings['cast-sanctuary']     = true  if CharSettings['cast-sanctuary'].nil?
CharSettings['buy-crap']           = false if CharSettings['buy-crap'].nil?
CharSettings['throw-away-crap']    = false if CharSettings['throw-away-crap'].nil?
CharSettings['sell-crap']          = false if CharSettings['sell-crap'].nil?
CharSettings['max-travel-time']  ||=   90
CharSettings['max-hunt-time']    ||=  300
CharSettings['max-forage-time']  ||=  300
CharSettings['cost-per-second']  ||=   15
CharSettings['favorite-recipes'] ||= Array.new

known_recipes = [

	#
	# general alchemy recipes
	#

	r = {
		:product => 'tincture of acantha',
		:steps   => [ 'light', 'add flask of clear water', 'add some acantha leaf', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 1, 12 ],
	},
	r = {
		:product => 'tincture of tkaro',
		:steps   => [ 'light', 'add flask of clear water', 'add tkaro root', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 1, 12 ],
	},
	r = {
		:product => 'tincture of ambrominas',
		:steps   => [ 'light', 'add flask of clear water', 'add some ambrominas leaf', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 13 ],
	},
	r = {
		:product => 'tincture of wolifrew',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground wolifrew', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 3, 14 ],
	},
	r = {
		:product => 'minor health potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground cuctucae', 'add some ground cuctucae', 'add some ground cuctucae', 'add ayanad crystal', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 15 ],
	},
	r = {
		:product => 'tincture of rose-marrow',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground rose-marrow', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 15 ],
	},
	r = {
		:product => 'tincture of basal',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground basal moss', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 5, 16 ],
	},
	r = {
		:product => 'tincture of yabathilium',
		:steps   => [ 'light', 'add flask of clear water', 'add yabathilium fruit', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 6, 18 ],
	},
	r = {
		:product => 'minor mana potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 10, 23 ],
	},
	r = {
		:product => "grot'tkel potion",
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'boil', 'add ayanad crystal', 'simmer', 'add some crystal core essence', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 25 ],
	},
	r = {
		:product => 'tincture of bolmara',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground bolmara', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 20 ],
	},
	r = {
		:product => 'tincture of cactacae',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground cactacae', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 24 ],
	},
	r = {
		:product => 'tincture of ephlox',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground ephlox moss', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 20 ],
	},
	r = {
		:product => 'tincture of aloeas',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some aloeas stem', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 21 ],
	},
	r = {
		:product => 'tincture of haphip',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground haphip', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 26 ],
	},
	r = {
		:product => 'tincture of pothinir',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some pothinir grass', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 22 ]
	},
	r = {
		:product => 'tincture of talneo',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground talneo', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 27 ],
	},
	r = {
		:product => 'tincture of torban',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some torban leaf', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 25 ],
	},
	r = {
		:product => "aish'vrak potion",
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add ayana leaf', 'boil', 'add ayanad crystal', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'add some crystal core essence', 'add some crystal core essence', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 20 ],
	},
	r = {
		:product => 'flask of pure water',
		:steps   => [ 'distill flask of clear water' ],
		:type    => 'alchemy',
		:rank    => [ 15, 62 ]
	},
	r = {
		:product => 'tincture of calamia',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some calamia fruit', 'boil', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 15, 28 ],
	},
	r = {
		:product => 'minor mana-well potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground tkaro', "add s'ayanad crystal", 'add some faintly glimmering dust', 'add some faintly glimmering dust', 'simmer', 'add some glimmering blue essence dust', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 16, 33 ],
	},
	r = {
		:product => 'tincture of woth',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some woth flower', 'boil', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 16, 30 ],
	},
	r = {
		:product => 'tincture of brostheras',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some brostheras grass', 'boil', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 17, 31 ],
	},
	r = {
		:product => 'tincture of wingstem',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground wingstem', 'simmer', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 18, 33 ],
	},
	r = {
		:product => 'tincture of bur-clover',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground bur-clover', 'simmer', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 19, 33 ],
	},
	r = {
		:product => 'minor mana regen potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add some ground tkaro', 'add some ground tkaro', 'simmer', "add s'ayanad crystal", 'add glimmering blue mote of essence', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 20, 34 ]
	},
	r = {
		:product => 'tincture of sovyn',
		:steps   => [ 'light', 'add flask of clear water', 'add handful of sea salt', 'add some ground sovyn', 'simmer', 'add some essence of regeneration', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 20, 34 ],
	},
	r = {
		:product => 'lesser health potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground marallis', 'add some ground marallis', 'add some ground marallis', "add s'ayanad crystal", 'boil', 'add small troll tooth', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 22, 38 ],
	},
	r = {
		:product => 'lesser mana potion',
		:steps   => [ 'light', 'add flask of clear water', "add s'ayanad crystal", 'add some faintly glimmering dust', 'simmer', 'add glimmering blue essence shard', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 28, 44 ],
	},
	r = {
		:product => 'essence shard',
		:steps   => [ 'light', 'add vial of viscous liquid', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 30, 34 ],
	},
	r = {
		:product => 'ayanad crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add essence shard', 'add some faintly glowing dust', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 30, 46 ],
	},
	r = {
		:product => "s'ayanad crystal",
		:steps   => [ 'light', 'add vial of viscous liquid', 'add essence shard', 'add some faintly radiant dust', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 30, 46 ],
	},
	r = {
		:product => "t'ayanad crystal",
		:steps   => [ 'light', 'add vial of viscous liquid', 'add essence shard', 'add some faintly shimmering dust', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 30, 46 ],
	},
	r = {
		:product => 'small flask of normal-strength skin glue',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered sea urchin shell', 'add some powdered crystal crab shell', 'add some powdered crystal crab shell', 'add some essence of earth', 'add some essence of water', 'add some glimmering blue essence dust', 'infuse', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 30, 40 ],
	},
	r = {
		:product => 'lesser mana-well potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground tkaro', "add t'ayanad crystal", 'add some faintly glowing dust', 'add some faintly glowing dust', 'simmer', 'add some glowing violet essence dust', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 31, 48 ],
	},
	r = {
		:product => 'minor sneezing powder',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered citrine quartz', 'add some essence of fire', 'simmer', 'add pepperthorn root', 'add pepperthorn root', 'add pepperthorn root', 'add ayanad crystal', 'add ayanad crystal', 'boil', 'add vial of concentrated firethorn essence', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 34, 51 ],
	},
	r = {
		:product => 'minor luck talisman',
		:steps   => [ 'light', 'add vial of pearlescent oil', 'add some ground tkaro', 'add some ground tkaro', 'boil', 'add luckbloom blossom', "add s'ayanad crystal", 'simmer', 'add some powdered white pearl', "add pristine nymph's hair", 'infuse', 'add smooth stone', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 37, 55 ],
	},
	r = {
		:product => 'lesser mana regeneration potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add some ground tkaro', 'add some ground tkaro', 'simmer', "add t'ayanad crystal", 'add glowing violet mote of essence', 'add some faintly glowing dust', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 40, 58 ]
	},
	r = {
		:product => 'greater mana potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayanad crystal', "add s'ayanad crystal", "add s'ayanad crystal", 'add some faintly glimmering dust', 'simmer', 'add glowing violet essence shard', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 44, 62 ],
	},
	r = {
		:product => 'major sneezing powder',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered rose quartz', 'add some essence of fire', 'add some essence of fire', 'simmer', 'add pepperthorn root', 'add pepperthorn root', 'add pepperthorn root', "add s'ayanad crystal", "add s'ayanad crystal", 'boil', 'add vial of concentrated firethorn essence', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 47, 62 ],
	},
	r = {
		:product => 'spirit shard',
		:steps   => [ 'light', 'add vial of viscous liquid', 'channel', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 50, 58 ],
	},
	r = {
		:product => 'mottled malachite talisman',
		:nick    => 'lesser luck talisman',
		:steps   => [ 'light', 'add vial of pearlescent oil', 'add some ground tkaro', 'add some ground tkaro', 'boil', 'add luckbloom blossom', 'add luckbloom blossom', "add t'ayanad crystal", 'simmer', 'add some powdered white pearl', 'infuse', "add pristine sprite's hair", 'channel', 'add green malachite stone', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 50, 62 ],
	},
	r = {
		:product => 'greater mana-well potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground tkaro', "add s'ayanad crystal", "add t'ayanad crystal", 'simmer', 'add some faintly radiant dust', 'add some faintly radiant dust', 'infuse', 'add some radiant crimson essence dust', 'channel', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 57, 62 ],
	},
	r = {
		:product => 'full health potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground cothinar', 'add some ground cothinar', 'add some ground cothinar', "add n'ayanad crystal", 'boil', 'chant 1101', 'add flask of sparkling body essence', 'channel',  'seal' ],
		:type    => 'alchemy',
		:rank    => [ 58, 62 ],
		:for    => [ 'Empath' ],
	},
	r = {
		:product => 'glowing moonstone talisman',
		:nick    => 'greater luck talisman',
		:steps   => [ 'light', 'add vial of pearlescent oil', 'add some ground tkaro', 'add some ground tkaro', 'boil', 'add luckbloom blossom', 'add luckbloom blossom', 'add luckbloom blossom', 'add luckbloom blossom', 'add some faintly glowing dust', 'add some faintly glowing dust', 'simmer', 'add some powdered white pearl', "add t'ayanad crystal", 'infuse', "add pristine siren's hair", 'channel', 'add golden moonstone', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 60, 62 ],
	},
	r = {
		:product => 'greater mana regeneration potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add ayana leaf', 'add some ground tkaro', 'add some ground tkaro', 'simmer', "add s'ayanad crystal", "add t'ayanad crystal", 'infuse', 'add radiant crimson mote of essence', 'add some faintly radiant dust', 'channel', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 60, 62 ],
	},
	r = {
		:product => 'tiny vial of extra-strong skin glue',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered iridescent tempest shell', "add some powdered deep blue mermaid's tear sapphire", 'add some essence of earth', 'add some essence of earth', 'add some essence of water', 'add some essence of water', 'add some glowing violet essence dust', 'infuse', 'refract sunlight through ruby lens', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 60, 62 ], # fixme
	},
	r = {
		:product => 'full mana potion',
		:steps   => [ 'light', 'add flask of clear water', "add s'ayanad crystal", "add s'ayanad crystal", "add s'ayanad crystal", "add t'ayanad crystal", 'add some faintly glimmering dust', 'add some faintly glimmering dust', 'add some faintly glimmering dust', 'add some faintly glimmering dust', 'simmer', 'add radiant crimson essence shard', 'infuse', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 62, 62 ],
	},
	r = {
		:product => 'vial of translucent dye base',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground murdroot', 'add some ground murdroot', 'add ayanad crystal', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 14 ],
	},
	r = {
		:product => 'black vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground alder bark', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 14 ],
	},
	r = {
		:product => 'purple vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed wood violet', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'indigo vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed wild lilac', 'add some ground woad leaves', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'brown vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some powdered walnuts', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'dark red vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed oxblood lily', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'light blue vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground woad leaves', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'dark blue vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed stalk of bluebells', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'light green vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground arctic moss', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'dark green vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground blackened moss', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 2, 12 ],
	},
	r = {
		:product => 'light red vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground lichen', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 3, 13 ],
	},
	r = {
		:product => 'orange vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed coppery rain lily', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 3, 13 ],
	},
	r = {
		:product => 'pink vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground orchil', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 3, 13 ],
	},
	r = {
		:product => 'cream white vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground longgrass', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 14 ],
	},
	r = {
		:product => 'lavender blue vial of dye',
		# fixme: cowrie shell?
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some powdered purple-cap cowrie', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 14 ],
	},
	r = {
		:product => 'pale yellow vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed yellow clover', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 14 ],
	},
	r = {
		:product => 'tan vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed onion skin', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 4, 14 ],
	},
	r = {
		:product => 'bright yellow vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed gorse', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 5, 15 ],
	},
	r = {
		:product => 'white vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some ground valerian', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 5, 15 ],
	},
	r = {
		:product => 'grey vial of dye',
		:steps   => [ 'light', 'add vial of translucent dye base', 'add some mashed alligator lily', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 7, 17 ],
	},
	r = {
		:product => 'vial of limpid dye base',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground murdroot', 'add some ground murdroot', 'add some powdered grey ambergris', 'boil', "add s'ayanad crystal", 'add crystalline globe', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'tangerine yellow vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed tiger lily', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'light ginger vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed red clover', 'add some ground ginger', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'raven black vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground trollfear mushroom', 'add some ground trollfear mushroom', 'add some ground alder bark', 'add some ground alder bark', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'goldenrod yellow vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed stalk of goldenrod', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'rosy pink vial of dye',
		# not yellow primrose
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed primrose', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'azure vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground valerian', 'add some ground valerian', 'add some ground woad leaves', 'add some ground woad leaves', 'simmer', 'add some powdered blue spinel', 'add some powdered blue spinel', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'cerulean blue vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed yellow clover', 'add some mashed yellow clover', 'add some ground woad leaves', 'add some ground woad leaves', 'simmer', 'add some powdered blue lapis lazuli', 'add some powdered blue lapis lazuli', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'cobalt blue vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground woad leaves', 'add some ground woad leaves', 'add some ground alder bark', 'add some ground alder bark', 'simmer', 'add some powdered blue lapis lazuli', 'add some powdered blue lapis lazuli', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'periwinkle blue vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground woad leaves', 'add some ground woad leaves', 'add some ground orchil', 'add some ground orchil', 'simmer', 'add some powdered red coral', 'add some powdered red coral', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'turquoise blue vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed stalk of bluebells', 'add some mashed stalk of bluebells', 'add some ground woad leaves', 'add some ground woad leaves', 'simmer', 'add some powdered turquoise stone', 'add some powdered turquoise stone', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'cranberry red vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed bright red cranberry', 'simmer', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'slate grey vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground valerian', 'add some ground valerian', 'add some ground alder bark', 'add some ground alder bark', 'add some ground alder bark', 'simmer', 'add some powdered white clam shell', 'add some powdered white clam shell', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'slate grey vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some ground valerian', 'add some ground valerian', 'add some ground alder bark', 'add some ground alder bark', 'add some ground alder bark', 'simmer', 'add some powdered white chalcedony', 'add some powdered white chalcedony', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'scarlet vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some mashed orange begonia', 'simmer', 'add some powdered ruby-lined nassa shell', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'tawny brown vial of dye',
		:steps   => [ 'light', 'add vial of limpid dye base', 'add some powdered walnuts', 'add some powdered walnuts', 'add some mashed onion skin', 'add some mashed onion skin', 'simmer', 'add ruff of raptor feathers', 'add ruff of raptor feathers', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'vial of clear dye base',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground murdroot', 'add some ground murdroot', 'add some ground murdroot', 'add some ground murdroot', 'add some powdered grey ambergris', 'boil', "add t'ayanad crystal", "add t'ayanad crystal", 'add vial of farlook vitreous humor', 'infuse', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'saphire blue vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some ground blue moss', 'add some ground blue moss', 'simmer', 'add some powdered blue sapphire', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'silvery vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed moonlight cactus-bloom', 'add some mashed moonlight cactus-bloom', 'add some mashed moonlight cactus-bloom', 'simmer', 'add some powdered silver fang', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'emerald green vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some ground green fungus', 'add some ground green fungus', 'simmer', 'add some powdered uncut emerald', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'golden vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed flaeshorn berry', 'add some mashed flaeshorn berry', 'add some mashed flaeshorn berry', 'add some mashed flaeshorn berry', 'add some mashed flaeshorn berry', 'simmer', 'add pinch of gold dust', 'add pinch of gold dust', 'add pinch of gold dust', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'amethyst violet vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed purple poppy', 'add some mashed purple poppy', 'add some mashed purple poppy', 'add some mashed purple poppy', 'add some mashed purple poppy', 'simmer', 'add some powdered deep blue amethyst', 'add some powdered deep blue amethyst', 'add some powdered deep blue amethyst', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'olivine vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some ground shadowlace moss', 'add some ground shadowlace moss', 'add some ground shadowlace moss', 'simmer', 'add some powdered olivine feanor-bloom', 'add some powdered olivine feanor-bloom', 'add some powdered olivine feanor-bloom', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'coppery vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed coppery rain lily', 'add some mashed coppery rain lily', 'add some mashed coppery rain lily', 'add some mashed coppery rain lily', 'add some mashed coppery rain lily', 'simmer', 'add some powdered copper fang', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'rainbow vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed stargazer lily', 'add some mashed stargazer lily', 'add some mashed stargazer lily', 'simmer', 'add some powdered swirling aetherstone', 'add some powdered swirling aetherstone', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'ruby red vial of dye',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some mashed red passionflower', 'add some mashed red passionflower', 'add some mashed red passionflower', 'add some mashed red passionflower', 'add some mashed red passionflower', 'simmer', 'add some powdered uncut ruby', 'boil', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'brilliant dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground sponge mushroom', 'add some ground sponge mushroom', 'add some ground sponge mushroom', 'simmer', 'add some powdered uncut star-of-Tamzyrr diamond', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'glimmering dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some fetid black slime', 'simmer', 'add some powdered uncut maernstrike diamond', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'glittering dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add mass of congealed slime', 'simmer', 'add some powdered blue diamond', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'glowing dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground green lichen', 'add some ground green lichen', 'add some ground green lichen', 'simmer', 'add some powdered uncut diamond', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'radiant dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground wyrm thorn', 'add some ground wyrm thorn', 'simmer', 'add some powdered clear glimaerstone', "add some powdered dragon's-tear diamond", 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'shimmering dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground petrified shadowstalk', 'add some ground petrified shadowstalk', 'simmer', 'add some powdered uncut diamond', 'add some powdered shimmertine shard', 'add some powdered shimmertine shard', 'add some powdered shimmertine shard', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'shining dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground bloodthorn stem', 'add some ground bloodthorn stem', 'simmer', 'add some powdered yellow hyacinth', 'add some powdered uncut maernstrike diamond', 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'sparkling dye additive',
		:steps   => [ 'light', 'add vial of clear dye base', 'add some powdered waxy grey caederine', 'boil', 'add some ground bone mushroom', 'add some ground bone mushroom', 'simmer', "add some powdered dragon's-tear diamond", 'channel', 'seal' ],
		:type    => 'alchemy',
	},
	r = {
		:product => 'vial of hair dye base',
		:steps   => [ 'light', 'add flask of pure oil', 'add some powdered black ambergris', "add s'ayanad crystal", 'add perfect myklian belly scale', 'add some murdroot essence', 'add some murdroot essence', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 26, 36 ],
	},
	r = {
		:product => 'temporary honey blonde hair dye',
		:steps   => [ 'light', 'add vial of hair dye base', 'add some mashed golden buttercup', 'add some powdered Kezmonian honey beryl', 'boil', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 26, 36 ],
	},
	r = {
		:product => 'temporary mossy green hair dye',
		:steps   => [ 'light', 'add vial of hair dye base', 'add some cave moss', 'add some cave moss', 'add witchwood twig', 'add some powdered malachite stone', 'add some powdered malachite stone', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 26, 36 ],
	},
	r = {
		:product => 'temporary plum-colored hair dye',
		:steps   => [ 'light', 'add vial of hair dye base', 'add some mashed juicy plum', 'add some mashed juicy plum', 'add some powdered violet sapphire', 'add black dreamstone', 'simmer', 'seal' ],
		:type    => 'alchemy',
		:rank    => [ 26, 36 ],
	},
	r = {
		:product => 'hazy silver potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground haphip', 'add some ground haphip', 'add some ground haphip', 'add some powdered grey ambergris', 'add some powdered grey ambergris', 'add some powdered grey ambergris', 'add glowing firefly', 'add glowing firefly', 'add glowing firefly', 'add glowing firefly', 'boil', 'add giant glowing toadstool', 'add giant glowing toadstool', 'add giant glowing toadstool', 'add Elanthian snow rose', 'add soft blue griffin feather', 'simmer', 'add some powdered rock crystal', 'add some essence of vitality', 'add some essence of vitality', 'add vial of faintly glowing aelotoi tears', 'seal' ],
		:type    => 'alchemy',
	},

	#
	# alchemic potions recipes
	#
	r = {
		:product => 'silvery potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'boil', 'add some powdered smoky topaz', 'simmer', 'chant 401', 'seal' ],
		:type    => 'potions',
		:spell   => '401',
		:rank    => [ 2, 13 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'shimmering pale green potion',
		:steps   => [ 'light', 'add flask of clear water', 'add sprig of larkspur', 'simmer', 'add glistening black eye', 'boil', 'add some powdered green sapphire', 'chant 402', 'seal' ],
		:type    => 'potions',
		:spell   => '402',
		:rank    => [ 5, 16 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'scintillating pale blue potion',
		:steps   => [ 'light', 'add flask of clear water', 'add blue trafel mushroom', 'boil', 'add some powdered blue lapis lazuli', 'simmer', 'add ayanad crystal', 'add ayanad crystal', 'add ayanad crystal', 'chant 403', 'seal' ],
		:type    => 'potions',
		:spell   => '403',
		:rank    => [ 8, 20 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'dark shimmering oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add some powdered black jasper', 'add ayanad crystal', 'add ayanad crystal', 'boil', 'add jagged translucent crystal', 'simmer', 'chant 902', 'seal' ],
		:type    => 'potions',
		:spell   => '902',
		:rank    => [ 9, 21 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'rohnuru potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground ayana', 'add some essence of water', 'chant 925', 'add some faintly glowing dust', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 10, 22 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'scintillating pale red potion',
		:steps   => [ 'light', 'add flask of clear water', 'add red trafel mushroom', 'boil', 'add some powdered brown sphene', 'simmer', 'add ayanad crystal', 'add ayanad crystal', 'add ayanad crystal', 'chant 404', 'seal' ],
		:type    => 'potions',
		:spell   => '404',
		:rank    => [ 11, 24 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'minor elemental focus potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered blue peridot', 'add some powdered blue peridot', 'add some powdered green peridot', 'boil', 'add some ground flathead mushroom', "add s'ayanad crystal", 'simmer', 'seal' ],
		:type    => 'potions',
		:rank    => [ 12, 22 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		# fixme: grind mother-of-pearl?
		:product => 'rainbow-hued potion',
		:steps   => [ 'light', 'add flask of clear water', 'add crimson dragonstalk', 'simmer', 'add iridescent piece of mother-of-pearl', 'add myklian scale', 'boil', 'chant 405', 'seal' ],
		:type    => 'potions',
		:spell   => '405',
		:rank    => [ 14, 28 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'rainbow-hued potion',
		:steps   => [ 'light', 'add flask of clear water', 'add crimson dragonstalk', 'simmer', 'add some powdered rainbow quartz', 'boil', 'chant 405', 'seal' ],
		:type    => 'potions',
		:spell   => '405',
		:rank    => [ 14, 28 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'bright silvery potion',
		:steps   => [ 'light', 'add flask of clear water', 'add silver mane', 'add some powdered silvery conch shell', 'simmer', 'chant 406', 'seal' ],
		:type    => 'potions',
		:spell   => '406',
		:rank    => [ 18, 31 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'bright silvery potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ursian tusk', 'add ursian tusk', 'add some powdered shimmertine shard', 'boil', 'chant 406', 'seal' ],
		:type    => 'potions',
		:spell   => '406',
		:rank    => [ 18, 31 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'sarmoc potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground ayana', 'add some essence of water', 'chant 925', 'add some faintly glimmering dust', 'boil', 'add some essence of fire', 'chant 417', 'seal' ],
		:type    => 'potions',
		:rank    => [ 18, 31 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'duqnuru potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground ayana', 'add some ground ayana', 'add some essence of water', 'add some essence of water', 'chant 925', 'add some faintly glowing dust', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 20, 33 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'softly glowing blue potion',
		:steps   => [ 'light', 'add flask of clear water', 'add blue trafel mushroom', 'add blue trafel mushroom', 'boil', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'add some powdered rhodochrosite stone', 'chant 407', 'seal' ],
		:type    => 'potions',
		:spell   => '407',
		:rank    => [ 21, 34 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'softly glowing red potion',
		:steps   => [ 'light', 'add flask of clear water', 'add red trafel mushroom', 'add red trafel mushroom', 'boil', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'add some powdered rhodochrosite stone', 'chant 408', 'seal' ],
		:type    => 'potions',
		:spell   => '408',
		:rank    => [ 23, 38 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'thick silver potion',
		:steps   => [ 'light', 'add flask of clear water', 'add silvery hoof', 'add some powdered star sapphire', 'boil', 'add sprig of foxglove', 'add sprig of foxglove', 'add sprig of foxglove', 'add sprig of foxglove', 'simmer', 'chant 506', 'seal' ],
		:type    => 'potions',
		:spell   => '506',
		:rank    => [ 23, 38 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'thick silver potion',
		:steps   => [ 'light', 'add flask of clear water', 'add viper fang', 'add some powdered black sphene', 'boil', 'add sprig of foxglove', 'add sprig of foxglove', 'add sprig of foxglove', 'add sprig of foxglove', 'simmer', 'chant 506', 'seal' ],
		:type    => 'potions',
		:spell   => '506',
		:rank    => [ 23, 38 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'prismatic potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered green sapphire', 'add ayanad crystal', 'boil', 'add troll fang', 'add troll fang', 'add shimmering prismatic shard', 'simmer', 'chant 905', 'seal' ],
		:type    => 'potions',
		:spell   => '905',
		:rank    => [ 24, 39 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'prismatic potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered fiery jacinth', 'add ayanad crystal', 'boil', 'add goat hoof', 'add goat hoof', 'add shimmering prismatic shard', 'simmer', 'chant 905', 'seal' ],
		:type    => 'potions',
		:spell   => '905',
		:rank    => [ 24, 39 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'pinkish-grey tonic',
		:nick    => 'lesser stamina potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered star ruby', 'add glimmering blue essence shard', 'add some essence of vitality', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 24, 34 ],
		:for     => [ 'Empath' ],
	},
	r = {
		:product => 'minor lockrot oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add some powdered golden amber', 'add some powdered golden amber', "add s'ayanad crystal", 'add some powdered charcoal', 'add some powdered charcoal', 'boil', 'add some essence of water', 'seal' ],
		:type    => 'potions',
		:rank    => [ 26, 36 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'shimmering silver potion',
		:steps   => [ 'light', 'add flask of clear water', 'add mountain lion skin', 'add some powdered silvery conch shell', 'simmer', 'chant 507', 'seal' ],
		:type    => 'potions',
		:spell   => '507',
		:rank    => [ 27, 41 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'dirtokh potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground ayana', 'add some ground ayana', 'add some ground ayana', 'add some essence of water', 'add some essence of water', 'add some essence of water', 'chant 925', 'add some faintly radiant dust', 'infuse', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 30, 40 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'some scintillating prismatic oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add fairy primrose', 'add fairy primrose', 'simmer', 'add elemental core', 'add elemental core', 'boil', 'add some powdered green starstone', 'infuse', 'chant 411', 'seal' ],
		:type    => 'potions',
		:spell   => '411',
		:rank    => [ 30, 46 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'some scintillating prismatic oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add fairy primrose', 'add fairy primrose', 'simmer', 'add elemental core', 'add elemental core', 'boil', 'add some powdered bright bluerock', 'infuse', 'chant 411', 'seal' ],
		:type    => 'potions',
		:spell   => '411',
		:rank    => [ 30, 46 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'gold-flecked clear potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered gold nugget', "add s'ayanad crystal", 'simmer', 'add vruul skin', 'boil', 'infuse', 'chant 508', 'seal' ],
		:type    => 'potions',
		:spell   => '508',
		:rank    => [ 31, 48 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'effervescent green potion',
		:nick   => 'lesser logic potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add ayana leaf', 'add green sapphire', 'add vial of farlook vitreous humor', 'infuse', 'add some faintly radiant dust', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 32, 47 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'blue bubbling potion',
		:nick    => 'lesser elemental focus potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered blue sapphire', 'boil', 'add some essence of water', 'infuse', 'add blue mist-shrouded crystal', 'simmer', 'seal' ],
		:type    => 'potions',
		:spell   => '112',
		:rank    => [ 36, 54 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'mirtokh potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some ground ayana', 'add some ground ayana', 'add some ground ayana', 'add some ground ayana', 'add some essence of water', 'add some essence of water', 'add some essence of water', 'add some essence of water', 'chant 925', 'add some faintly shimmering dust', 'infuse', 'add some powdered uncut diamond', 'boil', 'seal' ],
		:type    => 'potions',
		:rank    => [ 40, 50 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'brilliant silvery potion',
		:steps   => [ 'light', 'add flask of clear water', 'add vesperti claw', 'add vesperti claw', 'add vesperti claw', 'add some powdered golden topaz', 'boil', 'add shining silver crystal fragment', 'simmer', 'infuse', 'chant 414', 'seal' ],
		:type    => 'potions',
		:spell   => '414',
		:rank    => [ 41, 51 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'lesser lockrot oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add some powdered golden amber', 'add some powdered golden amber', "add s'ayanad crystal", 'add some powdered charcoal', 'add some powdered charcoal', 'boil', 'add dark glimmering crystal', 'infuse', 'add some essence of earth', 'seal' ],
		:type    => 'potions',
		:rank    => [ 44, 54 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'glowing brilliant silver potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add ayana leaf', 'simmer', 'add centaur hide', 'add centaur hide', 'add centaur hide', 'boil', 'add some powdered yellow sapphire', 'infuse', "add t'ayanad crystal", 'channel', 'chant 419', 'seal' ],
		:type    => 'potions',
		:spell   => '419',
		:rank    => [ 50, 62 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'dark murky potion',
		:steps   => [ 'light', 'add flask of clear water', 'add centaur hide', 'add some powdered violet sapphire', 'boil', "add s'ayanad crystal", 'simmer', 'add dark glimmering crystal', 'infuse', 'chant 911', 'seal' ],
		:type    => 'potions',
		:spell   => '911',
		:rank    => [ 54, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'vivid blue bubbling potion',
		:nick    => 'greater elemental focus potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered dragonseye sapphire', 'boil', 'add flask of sparkling body essence', 'infuse', 'add some powdered wild beechnut', 'add some powdered wild beechnut', 'simmer', 'seal' ],
		:type    => 'potions',
		:rank    => [ 58, 62 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'ayveneh potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add ayana leaf', 'add ayana leaf', 'add some essence of water', 'add some powdered black opal', 'add some powdered black opal', 'simmer', 'add some powdered uncut diamond', 'add some powdered uncut diamond', 'add some faintly radiant dust', 'add some faintly radiant dust', 'add some essence of water', 'boil', 'add some powdered dragonfire opal', 'add some powdered dragonfire opal', 'add some powdered moonglae opal', 'add some powdered moonglae opal', 'add some faintly shimmering dust', 'add some faintly shimmering dust', 'add some faintly shimmering dust', 'add some essence of water', 'infuse', 'chant 925', 'seal' ],
		:type    => 'potions',
		:spell   => '925',
		:rank    => [ 60, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'sparkling green potion',
		:nick    => 'greater logic potion',
		:steps   => [ 'light', 'add flask of clear water', 'add ayana leaf', 'add some ground tkaro', 'add some powdered emerald blazestar', 'add some powdered emerald blazestar', 'infuse', "add n'ayanad crystal", 'add flask of sparkling mind essence', 'refract moonlight through emerald lens', 'simmer', 'seal' ],
		:type    => 'potions',
		:rank    => [ 62, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		# fixme: unknown rank
		:product => 'eoveneh potion',
		:steps   => [ 'light', 'add flask of clear water', 'add some powdered uncut diamond', 'add some essence of water', 'simmer', 'add minor holy oil', 'add some faintly radiant dust', 'infuse', 'add radiant white soulstone', 'chant 925', 'seal' ],
		:type    => 'potions',
		:spell   => '925',
		:for     => [ 'Wizard' ],
	},
	r = {
		# fixme: unknown rank
		:product => 'greater lockrot oil',
		:steps   => [ 'light', 'add flask of pure oil', 'add some powdered golden amber', 'add some powdered golden amber', "add s'ayanad crystal", 'add some powdered charcoal', 'add some powdered charcoal', 'boil', 'add dark glimmering crystal', 'infuse', 'add some radiant crimson essence dust', 'refract moonlight through amethyst lens', 'seal' ],
		:type    => 'potions',
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'iron wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered turquoise stone', 'simmer', 'add pinch of iron dust', 'boil', 'chant 901', 'seal' ],
		:type    => 'trinkets',
		:spell   => '901',
		:rank    => [ 1, 15 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'pale glittering dust',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some powdered turquoise stone', 'simmer', 'add sprig of lavender', 'add sprig of lavender', 'boil', 'add ayanad crystal', 'chant 501', 'seal' ],
		:type    => 'trinkets',
		:spell   => '501',
		:rank    => [ 3, 14 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'minor elemental channeling crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered clear sapphire', 'add some powdered clear sapphire', 'add some powdered clear sapphire', 'add some essence of air', 'boil', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 7, 17 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'pale pink crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add pink topaz', 'add shelfae crest', 'add shelfae crest', 'boil', 'chant 502', 'seal' ],
		:type    => 'trinkets',
		:spell   => '502',
		:rank    => [ 7, 17 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'pale pink crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add pink topaz', 'add scraggly orc scalp', 'add scraggly orc scalp', 'simmer', 'chant 502', 'seal' ],
		:type    => 'trinkets',
		:spell   => '502',
		:rank    => [ 7, 17 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'pink burst firework',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some coarse glittering earth', 'add some powdered charcoal', 'simmer', 'add some powdered pink dreamstone', 'boil', 'chant 908', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 9, 19 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'blue burst firework',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some coarse glittering earth', 'add some powdered charcoal', 'simmer', 'add some mashed blue poppy', 'add some mashed blue poppy', 'add some powdered blue tourmaline', 'add some powdered blue tourmaline', 'boil', 'chant 908', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 9, 19 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'white burst firework',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some coarse glittering earth', 'add some powdered charcoal', 'simmer', 'add some powdered white jade', 'boil', 'chant 908', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 9, 19 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'clear rainbow-flecked crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered blue starstone', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'chant 503', 'seal' ],
		:type    => 'trinkets',
		:spell   => '503',
		:rank    => [ 11, 21 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'clear rainbow-flecked crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered azurite', 'add ayanad crystal', 'add ayanad crystal', 'boil', 'chant 503', 'seal' ],
		:type    => 'trinkets',
		:spell   => '503',
		:rank    => [ 11, 21 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'iridescent opal wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered white opal', 'boil', 'add pale blue runed crystal shard', 'simmer', 'chant 903', 'seal' ],
		:type    => 'trinkets',
		:spell   => '903',
		:rank    => [ 14, 27 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'some dull silvery dust',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some powdered violet sapphire', 'boil', "add s'ayanad crystal", 'simmer', 'chant 504', 'seal' ],
		:type    => 'trinkets',
		:spell   => '504',
		:rank    => [ 15, 27 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'spiraled sapphire wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add ayana leaf', 'add ayana leaf', 'simmer', 'add some powdered blue sapphire', 'boil', "add s'ayanad crystal", 'chant 505', 'seal' ],
		:type    => 'trinkets',
		:spell   => '505',
		:rank    => [ 19, 34 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'smooth crystalline wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered clear topaz', 'add shard of cloudy crystal', 'simmer', 'add ayanad crystal', 'add ayanad crystal', 'add ayanad crystal', 'boil', 'chant 904', 'seal' ],
		:type    => 'trinkets',
		:spell   => '904',
		:rank    => [ 19, 33 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'grooved witchwood wand',
		:steps   => [ 'light', 'add vial of amber-hued oil', 'add faeroth fang', 'add some powdered fiery jacinth', 'boil', 'add witchwood twig', 'add witchwood twig', 'add witchwood twig', 'simmer', 'chant 409', 'seal' ],
		:type    => 'trinkets',
		:spell   => '409',
		:rank    => [ 26, 42 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'grooved witchwood wand',
		:steps   => [ 'light', 'add vial of amber-hued oil', 'add fenghai fur', 'add fenghai fur', 'add some powdered fire pearl', 'boil', 'add witchwood twig', 'add witchwood twig', 'add witchwood twig', 'simmer', 'chant 409', 'seal' ],
		:type    => 'trinkets',
		:spell   => '409',
		:rank    => [ 26, 42 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},		
	r = {
		:product => 'golden wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered almandine garnet', 'add ayanad crystal', 'add ayanad crystal', 'add ayanad crystal', 'simmer', 'add pinch of gold dust', 'boil', 'chant 906', 'seal' ],
		:type    => 'trinkets',
		:spell   => '906',
		:rank    => [ 29, 45 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'dark translucent crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add wavepetal blossom', 'boil', 'add elemental core', 'simmer', 'add some powdered smoky topaz', 'add ayanad crystal', 'infuse', 'chant 410', 'seal' ],
		:type    => 'trinkets',
		:spell   => '410',
		:rank    => [ 30, 46 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'lesser elemental channeling crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered fire opal', 'add glowing violet mote of essence', 'infuse', 'simmer', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 30, 46 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'lesser aura crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add essence shard', 'add ayana leaf', 'simmer', 'add yellow sapphire', 'add some ground angelica', 'add some ground angelica', 'infuse', 'add some radiant crimson essence dust', 'boil', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 31, 41 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'silvery monogram rocket',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add some coarse glittering earth', 'add some powdered charcoal', 'boil', 'add some powdered black pearl', 'infuse', 'add glowing violet essence shard', 'chant 908', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 32, 42 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'slender azure rod',
		:steps   => [ 'light', 'add vial of amber-hued oil', 'add slender twig', 'add slender twig', 'add slender twig', 'boil', 'add some powdered blue coral', 'simmer', "add s'ayanad crystal", 'infuse', 'add runed azure crystal', 'chant 907', 'seal' ],
		:type    => 'trinkets',
		:spell   => '907',
		:rank    => [ 34, 44 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'wavy grey crystal wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add snowy cockatrice tailfeather', 'add snowy cockatrice tailfeather', 'add snowy cockatrice tailfeather', 'boil', 'add some ground ironfern', 'add some ground ironfern', 'add some ground ironfern', 'simmer', 'add some powdered star sapphire', 'infuse', 'chant 412', 'seal' ],
		:type    => 'trinkets',
		:spell   => '412',
		:rank    => [ 35, 51 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'white crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add ayana leaf', 'add ayana leaf', 'simmer', 'add some powdered star ruby', 'boil', "add s'ayanad crystal", 'infuse', 'chant 509', 'seal' ],
		:type    => 'trinkets',
		:spell   => '509',
		:rank    => [ 35, 52 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'shadowy dark crystal wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add yellowed boar tusk', 'add yellowed boar tusk', 'add yellowed boar tusk', 'boil', 'add some powdered green garnet', 'infuse', 'add dark shadow-shrouded crystal', 'simmer', 'chant 413', 'seal' ],
		:type    => 'trinkets',
		:spell   => '413',
		:rank    => [ 38, 56 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'some coarse black powder',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add handful of sea salt', 'add some powdered charcoal', 'add some powdered charcoal', 'add some essence of fire', 'add some essence of fire', 'simmer', 'chant 906', 'chant 908', 'boil', 'infuse', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 38, 48 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'shadowy dark crystal wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add fire cat claw', 'add fire cat claw', 'add fire cat claw', 'boil', 'add some powdered green garnet', 'infuse', 'add dark shadow-shrouded crystal', 'simmer', 'chant 413', 'seal' ],
		:type    => 'trinkets',
		:spell   => '413',
		:rank    => [ 38, 56 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'slender crimson rod',
		:steps   => [ 'light', 'add vial of amber-hued oil', 'add slender twig', 'add slender twig', 'add slender twig', 'boil', 'add some powdered citrine quartz', 'simmer', "add s'ayanad crystal", 'infuse', 'add runed crimson crystal', 'chant 908', 'seal' ],
		:type    => 'trinkets',
		:spell   => '908',
		:rank    => [ 39, 49 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'faceted topaz wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered smoky topaz', 'simmer', 'add bear hide', 'add bear hide', 'boil', 'add some coarse glittering earth', 'infuse', "add s'ayanad crystal", 'chant 510', 'seal' ],
		:type    => 'trinkets',
		:spell   => '511',
		:rank    => [ 39, 56 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'black crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered black jasper', 'simmer', 'add plains lion skin', 'add plains lion skin', 'boil', 'add some dark glittering powder', 'infuse', 'chant 511', 'seal' ],
		:type    => 'trinkets',
		:spell   => '511',
		:rank    => [ 43, 53 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'black crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered black jasper', 'simmer', "add roa'ter skin", "add roa'ter skin", 'boil', 'add some dark glittering powder', 'infuse', 'chant 511', 'seal' ],
		:type    => 'trinkets',
		:spell   => '511',
		:rank    => [ 43, 53 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'jagged brown crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add boar tusk', 'add boar tusk', 'add some powdered clear topaz', 'boil', 'add some coarse glittering earth', 'simmer', 'infuse', 'chant 909', 'seal' ],
		:type    => 'trinkets',
		:spell   => '909',
		:rank    => [ 44, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'translucent pale blue dust',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add myklian scale', 'add some powdered blue coral', 'boil', "add s'ayanad crystal", "add s'ayanad crystal", 'add blue mist-shrouded crystal', 'simmer', 'infuse', 'chant 512', 'seal' ],
		:type    => 'trinkets',
		:spell   => '512',
		:rank    => [ 47, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'translucent pale blue dust',
		:steps   => [ 'light', 'add vial of sand-like liquid', 'add tegu tailspike', 'add tegu tailspike', 'add tegu tailspike', 'add some powdered blue coral', 'boil', "add s'ayanad crystal", "add s'ayanad crystal", 'add blue mist-shrouded crystal', 'simmer', 'infuse', 'chant 512', 'seal' ],
		:type    => 'trinkets',
		:spell   => '512',
		:rank    => [ 47, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'slender mithril wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add shelfae crest', 'add shelfae crest', 'add shelfae crest', 'add shelfae crest', 'boil', 'add some powdered turquoise stone', 'simmer', "add s'ayanad crystal", 'infuse', 'add pinch of mithril dust', 'channel', 'chant 910', 'seal' ],
		:type    => 'trinkets',
		:spell   => '910',
		:rank    => [ 50, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'slender mithril wand',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add tufted hawk-owl ear', 'boil', 'add some powdered turquoise stone', 'simmer', "add s'ayanad crystal", 'infuse', 'add pinch of mithril dust', 'channel', 'chant 910', 'seal' ],
		:type    => 'trinkets',
		:spell   => '910',
		:rank    => [ 50, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'greater elemental channeling crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered maernstrike diamond', 'add some radiant crimson essence dust', 'channel', 'add essence shard', 'add sprig of columbine', 'infuse', 'boil', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 52, 62 ],
		:for     => [ 'Wizard', 'Sorcerer' ],
	},
	r = {
		:product => 'glass amulet',
		:steps   => [ 'light', 'add vial of pearlescent oil', 'add some powdered uncut diamond', 'add some faintly glowing dust', 'simmer', 'add some mashed large white gardenia', 'infuse', 'refract sunlight through sapphire lens', 'boil', 'chant 916', 'seal' ],
		:type    => 'trinkets',
		:spell   => '916',
		:rank    => [ 60, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'greater aura crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add ayana leaf', 'add some powdered yellow diamond', 'add some powdered yellow diamond', 'infuse', 'add essence shard', "add n'ayanad crystal", 'add flask of sparkling soul essence', 'refract sunlight through diamond lens', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 62, 62 ],
		:for     => [ 'Wizard' ],
	},
	r = {
		:product => 'greater spirit regeneration crystal',
		:steps   => [ 'light', 'add vial of viscous liquid', 'add some powdered yellow sapphire', 'add some powdered grey pearl', 'add some faintly shimmering dust', 'chant 308', 'infuse', 'add handful of pinenuts', 'add flask of sparkling soul essence', 'infuse', 'seal' ],
		:type    => 'trinkets',
		:rank    => [ 62, 62 ],
		:for     => [ 'Cleric' ],
	},


	r = {
		:product => 'flask of hazy grey liquid essence',
		:steps   => [ 'light', 'add flask of clear water', 'add tiny golden seed', 'infuse', 'add pink sapphire', 'add pink sapphire', 'infuse', 'boil', 'seal' ],
	},
	r = {
		:product => 'flask of hazy green liquid essence',
		:steps   => [ 'light', 'add flask of clear water', 'add tiny golden seed', 'channel', 'add uncut diamond', 'boil', 'seal' ],
	},
	r = {
		:product => 'flask of hazy brown liquid essence',
		:steps   => [ 'light', 'add flask of clear water', 'add tiny golden seed', 'simmer', 'add pine cone', 'add small wild rose', "add ayana'al leaf", 'add uncut emerald', 'boil', 'seal' ],
	},

	#
	# buy reagents
	#

	r = {
		:product => 'flask of clear water',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'flask of blessed water',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'flask of pure oil',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'flask of blessed oil',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'vial of viscous liquid',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100	,
	},
	r = {
		:product => 'vial of sand-like liquid',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'vial of pearlescent oil',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 100,
	},
	r = {
		:product => 'vial of amber-hued oil',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 250,
	},
	r = {
		:product => 'some coarse ivory dust',
		:steps   => [ "buy from empath alchemy shop" ],
		:for     => [ 'Empath' ],
		:cost    => 500,
	},
	r = {
		:product => 'shimmering shard',
		:steps   => [ "buy from empath alchemy shop" ],
		:for     => [ 'Empath' ],
		:cost    => 1250,
	},
	r = {
		:product => 'some fine alabaster dust',
		:steps   => [ "buy from empath alchemy shop" ],
		:for     => [ 'Empath' ],
		:cost    => 1750,
	},
	r = {
		:product => 'small enruned bone',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 800,
	},
	r = {
		:product => 'small ivory disc',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 800,
	},
	r = {
		:product => 'some glowing white powder',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 1000,
	},
	r = {
		:product => 'vial of shimmering oil',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 600,
	},
	r = {
		:product => 'some dark glittering powder',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 1500,
	},
	r = {
		:product => 'blue mist-shrouded crystal',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 800,
	},
	r = {
		:product => 'pinch of iron dust',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 300,
	},
	r = {
		:product => 'jagged translucent crystal',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 400,
	},
	r = {
		:product => 'pale blue runed crystal shard',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 250,
	},
	r = {
		:product => 'shard of cloudy crystal',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 400,
	},
	r = {
		:product => 'shimmering prismatic shard',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 250,
	},
	r = {
		:product => 'pinch of gold dust',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 600,
	},
	r = {
		:product => 'runed azure crystal',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 250,
	},
	r = {
		:product => 'runed crimson crystal',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 350,
	},
	r = {
		:product => 'some coarse glittering earth',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 500,
	},
	r = {
		:product => 'pinch of mithril dust',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 1000,
	},
	r = {
		:product => 'dark glimmering crystal',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 1000,
	},
	r = {
		:product => 'dark shadow-shrouded crystal',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 400,
	},
	r = {
		:product => 'shining silver crystal fragment',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1500,
	},
	r = {
		:product => 'jagged crimson crystal',
		:steps   => [ "buy from sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 150,
	},
	r = {
		:product => 'some pale translucent dust',
		:steps   => [ "buy from sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 375,
	},
	r = {
		:product => 'slender white bone',
		:steps   => [ "buy from sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'handful of quartz sand',
		:steps   => [ "buy from sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 450,
	},
	r = {
		:product => 'vial of concentrated firethorn essence',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 3000,
	},
	r = {
		:product => 'vial of viper venom',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 1100,
	},
	r = {
		:product => 'some powdered clear zircon',
		:steps   => [ "buy from empath alchemy shop" ],
		:for     => [ 'Empath' ],
		:cost    => 50,
	},
	r = {
		:product => 'some powdered rock crystal',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 20,
	},
	r = {
		:product => 'some powdered labradorite stone',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Cleric', 'Sorcerer' ],
		:cost    => 100,
	},
	r = {
		:product => 'some powdered black tourmaline',
		:steps   => [ "buy from sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 200,
	},
	r = {
		:product => 'some powdered green tourmaline',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 220,
	},
	r = {
		:product => 'some powdered clear tourmaline',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 180,
	},
	r = {
		:product => 'some powdered golden amber',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 300,
	},
	r = {
		:product => 'some powdered clear topaz',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 20,
	},
	r = {
		:product => 'some powdered almandine garnet',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 130,
	},
	r = {
		:product => 'some powdered black jasper',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 100,
	},
	r = {
		:product => 'some powdered rose quartz',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 160,
	},
	r = {
		:product => 'some powdered citrine quartz',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 160,
	},
	r = {
		:product => 'some powdered bright chrysoberyl gem',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 400,
	},
	r = {
		:product => 'some powdered beryl gem',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 480,
	},
	r = {
		:product => 'some powdered golden topaz',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 1200,
	},
	r = {
		:product => 'some powdered pink topaz',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered smoky topaz',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered blue lapis lazuli',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1200,
	},
	r = {
		:product => 'some powdered malachite stone',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered green garnet',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered rhodochrosite stone',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered pink coral',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 700,
	},
	r = {
		:product => 'some powdered white opal',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Wizard' ],
		:cost    => 1600,
	},
	r = {
		:product => 'some powdered star ruby',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered yellow sapphire',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 1800,
	},
	r = {
		:product => 'some powdered violet sapphire',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered star sapphire',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered green sapphire',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1800,
	},
	r = {
		:product => 'some powdered blue sapphire',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Wizard' ],
		:cost    => 6000,
	},
	r = {
		:product => 'some powdered fire agate',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 360,
	},
	r = {
		:product => 'some powdered fire agate',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 360,
	},
	r = {
		:product => 'some powdered water sapphire',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered water sapphire',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered spiderweb turquoise',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 1200,
	},
	r = {
		:product => 'some powdered spiderweb turquoise',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 1200,
	},
	r = {
		:product => 'some powdered spessartine garnet',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered spessartine garnet',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered imperial topaz',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 1600,
	},
	r = {
		:product => 'some powdered imperial topaz',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 1600,
	},
	r = {
		:product => 'some powdered green moonstone',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2200,
	},
	r = {
		:product => 'some powdered green moonstone',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2200,
	},
	r = {
		:product => 'some powdered blue moonstone',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2200,
	},
	r = {
		:product => 'some powdered blue moonstone',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2200,
	},
	r = {
		:product => 'some powdered smoky glimaerstone',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered smoky glimaerstone',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered shimmertine shard',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered shimmertine shard',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered rainbow quartz',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered rainbow quartz',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered fiery jacinth',
		:steps   => [ "buy from Ta'Illistim #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered fiery jacinth',
		:steps   => [ "buy from Ta'Vaalor #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered moonglae opal',
		:steps   => [ "buy from Ta'Illistim cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 5600,
	},
	r = {
		:product => 'some powdered moonglae opal',
		:steps   => [ "buy from Ta'Vaalor cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 5600,
	},
	r = {
		:product => 'some powdered blood red garnet',
		:steps   => [ "buy from Icemule #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered gold nugget',
		:steps   => [ "buy from Icemule wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered green jade',
		:steps   => [ "buy from Icemule #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 1600,
	},
	r = {
		:product => 'some powdered white jade',
		:steps   => [ "buy from Icemule cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 500,
	},
	r = {
		:product => 'some powdered brown jade',
		:steps   => [ "buy from Icemule sorcerer alchemy shop" ],
		:for     => [ 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered blue coral',
		:steps   => [ "buy from wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 60,
	},
	r = {
		:product => 'some powdered deep purple amethyst',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 440,
	},
	r = {
		:product => 'some powdered turquoise stone',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered grey pearl',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Cleric', 'Empath', 'Sorcerer' ],
		:cost    => 4000,
	},
	r = {
		:product => 'some powdered white pearl',
		:steps   => [ "buy from #{Char.prof.downcase} alchemy shop" ],
		:cost    => 5000,
	},
	r = {
		:product => 'some powdered red-green bloodstone',
		:steps   => [ "buy from empath alchemy shop" ],
		:for     => [ 'Empath' ],
		:cost    => 40,
	},
	r = {
		:product => 'some powdered aquamarine gem',
		:steps   => [ "buy from cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 700,
	},
	r = {
		:product => 'some powdered cowrie shell',
		:steps   => [ "buy from Solhaven #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 900,
	},
	r = {
		:product => 'some powdered cowrie shell',
		:steps   => [ "buy from River's Rest #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 900,
	},
	r = {
		:product => 'some powdered pearl nautilus shell',
		:steps   => [ "buy from Solhaven #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2600,
	},
	r = {
		:product => 'some powdered pearl nautilus shell',
		:steps   => [ "buy from River's Rest #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2600,
	},
	r = {
		:product => 'some powdered iridescent mother-of-pearl',
		:steps   => [ "buy from Solhaven #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered iridescent mother-of-pearl',
		:steps   => [ "buy from River's Rest #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered silvery conch shell',
		:steps   => [ "buy from Solhaven #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1800,
	},
	r = {
		:product => 'some powdered silvery conch shell',
		:steps   => [ "buy from River's Rest #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1800,
	},
	r = {
		:product => 'some powdered fire pearl',
		:steps   => [ "buy from Solhaven #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2600,
	},
	r = {
		:product => 'some powdered fire pearl',
		:steps   => [ "buy from River's Rest #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2600,
	},
	r = {
		:product => 'some powdered golden moonstone',
		:steps   => [ "buy from Kharam-Dzu #{Char.prof.downcase} alchemy shop" ],
		:cost    => 5000,
	},
	r = {
		:product => 'some powdered blue starstone',
		:steps   => [ "buy from Kharam-Dzu wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 200,
	},
	r = {
		:product => 'some powdered green starstone',
		:steps   => [ "buy from Kharam-Dzu #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2000,
	},
	r = {
		:product => 'some powdered cats-eye moonstone',
		:steps   => [ "buy from Kharam-Dzu #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric', 'Sorcerer' ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered dragonfire opal',
		:steps   => [ "buy from Kharam-Dzu cleric alchemy shop" ],
		:for     => [ 'Cleric' ],
		:cost    => 6000,
	},
	r = {
		:product => 'some powdered blue eostone',
		:steps   => [ "buy from Zul Logoth #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Empath', 'Cleric' ],
		:cost    => 2400,
	},
	r = {
		:product => 'some powdered azurite',
		:steps   => [ "buy from Zul Logoth wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 200,
	},
	r = {
		:product => 'some powdered green sphene',
		:steps   => [ "buy from Zul Logoth wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 800,
	},
	r = {
		:product => 'some powdered brown sphene',
		:steps   => [ "buy from Zul Logoth #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 1000,
	},
	r = {
		:product => 'some powdered black sphene',
		:steps   => [ "buy from Zul Logoth wizard alchemy shop" ],
		:for     => [ 'Wizard' ],
		:cost    => 1400,
	},
	r = {
		:product => 'some powdered bright bluerock',
		:steps   => [ "buy from Zul Logoth #{Char.prof.downcase} alchemy shop" ],
		:for     => [ 'Wizard', 'Sorcerer' ],
		:cost    => 2400,
	},
	r = {
		# fixme: get backroom access if needed?
		:product => 'smooth stone',
		:steps   => [ "buy from Wehnimer's Landing general store" ],
		:cost    => 200,
	},
	r = {
		:product => 'some acantha leaf',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 22, # 220 for 10 doses
	},
	r = {
		:product => 'some wolifrew lichen',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 28, # 110 for 4 doses
	},
	r = {
		:product => 'some torban leaf',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 55, # 165 for 3 doses
	},
	r = {
		:product => 'some woth flower',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 55, # 110 for 2 doses
	},
	r = {
		:product => 'some ambrominas leaf',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 28, # 110 for 4 doses
	},
	r = {
		:product => 'some pothinir grass',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 200, # 400 for 2 doses
	},
	r = {
		:product => 'some ephlox moss',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 69, # 275 for 4 doses
	},
	r = {
		:product => 'some cactacae spine',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 28, # 110 for 4 doses
	},
	r = {
		:product => 'some calamia fruit',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 138, # 275 for 2 doses
	},
	r = {
		:product => 'some aloeas stem',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 138, # 275 for 2 doses
	},
	r = {
		:product => 'some haphip root',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 55, # 220 for 4 doses
	},
	r = {
		:product => 'some basal moss',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 55, # 220 for 4 doses
	},
	r = {
		:product => 'some sovyn clove',
		:steps   => [ "buy from Wehnimer's Landing herbalist" ],
		:cost    => 880, # 880 for 1 dose
	},
	r = {
		:product => 'vial of faintly glowing aelotoi tears',
		:steps   => [ "buy from Icemule empath guild entrance" ],
		:cost    => 7000,
	},
	r = {
		:product => 'vial of faintly glowing aelotoi tears',
		:steps   => [ "buy from River's Rest empath something" ],
		:cost    => 7000,
	},

	#
	# grind reagents
	#
	r = { :product => 'some powdered clear zircon',               :steps => [ 'grind clear zircon' ]                        },
	r = { :product => 'some powdered rock crystal',               :steps => [ 'grind rock crystal' ]                        },
	r = { :product => 'some powdered labradorite stone',          :steps => [ 'grind iridescent labradorite stone' ]        },
	r = { :product => 'some powdered black tourmaline',           :steps => [ 'grind black tourmaline' ]                    },
	r = { :product => 'some powdered green tourmaline',           :steps => [ 'grind green tourmaline' ]                    },
	r = { :product => 'some powdered clear tourmaline',           :steps => [ 'grind clear tourmaline' ]                    },
	r = { :product => 'some powdered blue tourmaline',            :steps => [ 'grind blue tourmaline' ]                     },
	r = { :product => 'some powdered golden amber',               :steps => [ 'grind piece of golden amber' ]               },
	r = { :product => 'some powdered clear topaz',                :steps => [ 'grind clear topaz' ]                         },
	r = { :product => 'some powdered almandine garnet',           :steps => [ 'grind almandine garnet' ]                    },
	r = { :product => 'some powdered black jasper',               :steps => [ 'grind black jasper' ]                        },
	r = { :product => 'some powdered rose quartz',                :steps => [ 'grind rose quartz' ]                         },
	r = { :product => 'some powdered citrine quartz',             :steps => [ 'grind citrine quartz' ]                      },
	r = { :product => 'some powdered chrysoberyl gem',            :steps => [ 'grind bright chrysoberyl gem' ]              },
	r = { :product => 'some powdered beryl gem',                  :steps => [ 'grind golden beryl gem' ]                    },
	r = { :product => 'some powdered golden topaz',               :steps => [ 'grind golden topaz' ]                        },
	r = { :product => 'some powdered pink topaz',                 :steps => [ 'grind pink topaz' ]                          },
	r = { :product => 'some powdered smoky topaz',                :steps => [ 'grind smoky topaz' ]                         },
	r = { :product => 'some powdered blue lapis lazuli',          :steps => [ 'grind blue lapis lazuli' ]                   },
	r = { :product => 'some powdered malachite stone',            :steps => [ 'grind green malachite stone' ]               },
	r = { :product => 'some powdered green garnet',               :steps => [ 'grind green garnet' ]                        },
	r = { :product => 'some powdered rhodochrosite stone',        :steps => [ 'grind pink rhodochrosite stone' ]            },
	r = { :product => 'some powdered pink coral',                 :steps => [ 'grind polished pink coral' ]                 },
	r = { :product => 'some powdered red coral',                  :steps => [ 'grind polished red coral' ]                  },
	r = { :product => 'some powdered blue coral',                 :steps => [ 'grind polished blue coral' ]                 },
	r = { :product => 'some powdered white opal',                 :steps => [ 'grind white opal' ]                          },
	r = { :product => 'some powdered star ruby',                  :steps => [ 'grind star ruby' ]                           },
	r = { :product => 'some powdered yellow sapphire',            :steps => [ 'grind yellow sapphire' ]                     },
	r = { :product => 'some powdered violet sapphire',            :steps => [ 'grind violet sapphire' ]                     },
	r = { :product => 'some powdered star sapphire',              :steps => [ 'grind star sapphire' ]                       },
	r = { :product => 'some powdered green sapphire',             :steps => [ 'grind green sapphire' ]                      },
	r = { :product => 'some powdered blue sapphire',              :steps => [ 'grind blue sapphire' ]                       },
	r = { :product => 'some powdered fire agate',                 :steps => [ 'grind fire agate' ]                          },
	r = { :product => 'some powdered water sapphire',             :steps => [ 'grind pale water sapphire' ]                 },
	r = { :product => 'some powdered spiderweb turquoise',        :steps => [ 'grind spiderweb turquoise' ]                 },
	r = { :product => 'some powdered spessartine garnet',         :steps => [ 'grind orange spessartine garnet' ]           },
	r = { :product => 'some powdered imperial topaz',             :steps => [ 'grind orange imperial topaz' ]               },
	r = { :product => 'some powdered green moonstone',            :steps => [ 'grind pale green moonstone' ]                },
	r = { :product => 'some powdered blue moonstone',             :steps => [ 'grind pale blue moonstone' ]                 },
	r = { :product => 'some powdered smoky glimaerstone',         :steps => [ 'grind smoky glimaerstone' ]                  },
	r = { :product => 'some powdered shimmertine shard',          :steps => [ 'grind shimmertine shard' ]                   },
	r = { :product => 'some powdered rainbow quartz',             :steps => [ 'grind rainbow quartz' ]                      },
	r = { :product => 'some powdered fiery jacinth',              :steps => [ 'grind fiery jacinth' ]                       },
	r = { :product => 'some powdered moonglae opal',              :steps => [ 'grind moonglae opal' ]                       },
	r = { :product => 'some powdered blood red garnet',           :steps => [ 'grind blood red garnet' ]                    },
	r = { :product => 'some powdered gold nugget',                :steps => [ 'grind gold nugget' ]                         },
	r = { :product => 'some powdered green jade',                 :steps => [ 'grind green jade' ]                          },
	r = { :product => 'some powdered white jade',                 :steps => [ 'grind white jade' ]                          },
	r = { :product => 'some powdered brown jade',                 :steps => [ 'grind brown jade' ]                          },
	r = { :product => 'some powdered deep purple amethyst',       :steps => [ 'grind deep purple amethyst' ]                },
	r = { :product => 'some powdered turquoise stone',            :steps => [ 'grind turquoise stone' ]                     },
	r = { :product => 'some powdered grey pearl',                 :steps => [ 'grind grey pearl' ]                          },
	r = { :product => 'some powdered white pearl',                :steps => [ 'grind white pearl' ]                         },
	r = { :product => 'some powdered black pearl',                :steps => [ 'grind black pearl' ]                         },
	r = { :product => 'some powdered red-green bloodstone',       :steps => [ 'grind dark red-green bloodstone' ]           },
	r = { :product => 'some powdered aquamarine gem',             :steps => [ 'grind aquamarine gem' ]                      },
	r = { :product => 'some powdered cowrie shell',               :steps => [ 'grind snake-head cowrie shell' ]             },
	r = { :product => 'some powdered pearl nautilus shell',       :steps => [ 'grind pearl nautilus shell' ]                },
	r = { :product => 'some powdered iridescent mother-of-pearl', :steps => [ 'grind iridescent piece of mother-of-pearl' ] },
	r = { :product => 'some powdered silvery conch shell',        :steps => [ 'grind sparkling silvery conch shell' ]       },
	r = { :product => 'some powdered fire pearl',                 :steps => [ 'grind brilliant fire pearl' ]                },
	r = { :product => 'some powdered golden moonstone',           :steps => [ 'grind golden moonstone' ]                    },
	r = { :product => 'some powdered blue starstone',             :steps => [ 'grind blue starstone' ]                      },
	r = { :product => 'some powdered green starstone',            :steps => [ 'grind green starstone' ]                     },
	r = { :product => 'some powdered cats-eye moonstone',         :steps => [ 'grind cats-eye moonstone' ]                  },
	r = { :product => 'some powdered dragonfire opal',            :steps => [ 'grind dragonfire opal' ]                     },
	r = { :product => 'some powdered blue eostone',               :steps => [ 'grind blue eostone' ]                        },
	r = { :product => 'some powdered azurite',                    :steps => [ 'grind azurite' ]                             },
	r = { :product => 'some powdered green sphene',               :steps => [ 'grind green sphene' ]                        },
	r = { :product => 'some powdered brown sphene',               :steps => [ 'grind brown sphene' ]                        },
	r = { :product => 'some powdered black sphene',               :steps => [ 'grind black sphene' ]                        },
	r = { :product => 'some powdered bright bluerock',            :steps => [ 'grind bright bluerock' ]                     },
	r = { :product => 'some powdered black opal',                 :steps => [ 'grind black opal' ]                          },
	r = { :product => 'some powdered fire opal',                  :steps => [ 'grind fire opal' ]                           },
	r = { :product => 'some powdered clear sapphire',             :steps => [ 'grind clear sapphire' ]                      },
	r = { :product => 'some powdered pink pearl',                 :steps => [ 'grind pink pearl' ]                          },
	r = { :product => 'some powdered emerald blazestar',          :steps => [ 'grind emerald blazestar' ]                   },
	r = { :product => 'some powdered maernstrike diamond',        :steps => [ 'grind maernstrike diamond' ]                 },
	r = { :product => 'some powdered uncut ruby',                 :steps => [ 'grind uncut ruby' ]                          },
	r = { :product => 'some powdered white starstone',            :steps => [ 'grind white starstone' ]                     },
	r = { :product => 'some powdered cloud agate',                :steps => [ 'grind cloud agate' ]                         },
	r = { :product => 'some powdered grey chalcedony',            :steps => [ 'grind grey chalcedony' ]                     },
	r = { :product => 'some powdered white chalcedony',           :steps => [ 'grind white chalcedony' ]                    },
	r = { :product => 'some powdered shimmarglin sapphire',       :steps => [ 'grind shimmarglin sapphire' ]                },
	r = { :product => 'some powdered dragonseye sapphire',        :steps => [ 'grind dragonseye sapphire' ]                 },
	r = { :product => 'some powdered white marble',               :steps => [ 'grind white marble' ]                        },
	r = { :product => 'some powdered Kezmonian honey beryl',      :steps => [ 'grind Kezmonian honey beryl' ]               },
	r = { :product => 'some powdered glossy black doomstone',     :steps => [ 'grind glossy black doomstone' ]              },
#	r = { :product => 'some powdered uncut diamond',              :steps => [ 'grind uncut diamond' ]                       },
	r = { :product => 'some powdered water chestnut',             :steps => [ 'grind water chestnut' ]                      },
	r = { :product => 'some powdered white sunstone',             :steps => [ 'grind white sunstone' ]                      },
	r = { :product => 'some powdered pinenuts',                   :steps => [ 'grind handful of pinenuts' ]                 },
	r = { :product => 'some powdered skeleton bone',              :steps => [ 'grind skeleton bone' ]                       },
	r = { :product => 'some powdered skeletal giant bone',        :steps => [ 'grind skeletal giant bone' ]                 },
	r = { :product => 'some powdered wraith talon',               :steps => [ 'grind wraith talon' ]                        },
	r = { :product => 'some powdered walnuts',                    :steps => [ 'grind handful of walnuts' ]                  },
	r = { :product => 'some powdered grey ambergris',             :steps => [ 'grind lump of grey ambergris' ]              },
	r = { :product => 'some powdered aster opal',                 :steps => [ 'grind aster opal' ]                          },
	r = { :product => 'some powdered white clam shell',           :steps => [ 'grind white clam shell' ]                    },
	r = { :product => 'some powdered ruby-lined nassa shell',     :steps => [ 'grind ruby-lined nassa shell' ]              },
	r = { :product => 'some powdered sea urchin shell',           :steps => [ 'grind sea urchin shell' ]                    },
	r = { :product => 'some powdered crystal crab shell',         :steps => [ 'grind faceted crystal crab shell' ]          },
	r = { :product => 'some powdered copper fang',                :steps => [ 'grind copper fang' ]                         },
	r = { :product => 'some powdered wild beechnut',              :steps => [ 'grind wild beechnut' ]                       },
	r = { :product => 'some powdered charcoal',                   :steps => [ 'grind few lumps of charcoal' ]               },
	r = { :product => 'some powdered silver fang',                :steps => [ 'grind silver fang' ]                         },
	r = { :product => 'some powdered pink dreamstone',            :steps => [ 'grind pink dreamstone' ]                     },
	r = { :product => 'some powdered blue peridot',               :steps => [ 'grind blue peridot' ]                        },
	r = { :product => 'some powdered green peridot',              :steps => [ 'grind green peridot' ]                       },
	r = { :product => 'some powdered blue spinel',                :steps => [ 'grind blue spinel' ]                         },
	r = { :product => 'some ground ironfern',                     :steps => [ 'grind ironfern root' ]                       },
	r = { :product => 'some ground wolifrew',                     :steps => [ 'grind some wolifrew lichen' ]                },
	r = { :product => 'some ground rose-marrow',                  :steps => [ 'grind rose-marrow root' ]                    },
	r = { :product => 'some ground valerian',                     :steps => [ 'grind some valerian root' ]                  },
	r = { :product => 'some ground cuctucae',                     :steps => [ 'grind cuctucae berry' ]                      },
	r = { :product => 'some ground murdroot',                     :steps => [ 'grind murdroot' ]                            },
	r = { :product => 'some ground sweetfern stalk',              :steps => [ 'grind sweetfern stalk' ]                     },
	r = { :product => 'some ground basal moss',                   :steps => [ 'grind some basal moss' ]                     },
	r = { :product => 'some ground glowing toadstool',            :steps => [ 'grind giant glowing toadstool' ]             },
	r = { :product => 'some ground ephlox moss',                  :steps => [ 'grind some ephlox moss' ]                    },
	r = { :product => 'some ground bolmara',                      :steps => [ 'grind some bolmara lichen' ]                 },
	r = { :product => 'some ground cactacae',                     :steps => [ 'grind some cactacae spine' ]                 },
	r = { :product => 'some ground haphip',                       :steps => [ 'grind some haphip root' ]                    },
	r = { :product => 'some ground talneo',                       :steps => [ 'grind some talneo root' ]                    },
	r = { :product => 'some ground tkaro',                        :steps => [ 'grind tkaro root' ]                          },
	r = { :product => 'some ground wingstem',                     :steps => [ 'grind some wingstem root' ]                  },
	r = { :product => 'some ground sovyn',                        :steps => [ 'grind some sovyn clove' ]                    },
	r = { :product => 'some ground bur-clover',                   :steps => [ 'grind some bur-clover root' ]                },
	r = { :product => 'some ground marallis',                     :steps => [ 'grind marallis berry' ]                      },
	r = { :product => 'some ground ayana',                        :steps => [ 'grind ayana leaf' ]                          },
	r = { :product => 'some ground cothinar',                     :steps => [ 'grind some cothinar flower' ]                },
	r = { :product => 'some ground oats',                         :steps => [ 'grind handful of oats' ]                     },
	r = { :product => 'some ground alder bark',                   :steps => [ 'grind some alder bark' ]                     },
	r = { :product => 'some ground orchil',                       :steps => [ 'grind some orchil lichen' ]                  },
	r = { :product => 'some ground blackened moss',               :steps => [ 'grind some blackened moss' ]                 },
	r = { :product => 'some ground lichen',                       :steps => [ 'grind some red lichen' ]                     },
	r = { :product => 'some ground longgrass',                    :steps => [ 'grind some longgrass' ]                      },
	r = { :product => 'some ground arctic moss',                  :steps => [ 'grind some arctic moss' ]                    },
	r = { :product => 'some ground woad leaves',                  :steps => [ 'grind cluster of woad leaves' ]              },
	r = { :product => 'some ground ginger',                       :steps => [ 'grind ginger root' ]                         },
	r = { :product => 'some ground blue moss',                    :steps => [ 'grind some blue moss' ]                      },
	r = { :product => 'some ground green fungus',                 :steps => [ 'grind luminescent green fungus' ]            },
	r = { :product => 'some ground shadowlace moss',              :steps => [ 'grind some shadowlace moss' ]                },
	r = { :product => 'some ground wyrm thorn',                   :steps => [ 'grind black-tipped wyrm thorn' ]             },
	r = { :product => 'some ground petrified shadowstalk',        :steps => [ 'grind some petrified shadowstalk' ]          },
	r = { :product => 'some ground bloodthorn stem',              :steps => [ 'grind bloodthorn stem' ]                     },
	r = { :product => 'some ground flathead mushroom',            :steps => [ 'grind flathead mushroom' ]                   },
	r = { :product => 'some ground angelica',                     :steps => [ 'grind some angelica root' ]                  },
	r = { :product => 'some ground strigae cactus',               :steps => [ 'grind some strigae cactus' ]                 },
	r = { :product => 'some ground red trafel mushroom',          :steps => [ 'grind red trafel mushroom' ]                 },
	r = { :product => 'some ground acantha',                      :steps => [ 'grind some acantha leaf' ]                   },
	r = { :product => 'some ground ambrominas',                   :steps => [ 'grind some ambrominas leaf' ]                },
	r = { :product => 'some ground aloeas stem',                  :steps => [ 'grind some aloeas stem' ]                    },
	r = { :product => 'some ground torban',                       :steps => [ 'grind some torban leaf' ]                    },
	r = { :product => 'some ground pothinir',                     :steps => [ 'grind some pothinir grass' ]                 },
	r = { :product => 'some mashed pale yellow daffodil',         :steps => [ 'grind pale yellow daffodil' ]                },
	r = { :product => 'some mashed pink rain lily',               :steps => [ 'grind pink rain lily' ]                      },
	r = { :product => 'some mashed nightshade berry',             :steps => [ 'grind nightshade berry' ]                    },
	r = { :product => 'some mashed large white gardenia',         :steps => [ 'grind large white gardenia' ]                },
	r = { :product => 'some mashed red poppy',                    :steps => [ 'grind red poppy' ]                           },
	r = { :product => 'some mashed mournbloom',                   :steps => [ 'grind sprig of mournbloom' ]                 },
	r = { :product => 'some mashed stalk of bluebells',           :steps => [ 'grind stalk of bluebells' ]                  },
	r = { :product => 'some mashed coppery rain lily',            :steps => [ 'grind coppery rain lily' ]                   },
	r = { :product => 'some mashed oxblood lily',                 :steps => [ 'grind oxblood lily' ]                        },
	r = { :product => 'some mashed yellow clover',                :steps => [ 'grind yellow clover blossom' ]               },
	r = { :product => 'some mashed onion skin',                   :steps => [ 'grind layer of onion skin' ]                 },
	r = { :product => 'some mashed gorse',                        :steps => [ 'grind cluster of gorse' ]                    },
	r = { :product => 'some mashed bright red cranberry',         :steps => [ 'grind bright red cranberry' ]                },
	r = { :product => 'some mashed orange begonia',               :steps => [ 'grind orange begonia' ]                      },
	r = { :product => 'some mashed wild lilac',                   :steps => [ 'grind sprig of wild lilac' ]                 },
	r = { :product => 'some mashed tiger lily',                   :steps => [ 'grind orange tiger lily' ]                   },
	r = { :product => 'some mashed red clover',                   :steps => [ 'grind red clover blossom' ]                  },
	r = { :product => 'some mashed stalk of goldenrod',           :steps => [ 'grind stalk of goldenrod' ]                  },
	r = { :product => 'some mashed golden buttercup',             :steps => [ 'grind golden buttercup' ]                    },
	r = { :product => 'some mashed red passionflower',            :steps => [ 'grind red passionflower' ]                   },
	r = { :product => 'some mashed blue passionflower',           :steps => [ 'grind blue passionflower' ]                  },

	#
	# extract reagents
	#
	r = { :product => 'handful of sea salt',          :steps => [ 'special' ]                    },
	r = { :product => 'some crystal core essence',    :steps => [ 'extract crystal core' ]       },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll hide' ]         },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll beard' ]        },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll skin' ]         },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll scalp' ]        },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract ice troll scalp' ]    },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract pale troll tongue' ]  },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll scalp' ]        },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract chipped troll tusk' ] },
	r = { :product => 'some essence of regeneration', :steps => [ 'extract troll heart' ]        },
	r = { :product => 'some essence of vitality',     :steps => [ 'extract yabathilium fruit' ]  },
	r = { :product => 'some faintly glimmering dust', :steps => [ 'extract ayanad crystal' ]     },
	r = { :product => 'some faintly glowing dust',    :steps => [ "extract s'ayanad crystal" ]   },
	r = { :product => 'some faintly radiant dust',	  :steps => [ "extract t'ayanad crystal" ]   },
	r = { :product => 'some faintly shimmering dust', :steps => [ "extract n'ayanad crystal" ]   },
	r = { :product => 'some murdroot essence',        :steps => [ 'extract murdroot' ]           },
	r = { :product => 'few lumps of charcoal',        :steps => [ 'extract stick' ]              },
	r = { :product => 'some faint mote of soul',      :steps => [ 'extract inky necrotic core' ], :for => [ 'Cleric' ] },

	#
	# distill for reagants
	#
	r = { :product => 'flask of sparkling mind essence', :steps => [ 'distill flask of hazy grey liquid essence' ],  },
	r = { :product => 'flask of sparkling body essence', :steps => [ 'distill flask of hazy brown liquid essence' ], },
	r = { :product => 'flask of sparkling soul essence', :steps => [ 'distill flask of hazy green liquid essence' ], },

	#
	# forage for reagants
	#
	r = { :product => 'some acantha leaf',        :steps => [ 'forage' ] },
	r = { :product => 'rose-marrow root',         :steps => [ 'forage' ] },
	r = { :product => 'some ambrominas leaf',     :steps => [ 'forage' ] },
	r = { :product => 'some cactacae spine',      :steps => [ 'forage' ] },
	r = { :product => 'some aloeas stem',         :steps => [ 'forage' ] },
	r = { :product => 'some haphip root',         :steps => [ 'forage' ] },
	r = { :product => 'some pothinir grass',      :steps => [ 'forage' ] },
	r = { :product => 'some basal moss',          :steps => [ 'forage' ] },
	r = { :product => 'some ephlox moss',         :steps => [ 'forage' ] },
	r = { :product => 'some calamia fruit',       :steps => [ 'forage' ] },
	r = { :product => 'some sovyn clove',         :steps => [ 'forage' ] },
	r = { :product => 'some wolifrew lichen',     :steps => [ 'forage' ] },
	r = { :product => 'some woth flower',         :steps => [ 'forage' ] },
	r = { :product => 'some torban leaf',         :steps => [ 'forage' ] },
	r = { :product => 'ayana leaf',               :steps => [ 'forage' ] },
	r = { :product => 'tkaro root',               :steps => [ 'forage' ] },
	r = { :product => 'pepperthorn root',         :steps => [ 'forage' ] },
	r = { :product => 'some talneo root',         :steps => [ 'forage' ] },
	r = { :product => 'luckbloom blossom',        :steps => [ 'forage' ] },
	r = { :product => 'wavepetal blossom',        :steps => [ 'forage' ] },
	r = { :product => 'red trafel mushroom',      :steps => [ 'forage' ] },
	r = { :product => 'slender twig',             :steps => [ 'forage' ] },
	r = { :product => 'yabathilium fruit',        :steps => [ 'forage' ] },
	r = { :product => 'small daisy',              :steps => [ 'forage' ] },
	r = { :product => 'cuctucae berry',           :steps => [ 'forage' ] },
	r = { :product => 'some bolmara lichen',      :steps => [ 'forage' ] },
	r = { :product => 'some rose-marrow root',    :steps => [ 'forage' ] },
	r = { :product => 'nightshade berry',         :steps => [ 'forage' ] },
	r = { :product => 'sprig of larkspur',        :steps => [ 'forage' ] },
	r = { :product => 'some brostheras grass',    :steps => [ 'forage' ] },
	r = { :product => 'some wingstem root',       :steps => [ 'forage' ] },
	r = { :product => 'sprig of foxglove',        :steps => [ 'forage' ] },
	r = { :product => 'blue trafel mushroom',     :steps => [ 'forage' ] },
	r = { :product => 'sprig of lavender',        :steps => [ 'forage' ] },
	r = { :product => 'some cothinar flower',     :steps => [ 'forage' ] },
	r = { :product => 'marallis berry',           :steps => [ 'forage' ] },
	r = { :product => 'ironfern root',            :steps => [ 'forage' ] },
	r = { :product => 'some valerian root',       :steps => [ 'forage' ] },
	r = { :product => 'large white gardenia',     :steps => [ 'forage' ] },
	r = { :product => 'murdroot',                 :steps => [ 'forage' ] },
	r = { :product => 'glowing firefly',          :steps => [ 'forage' ] },
	r = { :product => 'giant glowing toadstool',  :steps => [ 'forage' ] },
	r = { :product => 'Elanthian snow rose',      :steps => [ 'forage' ] },
	r = { :product => 'crimson dragonstalk',      :steps => [ 'forage' ] },
	r = { :product => 'fairy primrose',           :steps => [ 'forage' ] },
	r = { :product => 'witchwood twig',           :steps => [ 'forage' ] },
	r = { :product => 'sprig of columbine',       :steps => [ 'forage' ] },
	r = { :product => 'handful of pinenuts',      :steps => [ 'forage' ] },
	r = { :product => 'some bur-clover root',     :steps => [ 'forage' ] },
	r = { :product => 'water chestnut',           :steps => [ 'forage' ] },
	r = { :product => 'handful of oats',          :steps => [ 'forage' ] },
	r = { :product => 'pale yellow daffodil',     :steps => [ 'forage' ] },
	r = { :product => 'pink rain lily',           :steps => [ 'forage' ] },
	r = { :product => 'stick',                    :steps => [ 'forage' ] },
	r = { :product => 'sprig of holly',           :steps => [ 'forage' ] },
	r = { :product => 'white hook mushroom',      :steps => [ 'forage' ] },
	r = { :product => 'blue poppy',               :steps => [ 'forage' ] },
	r = { :product => 'yellow passionflower',     :steps => [ 'forage' ] },
	r = { :product => 'sprig of wild lilac',      :steps => [ 'forage' ] },
	r = { :product => 'strand of seaweed',        :steps => [ 'forage' ] },
	r = { :product => 'some cave moss',           :steps => [ 'forage' ] },
	r = { :product => 'striped heart mushroom',   :steps => [ 'forage' ] },
	r = { :product => 'white clover blossom',     :steps => [ 'forage' ] },
	r = { :product => 'wood violet',              :steps => [ 'forage' ] },
	r = { :product => 'soft white mushroom',      :steps => [ 'forage' ] },
	r = { :product => 'bloodwood twig',           :steps => [ 'forage' ] },
	r = { :product => 'twisted twig',             :steps => [ 'forage' ] },
	r = { :product => 'some wheat grass',         :steps => [ 'forage' ] },
	r = { :product => 'yew twig',                 :steps => [ 'forage' ] },
	r = { :product => 'sunburst blossom',         :steps => [ 'forage' ] },
	r = { :product => 'nightbloom blossom',       :steps => [ 'forage' ] },
	r = { :product => 'willow twig',              :steps => [ 'forage' ] },
	r = { :product => 'genkew mushroom',          :steps => [ 'forage' ] },
	r = { :product => 'ebony twig',               :steps => [ 'forage' ] },
	r = { :product => 'stargazer lily',           :steps => [ 'forage' ] },
	r = { :product => 'fragrant white lily',      :steps => [ 'forage' ] },
	r = { :product => "ayana'al leaf",            :steps => [ 'forage' ] },
	r = { :product => 'oak twig',                 :steps => [ 'forage' ] },
	r = { :product => 'sweetfern stalk',          :steps => [ 'forage' ] },
	r = { :product => 'red poppy',                :steps => [ 'forage' ] },
	r = { :product => 'pine cone',                :steps => [ 'forage' ] },
	r = { :product => 'small wild rose',          :steps => [ 'forage' ] },
	r = { :product => 'some alder bark',          :steps => [ 'forage' ] },
	r = { :product => 'some orchil lichen',       :steps => [ 'forage' ] },
	r = { :product => 'stalk of bluebells',       :steps => [ 'forage' ] },
	r = { :product => 'some blackened moss',      :steps => [ 'forage' ] },
	r = { :product => 'coppery rain lily',        :steps => [ 'forage' ] },
	r = { :product => 'some longgrass',           :steps => [ 'forage' ] },
	r = { :product => 'oxblood lily',             :steps => [ 'forage' ] },
	r = { :product => 'sprig of mournbloom',      :steps => [ 'forage' ] },
	r = { :product => 'some red lichen',          :steps => [ 'forage' ] },
	r = { :product => 'handful of walnuts',       :steps => [ 'forage' ] },
	r = { :product => 'some arctic moss',         :steps => [ 'forage' ] },
	r = { :product => 'cluster of woad leaves',   :steps => [ 'forage' ] },
	r = { :product => 'yellow clover blossom',    :steps => [ 'forage' ] },
	r = { :product => 'layer of onion skin',      :steps => [ 'forage' ] },
	r = { :product => 'cluster of gorse',         :steps => [ 'forage' ] },
	r = { :product => 'bright red cranberry',     :steps => [ 'forage' ] },
	r = { :product => 'orange begonia',           :steps => [ 'forage' ] },
	r = { :product => 'wild beechnut',            :steps => [ 'forage' ] },
	r = { :product => 'pine cone',                :steps => [ 'forage' ] },
	r = { :product => 'pink hydrangea',           :steps => [ 'forage' ] },
	r = { :product => 'wild orchid',                :steps => [ 'forage' ] },
	r = { :product => 'wild pansy blossom',         :steps => [ 'forage' ] },
	r = { :product => 'small dandelion',            :steps => [ 'forage' ] },
	r = { :product => 'golden hook mushroom',       :steps => [ 'forage' ] },
	r = { :product => 'some fetid black slime',     :steps => [ 'forage' ] },
	r = { :product => 'mass of congealed slime',    :steps => [ 'forage' ] },
	r = { :product => 'orange tiger lily',          :steps => [ 'forage' ] },
	r = { :product => 'red clover blossom',         :steps => [ 'forage' ] },
	r = { :product => 'ginger root',                :steps => [ 'forage' ] },
	r = { :product => 'stalk of goldenrod',         :steps => [ 'forage' ] },
	r = { :product => 'some blue moss',             :steps => [ 'forage' ] },
	r = { :product => 'luminescent green fungus',   :steps => [ 'forage' ] },
	r = { :product => 'some shadowlace moss',       :steps => [ 'forage' ] },
	r = { :product => 'red passionflower',          :steps => [ 'forage' ] },
	r = { :product => 'black-tipped wyrm thorn',    :steps => [ 'forage' ] },
	r = { :product => 'some petrified shadowstalk', :steps => [ 'forage' ] },
	r = { :product => 'bloodthorn stem',            :steps => [ 'forage' ] },
	r = { :product => 'golden buttercup',           :steps => [ 'forage' ] },
	r = { :product => 'flathead mushroom',          :steps => [ 'forage' ] },
	r = { :product => 'blue passionflower',         :steps => [ 'forage' ] },
	r = { :product => 'some angelica root',         :steps => [ 'forage' ] },
	r = { :product => 'some strigae cactus',        :steps => [ 'forage' ] },
	r = { :product => 'red trafel mushroom',        :steps => [ 'forage' ] },
# fixme: can only forage in moonlight?
#	r = { :product => 'trollfear mushroom',       :steps => [ 'forage' ] },
#	r = { :product => 'moonlight cactus-bloom',   :steps => [ 'forage' ] },

	#
	# kill for reagents
	#
	r = { :product => "pristine nymph's hair",        :steps => [ 'kill sea nymph' ],           },
	r = { :product => 'skeletal giant bone',          :steps => [ 'kill skeletal giant' ],      },
	r = { :product => 'giant skin',                   :steps => [ 'kill storm giant' ],         },
	r = { :product => 'cockatrice plume',             :steps => [ 'kill plumed cockatrice' ],   },
	r = { :product => 'wight skin',                   :steps => [ 'kill arch wight' ],          },
	r = { :product => 'ghoul nail',                   :steps => [ 'kill lesser ghoul' ],        },
	r = { :product => 'red bear paw',                 :steps => [ 'kill red bear' ],            },
	r = { :product => 'wraith talon',                 :steps => [ 'kill wraith' ],              },
	r = { :product => 'ghoul finger',                 :steps => [ 'kill ghoul master' ],        },
	r = { :product => 'mist wraith eye',              :steps => [ 'kill mist wraith' ],         },
	r = { :product => 'wight skull',                  :steps => [ 'kill lesser moor wight' ],   },
	r = { :product => 'wight mane',                   :steps => [ 'kill greater moor wight' ],  },
	r = { :product => 'kappa fin',                    :steps => [ 'kill greater kappa' ],       },
	r = { :product => 'bear hide',                    :steps => [ 'kill black bear' ],          },
	r = { :product => 'troll heart',                  :steps => [ 'kill war troll' ],           },
	r = { :product => 'ogre tooth',                   :steps => [ 'kill fire ogre' ],           },
	r = { :product => 'stone-grey lizard tail',       :steps => [ 'kill cave lizard' ],         },
	r = { :product => 'troll toe',                    :steps => [ 'kill mountain troll' ],      },
	r = { :product => 'cougar tail',                  :steps => [ 'kill cougar' ],              },
	r = { :product => 'tawny brindlecat hide',        :steps => [ 'kill tawny brindlecat' ],    },
	r = { :product => 'spotted leopard pelt',         :steps => [ 'kill mastodonic leopard' ],  },
	r = { :product => 'ogre nose',                    :steps => [ 'kill mountain ogre' ],       },
	r = { :product => 'cyclops eye',                  :steps => [ 'kill cyclops' ],             },
	r = { :product => 'mottled faeroth crest',        :steps => [ 'kill lesser faeroth' ],      },
	r = { :product => 'ghoul scraping',               :steps => [ 'kill greater ghoul' ],       },
	r = { :product => 'spider leg',                   :steps => [ 'kill greater spider' ],      },
	r = { :product => 'warcat whisker',               :steps => [ 'kill striped warcat' ],      },
	r = { :product => 'golem bone',                   :steps => [ 'kill bone golem' ],          },
	r = { :product => 'basilisk crest',               :steps => [ 'kill crested basilisk' ],    },
	r = { :product => 'scaly burgee shell',           :steps => [ 'kill scaly burgee' ],        },
	r = { :product => 'faintly glowing worm skin',    :steps => [ 'kill phosphorescent worm' ], },
	r = { :product => 'silvery tail',                 :steps => [ 'kill shadow steed' ],        },
	r = { :product => 'silver-tipped horseshoe',      :steps => [ 'kill shadow mare' ],         },
	r = { :product => 'fire cat claw',                :steps => [ 'kill fire cat' ],            },
	r = { :product => 'fire rat tail',                :steps => [ 'kill fire rat' ],            },
	r = { :product => 'centaur hide',                 :steps => [ 'kill bay centaur' ],         },
	r = { :product => 'centaur hide',                 :steps => [ 'kill white centaur' ],       },
	r = { :product => 'centaur hide',                 :steps => [ 'kill tan centaur' ],         },
	r = { :product => 'centaur hide',                 :steps => [ 'kill roan centaur' ],        },
	r = { :product => 'centaur hide',                 :steps => [ 'kill black centaur' ],       },
	r = { :product => 'snowy cockatrice tailfeather', :steps => [ 'kill snowy cockatrice' ],    },
	r = { :product => 'glistening black eye',         :steps => [ 'kill dark shambler' ],       },
	r = { :product => 'troll beard',                  :steps => [ 'kill hill troll' ],          },
	r = { :product => 'mountain lion skin',           :steps => [ 'kill mountain lion' ],       },
	r = { :product => 'shelfae crest',                :steps => [ 'kill shelfae chieftain' ],   },
	r = { :product => 'silvery hoof',                 :steps => [ 'kill night mare' ],          },
	r = { :product => 'vesperti claw',                :steps => [ 'kill vesperti' ],            },
	r = { :product => 'yellowed boar tusk',           :steps => [ 'kill ridgeback boar' ],      },
	r = { :product => 'vruul skin',                   :steps => [ 'kill lesser vruul' ],        },
	r = { :product => 'soft blue griffin feather',    :steps => [ 'kill storm griffin' ],       },
	r = { :product => 'myklian scale',                :steps => [ 'kill myklian' ],             },
	r = { :product => 'silver mane',                  :steps => [ 'kill nightmare steed' ],     },
	r = { :product => 'ursian tusk',                  :steps => [ 'kill tusked ursian' ],       },
	r = { :product => 'viper fang',                   :steps => [ 'kill black forest viper' ],  },
	r = { :product => 'tree viper fang',              :steps => [ 'kill tree viper' ],          },
	r = { :product => 'troll fang',                   :steps => [ 'kill troll cheiftain' ],     },
	r = { :product => 'goat hoof',                    :steps => [ 'kill mountain goat' ],       },
	r = { :product => 'scraggly orc scalp',           :steps => [ 'kill Neartofar orc' ],       },
	r = { :product => 'faeroth fang',                 :steps => [ 'kill greater faeroth' ],     },
	r = { :product => 'fenghai fur',                  :steps => [ 'kill fenghai' ],             },
	r = { :product => 'plains lion skin',             :steps => [ 'kill plains lion' ],         },
	r = { :product => "roa'ter skin",                 :steps => [ "kill roa'ter" ],             },
	r = { :product => 'boar tusk',                    :steps => [ 'kill great boar' ],          },
	r = { :product => 'tegu tailspike',               :steps => [ 'kill three-toed tegu' ],     },
	r = { :product => 'tufted hawk-owl ear',          :steps => [ 'kill giant hawk-owl' ],      },
	r = { :product => 'skeleton bone',                :steps => [ 'kill skeleton' ],            },
	r = { :product => 'troll hide',                   :steps => [ 'kill forest troll' ],        },
	r = { :product => 'ice troll scalp',              :steps => [ 'kill ice troll' ],           },
	r = { :product => 'kobold skin',                  :steps => [ 'kill kobold' ],              },
	r = { :product => 'pale troll tongue',            :steps => [ 'kill hunter troll' ],        }, # fixme
	r = { :product => "pristine sprite's hair",       :steps => [ 'kill fire sprite' ],         },
	r = { :product => 'some essence of fire',         :steps => [ 'kill fire sprite' ],         },
	r = { :product => 'some essence of fire',         :steps => [ 'kill fire cat' ],            },
	r = { :product => 'some essence of fire',         :steps => [ 'kill fire rat' ],            },
	r = { :product => 'elemental core',               :steps => [ 'kill fire cat' ],            },
	r = { :product => 'elemental core',               :steps => [ 'kill fire rat' ],            },
	r = { :product => 'orc knuckle',                  :steps => [ 'kill Neartofar orc' ],       },
	r = { :product => 'black leopard paw',            :steps => [ 'kill black leopard' ],       },
	r = { :product => 'kiramon tongue',               :steps => [ 'kill kiramon defender' ],    },
	r = { :product => 'ruff of raptor feathers',      :steps => [ 'kill drednought raptor' ],   },
	r = { :product => "mummy's shroud",               :steps => [ 'kill lesser mummy' ],        },
	r = { :product => 'mammoth arachnid mandible',    :steps => [ 'kill mammoth arachnid' ],    },

	#
	# blah
	#
	r = { :product => 'ayanad crystal',   :steps => [ 'separate cluster of ayanad crystals' ]   },
	r = { :product => "s'ayanad crystal", :steps => [ "separate cluster of s'ayanad crystals" ] },
	r = { :product => "t'ayanad crystal", :steps => [ "separate cluster of t'ayanad crystals" ] },

]

=begin
File.open("alchemy-recipes.xml", "w") { |f|
	f.puts "<alchemy>"
	f.puts "\t<general>"
	known_recipes.each { |recipe|
		if recipe[:type] == 'alchemy'
			output = "\t\t<recipe product=\"#{recipe[:product]}\""
			if recipe[:rank]
				output.concat " start_rank=\"#{recipe[:rank][0]}\" end_rank=\"#{recipe[:rank][1]}\""
			end
			if recipe[:spell]
				output.concat " spell=\"#{recipe[:spell]}\""
			end
			output.concat ">"
			f.puts output
			if recipe[:nick]
				f.puts "\t\t\t<nick>#{recipe[:nick]}</nick>"
			end
			if recipe[:for]
				recipe[:for].each { |profession|
					f.puts "\t\t\t<for>#{profession}</for>"
				}
			end
			f.puts "\t\t\t<steps>"
			recipe[:steps].each { |step|
				f.puts "\t\t\t\t<step>#{step}</step>"
			}
			f.puts "\t\t\t</steps>"
			f.puts "\t\t</recipe>"
		end
	}
	f.puts "\t</general>"
	f.puts "\t<potions>"
	known_recipes.each { |recipe|
		if recipe[:type] == 'potions'
			output = "\t\t<recipe product=\"#{recipe[:product]}\""
			if recipe[:rank]
				output.concat " start_rank=\"#{recipe[:rank][0]}\" end_rank=\"#{recipe[:rank][1]}\""
			end
			if recipe[:spell]
				output.concat " spell=\"#{recipe[:spell]}\""
			end
			output.concat ">"
			f.puts output
			if recipe[:nick]
				f.puts "\t\t\t<nick>#{recipe[:nick]}</nick>"
			end
			if recipe[:for]
				recipe[:for].each { |profession|
					f.puts "\t\t\t<for>#{profession}</for>"
				}
			end
			f.puts "\t\t\t<steps>"
			recipe[:steps].each { |step|
				f.puts "\t\t\t\t<step>#{step}</step>"
			}
			f.puts "\t\t\t</steps>"
			f.puts "\t\t</recipe>"
		end
	}
	f.puts "\t</potions>"
	f.puts "\t<trinkets>"
	known_recipes.each { |recipe|
		if recipe[:type] == 'trinkets'
			output = "\t\t<recipe product=\"#{recipe[:product]}\""
			if recipe[:rank]
				output.concat " start_rank=\"#{recipe[:rank][0]}\" end_rank=\"#{recipe[:rank][1]}\""
			end
			if recipe[:spell]
				output.concat " spell=\"#{recipe[:spell]}\""
			end
			output.concat ">"
			f.puts output
			if recipe[:nick]
				f.puts "\t\t\t<nick>#{recipe[:nick]}</nick>"
			end
			if recipe[:for]
				recipe[:for].each { |profession|
					f.puts "\t\t\t<for>#{profession}</for>"
				}
			end
			f.puts "\t\t\t<steps>"
			recipe[:steps].each { |step|
				f.puts "\t\t\t\t<step>#{step}</step>"
			}
			f.puts "\t\t\t</steps>"
			f.puts "\t\t</recipe>"
		end
	}
	f.puts "\t</trinkets>"
	f.puts "\t<other>"
	known_recipes.each { |recipe|
		if recipe[:type].nil?
			output = "\t\t<recipe product=\"#{recipe[:product]}\""
			if recipe[:rank]
				output.concat " start_rank=\"#{recipe[:rank][0]}\" end_rank=\"#{recipe[:rank][1]}\""
			end
			if recipe[:spell]
				output.concat " spell=\"#{recipe[:spell]}\""
			end
			output.concat ">"
			f.puts output
			if recipe[:nick]
				f.puts "\t\t\t<nick>#{recipe[:nick]}</nick>"
			end
			if recipe[:for]
				recipe[:for].each { |profession|
					f.puts "\t\t\t<for>#{profession}</for>"
				}
			end
			f.puts "\t\t\t<steps>"
			recipe[:steps].each { |step|
				f.puts "\t\t\t\t<step>#{step}</step>"
			}
			f.puts "\t\t\t</steps>"
			f.puts "\t\t</recipe>"
		end
	}
	f.puts "\t</other>"
	f.puts "</alchemy>"
}
exit
=end

elusive_reagent_cost = {
	'cluster of ayanad crystals'        =>   64,
	'ayanad crystal'                    =>  128,
	'crystal core'                      =>  128,
	'elemental core'                    =>  255,
	"cluster of s'ayanad crystals"      =>  255,
	'cracked soulstone'                 =>  300, # fixme
	"s'ayanad crystal"                  =>  510,
	'some essence of air'               =>  510,
	'some essence of earth'             =>  510,
	'some essence of fire'              =>  510,
	'some essence of water'             =>  510,
	"pristine nymph's hair"             =>  510,
	'small troll tooth'                 =>  638,
	'glimmering blue essence shard'     =>  638,
	'some glimmering blue essence dust' =>  765,
	'glimmering blue mote of essence'   =>  765,
	"cluster of t'ayanad crystals"      =>  892,
	'glowing violet essence shard'      => 1275,
	'crystalline globe'                 => 1530,
	"t'ayanad crystal"                  => 1785,
	"pristine sprite's hair"            => 1785,
	'glowing violet mote of essence'    => 2295,
	'some glowing violet essence dust'  => 2295,
	'perfect myklian belly scale'       => 2550,
	'large troll tooth'                 => 2550,
	'vial of farlook vitreous humor'    => 2550,
	'inky necrotic core'                => 2550,
	'tiny golden seed'                  => 2550,
	'radiant crimson essence shard'     => 3825,
	"pristine siren's hair"             => 4080,
	"n'ayanad crystal"                  => 5355,
	'some radiant crimson essence dust' => 6885,
	'radiant crimson mote of essence'   => 6885,
}

equivalent = [
	[ 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root' ],
	[ "ayana'al leaf", "ayana'al lichen", "ayana'al weed", "ayana'al berry", "ayana'al root" ],
	[ 'some ground ayana', 'some ground ayana leaf', 'some ground ayana lichen', 'some ground ayana weed', 'some ground ayana berry', 'some ground ayana root' ],
	[ 'myklian scale', 'orange myklian scale', 'red myklian scale', 'yellow myklian scale', 'green myklian scale' ],
	[ 'white pearl', 'large white pearl', 'medium white pearl', 'small white pearl', 'tiny white pearl' ],
	[ 'black pearl', 'large black pearl', 'medium black pearl', 'small black pearl', 'tiny black pearl' ],
	[ 'pink pearl', 'tiny pink pearl', 'small pink pearl', 'medium pink pearl', 'large pink pearl' ],
	[ 'stick', 'thick stick', 'stained stick', 'slender stick', 'pointed stick', 'twisted stick', 'long stick', 'slim stick', 'charred stick', 'flexible stick', 'sturdy stick', 'dark stick', 'hefty stick', 'cracked stick', 'thin stick', 'small stick', 'bent stick', 'short stick', 'heavy stick' ],
	[ 'vial of concentrated firethorn essence', 'vial concentrated firethorn essence' ],
	[ 'some powdered rhodochrosite stone', 'some powdered pink rhodochrosite stone' ],
	[ 'some powdered chrysoberyl gem', 'some powdered bright chrysoberyl gem' ],
	[ 'some powdered malachite stone', 'some powdered green malachite stone' ],
	[ 'some powdered spessartine garnet', 'some powdered orange spessartine garnet' ],
	[ 'some powdered pink coral', 'some powdered polished pink coral' ],
	[ 'some powdered blue coral', 'some powdered polished blue coral' ],
	[ 'some powdered red coral', 'some powdered polished red coral' ],
	[ 'some powdered water sapphire', 'some powdered pale water sapphire' ],
	[ 'some powdered fire pearl', 'some powdered billiant fire pearl' ],
	[ 'some powdered cowrie shell', 'some powdered snake-head cowrie shell' ],
	[ 'some powdered iridescent mother-of-pearl', 'some powdered iridescent piece of mother-of-pearl' ],
	[ 'some powdered silvery conch shell', 'some powdered sparkling silvery conch shell' ],
	[ 'some powdered imperial topaz', 'some powdered orange imperial topaz' ],
	[ 'some powdered green moonstone', 'some powdered pale green moonstone' ],
	[ 'some powdered pale blue moonstone', 'some powdered blue moonstone' ],
	[ 'some powdered beryl gem', 'some powdered golden beryl gem' ],
]

herb_doses = {
	'some acantha leaf' => 10,
	'some aloeas stem' => 2,
	'some haphip root' => 4,
	'some pothinir grass' => 2,
	'some basal moss' => 4,
	'some ephlox moss' => 4,
	'some ambrominas leaf' => 4,
	'some calamia fruit' => 2,
	'some cactacae spine' => 4,
	'some sovyn clove' => 1,
	'some wolifrew lichen' => 4,
	'some woth flower' => 2,
	'some torban leaf' => 3,
}

sea_water_flask = /^(?:small|faceted) crystal flask$|^dark sphene-inset flask$/
sea_water_vial  = /^(?:clouded|warped|chipped|tapered|smoky|thick|slender|clear|blackened) glass vial$|^polished glaes vial$/
bundled_herb    = /^some acantha leaf$|^some cactacae spine$|^some ambrominas leaf$|^some torban leaf$|^some wolifrew lichen$|^some sovyn clove$|^some ephlox moss$|^some pothinir grass$|^some haphip root$|^some calamia fruit$|^some aloeas stem$|^some basal moss$|^some woth flower$/

check_silvers = proc {
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("#{script.name}_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("#{script.name}_check_silvers", action)
	silence_me unless undo_silence = silence_me
	put 'info'
	silence_me if undo_silence
	wait_until { silvers }
	silvers
}

wander_room_order = Array.new
wander_room_list = Array.new
wander = proc {
	next_room_options = Room.current.wayto.keys & wander_room_list
	next_room = next_room_options.find_all { |r| not wander_room_order.include?(r) }
	if next_room.empty?
		next_room = wander_room_order.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	wander_room_order.delete(next_room)
	wander_room_order.push(next_room)
	way = Room.current.wayto[next_room]
	if way.class == String 
		move(way)
	else
		way.call
	end
}

gld_var = nil
gld = proc {
	if gld_var.nil?
		fix_type = { 'General Alchemy' => 'alchemy', 'Alchemic Potions' => 'potions', 'Alchemic Trinkets' => 'trinkets' }
		script.want_downstream = false
		script.want_downstream_xml = true
		gld_var = Hash.new
		type = nil
		if CharSettings['hide-gld-check']
			started = false
			action = proc { |server_string|
				if started
					if server_string =~ /<output/
						DownstreamHook.remove('hide_gld')
						server_string
					else
						nil
					end
				else
					if server_string =~ /^You are (?:a member|Guild Master)/
						started = true
						nil
					else
						server_string
					end
				end
			}
			DownstreamHook.add('hide_gld', action)
		end
		undo_silent = !script.silent
		script.silent = true
		dothistimeout 'gld', 10, /^You are (?:a member|Guild Master)/
		script.silent = false if undo_silent
		while (line = get) and (line !~ /<prompt/)
			if line =~ /^You have ([0-9]+|no) ranks? in the (General Alchemy|Alchemic Potions|Alchemic Trinkets) skill\.$/
				rank = $1
				type = fix_type[$2]
				gld_var[type] = Hash.new
				if rank =~ /^[0-9]+$/
					gld_var[type][:rank] = rank.to_i
				else
					gld_var[type][:rank] = 0
				end
			elsif line =~ /^You are a Master of (General Alchemy|Alchemic Potions|Alchemic Trinkets)\.$/
				type = fix_type[$1]
				gld_var[type] = Hash.new
				gld_var[type][:rank] = 63
			elsif line =~ /^The Training Administrator told you to (.*)\.$/
				gld_var[type][:task] = $1
			elsif line =~ /^You have earned enough training points for your next rank\./
				gld_var[type][:task] = 'promotion'
			elsif line =~ /^You are not currently training in this skill\.$|^You have not yet obtained your first task for this skill rank\.$|^You have not been assigned a current task for this skill\.$/
				gld_var[type][:task] = 'no task'
				gld_var[type][:reps] = 0
			elsif line == 'You have no repetitions remaining for this task.'
				gld_var[type][:reps] = 0
			elsif line =~ /^You have ([0-9]+) repetitions? remaining (?:for|to complete) this task\.$/
				gld_var[type][:reps] = $1.to_i
			end
		end
		script.want_downstream = true
		script.want_downstream_xml = false
	end
	gld_var
}

invalid_gld = proc {
	gld_var = nil
}

gld_suggestions = proc {
	gld.call
	if gld_var.values.any? { |hash| hash[:recipes].nil? }
		for type in gld_var.keys
			if gld_var[type][:task] =~ /(?:with your|that involve) (.*?)(?: ability| mana|ing spells|ing|ing mana|ing spirit)?$/
				required_step = $1
				if gld_var[type][:task] =~ /cauldron workshop/
					gld_var[type][:recipes] = known_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } and not recipe[:steps].any? { |step| step =~ /^refract/ } }.collect { |recipe| recipe[:product] }
				else
					gld_var[type][:recipes] = known_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } }.collect { |recipe| recipe[:product] }
				end
			elsif gld_var[type][:task] =~ /follow some tough recipes and create some items|visit a skilled master for a lesson/
				gld_var[type][:recipes] = known_recipes.find_all { |recipe| (recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max }.collect { |recipe| recipe[:product] }
			elsif gld_var[type][:task] == 'practice distilling for reagents'
				gld_var[type][:recipes] = known_recipes.find_all { |recipe| recipe[:product] == 'flask of pure water' }.collect { |recipe| recipe[:product] }
			elsif gld_var[type][:task] == 'practice extracting for reagents'
				gld_var[type][:recipes] = known_recipes.find_all { |recipe| recipe[:product] == 'handful of sea salt' }.collect { |recipe| recipe[:product] }
			else
				gld_var[type][:recipes] = Array.new
			end
			gld_var[type][:recipes] = gld_var[type][:recipes] | gld_var[type][:recipes]
		end
	end
	gld_var
}

alchemy_sack_var = nil
close_alchemy_sack_var = false
alchemy_sack = proc {
	if alchemy_sack_var.nil?
		if UserVars.alchemysack.nil? or UserVars.alchemysack.empty? 
			echo 'warning: alchemysack is not set (;set change alchemysack <container name>)'
			sleep 1
		else
			alchemy_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack).sub(' ', ' .*')}/i }
			if alchemy_sack_var.nil?
				echo "warning: failed to find your alchemysack (#{UserVars.alchemysack})"
				sleep 1
			else
				if alchemy_sack_var.contents.nil?
					open_result = dothistimeout "open ##{alchemy_sack_var.id}", 10, /You open|already open/
					close_alchemy_sack_var = true if open_result =~ /You open/
					if alchemy_sack_var.contents.nil?
						dothistimeout "look in ##{alchemy_sack_var.id}", 10, /In the .* you see/
						if alchemy_sack_var.contents.nil?
							echo "warning: failed to find the contents of your alchemysack (#{UserVars.alchemysack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	alchemy_sack_var
}

loot_sack_var = nil
close_loot_sack_var = false
loot_sack = proc {
	if loot_sack_var.nil?
		if UserVars.lootsack.nil? or UserVars.lootsack.empty? 
			echo 'warning: lootsack is not set (;set change lootsack <container name>)'
			sleep 1
		else
			loot_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack).sub(' ', ' .*')}/i }
			if loot_sack_var.nil?
				echo "warning: failed to find your lootsack (#{UserVars.lootsack})"
				sleep 1
			else
				if loot_sack_var.contents.nil?
					open_result = dothistimeout "open ##{loot_sack_var.id}", 10, /You open|already open/
					close_loot_sack_var = true if open_result =~ /You open/
					if loot_sack_var.contents.nil?
						dothistimeout "look in ##{loot_sack_var.id}", 10, /In the .* you see/
						if loot_sack_var.contents.nil?
							echo "warning: failed to find the contents of your lootsack (#{UserVars.lootsack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	loot_sack_var
}

herb_sack_var = nil
close_herb_sack_var = false
herb_sack = proc {
	if herb_sack_var.nil?
		if UserVars.herbsack.nil? or UserVars.herbsack.empty? 
			echo 'warning: herbsack is not set (;set change herbsack <container name>)'
			sleep 1
		else
			herb_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}/i }
			if herb_sack_var.nil?
				echo "warning: failed to find your herbsack (#{UserVars.herbsack})"
				sleep 1
			else
				if herb_sack_var.contents.nil?
					open_result = dothistimeout "open ##{herb_sack_var.id}", 10, /You open|already open/
					close_herb_sack_var = true if open_result =~ /You open/
					if herb_sack_var.contents.nil?
						dothistimeout "look in ##{herb_sack_var.id}", 10, /In the .* you see/
						if herb_sack_var.contents.nil?
							echo "warning: failed to find the contents of your herbsack (#{UserVars.herbsack})"
							sleep 1
						end
					end
				end
			end
		end
	end
	herb_sack_var
}

close_sacks = proc {
	if close_alchemy_sack_var
		fput "close ##{alchemy_sack_var.id}"
		close_alchemy_sack_var = false
	end
	if close_loot_sack_var
		fput "close ##{loot_sack_var.id}"
		close_loot_sack_var = false
	end
	if close_herb_sack_var
		fput "close ##{herb_sack_var.id}"
		close_herb_sack_var = false
	end
}

all_sack_contents = proc {
	(alchemy_sack.call.contents.to_a | loot_sack.call.contents.to_a | herb_sack.call.contents.to_a)
}

cauldron = nil
drop_cauldron = proc {
	error = false
	unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.find { |obj| obj.noun == 'cauldron' } or GameObj.loot.find { |obj| obj.noun =~ /^(?:cauldron|vat)$/ }
		unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ /^(?:cauldron|vat)$/ }
			echo 'error: missing cauldron'
			error = true
		end
		dothis "get ##{cauldron.id}", /^You remove|^You already have that/
		# Upon further reflection, you decide it would be best if you just used the already present training cauldron.
		dothis "drop ##{cauldron.id}", /^You drop/
		put 'drag cauldron'
	end
	!error
}

force_drop_cauldron = proc {
	error = false
	unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ /^(?:cauldron|vat)$/ }
		echo 'error: missing cauldron'
		error = true
	else
		dothis "get ##{cauldron.id}", /^You remove|^You already have that/
		# Upon further reflection, you decide it would be best if you just used the already present training cauldron.
		dothis "drop ##{cauldron.id}", /^You drop/
		put 'drag cauldron'
	end
	!error
}

get_cauldron = proc {
	if cauldron
		dothis "_drag ##{cauldron.id} ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		fput 'drag stop'
		cauldron = nil
	end
}

where_is_previous_var = nil
where_is_shortest_distances_var = nil
where_is = proc { |place|
	if where_is_previous_var.nil?
		if Room.current
			if home_room = Room.current.find_nearest_by_tag("#{Char.prof.downcase} alchemy administrator")
				home_room = Room[home_room]
				if (home_room == Room.current) or Map.estimate_time(Room.current.path_to(home_room)) <= CharSettings['max-travel-time']
					where_is_previous_var, where_is_shortest_distances_var = home_room.dijkstra
				else
					echo 'warning: nearest guild exceeds max travel time'
					where_is_previous_var = false
				end
			else
				echo 'warning: failed to find your guild'
				where_is_previous_var = false
			end
		else
			echo 'warning: your current room is not in the map database'
			where_is_previous_var = false
		end
	end
	if where_is_previous_var == false
		Array.new
	else
		results = Array.new
		Map.list.each { |room| results.push(room.id) if room.tags.include?(place) }
		results.delete_if { |room_id| where_is_shortest_distances_var[room_id].nil? or where_is_shortest_distances_var[room_id] > CharSettings['max-travel-time'] }
		results.sort { |a,b| where_is_shortest_distances_var[a] <=> where_is_shortest_distances_var[b] }
	end
}

go_empty_workshop = proc {
	room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
	unless room_list.empty? or room_list.include?(Room.current.id)
		get_cauldron.call
		for room_id in room_list
			break if where_is_shortest_distances_var[room_id] > 15
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			break unless checkpcs
		end
	end
}

is_workshop = proc {
	Room.current.tags.include?("#{Char.prof.downcase} alchemy workshop")
}

tavel_time = proc { |room_id|
	if where_is_shortest_distances_var.nil?
		where_is.call
	end
	where_is_shortest_distances_var[room_id]
}

note_name_var = nil
note_name = proc {
	if note_name_var.nil?
		if (room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first) and (location = Room[room_id].location)
			hash = {
				'Icemule Trace' => 'Icemule promissory note',
				'Kharam-Dzu' => 'Borthuum Mining Company scrip',
				"Wehnimer's Landing" => "Wehnimer's promissory note",
				"the Coastal Cliffs" => "Wehnimer's promissory note",
				"River's Rest" => 'Torren promissory note',
				'Zul Logoth' => 'mining chit',
				"Ta'Illistim" => 'City-States promissory note',
				"Ta'Vaalor" => 'City-States promissory note',
				'Solhaven' => 'Vornavis promissory note',
				'Mist Harbor' => 'Mist Harbor promissory note',
			}
			note_name_var = hash[location]
		else
			note_name_var = false
		end
	else
		note_name_var
	end
}

is_sunlight = proc {
	# fixme: guessing times for light
	# mid-morning:     11:26 - 11:26
	# afternoon:       12:07 - 14:04 (sunlight)
	# late afternoon:  14:23 - 16:48 (sunlight)
	# evening twilight 16:49 - 17:33 (moonlight)
	# late evening:    18:20 - 23:20
	# after midnight:  00:01 - 04:33
	# May 13-14, 2011
		# late afternoon:       ? - 18:50 (sunlight)
		# evening twilight: 18:51 - 19:20 (moonlight)
		# late evening:     19:21 - 23:59 (moonlight)
		# after midnight:   00:00 - 04:37 (moonlight)
		# morning twilight: 04:38 - 05:07 
		# early morning:    05:08 - 08:33 (sunlight)
		# mid morning:      08:34 - 11:59 (sunlight)
		# afternoon:        12:00 -     ? (sunlight)
	# (server_time.hour > 4 or (server_time.hour == 4 and server_time.min > 30)) and (server_time.hour < 16 or (server_time.hour == 16 and server_time.min < 30))
	offset = -18000
	if Time.now.dst?
		offset += 3600
	end
	# fixme: getlocal doesn't take an offset on Ruby 1.8
	time = Time.at(Time.now.to_f + XMLData.server_time_offset.to_f).getlocal(offset)
	(time.hour > 5 or (time.hour == 5 and time.min > 7)) and (time.hour < 18 or (time.hour == 18 and time.min < 51))
}

is_moonlight = proc { !is_sunlight.call }

set_needed_reagents = proc {
	ingredient_list = Array.new
	check_proc = proc { |recipe|
		for step in recipe[:steps]
			if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
				ingredient_name = $1
				ingredient_list.push(ingredient_name) unless ingredient_list.include?(ingredient_name)
				if equivalent_names = equivalent.find { |list| list.include?(ingredient_name) }
					for equivalent_name in equivalent_names
						ingredient_list.push(equivalent_name) unless ingredient_list.include?(equivalent_name)
					end
				end
				for sub_recipe in known_recipes.find_all { |r| r[:product] == ingredient_name }
					check_proc.call(sub_recipe)
				end
			end
		end
	}
	for type in gld.call.keys
		for recipe in known_recipes.find_all { |recipe| CharSettings['favorite-recipes'].include?(recipe[:product]) or ((recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and (gld.call[type][:rank] <= 62) and (gld.call[type][:rank] >= recipe[:rank].min) and (gld.call[type][:rank] <= recipe[:rank].max)) }
			check_proc.call(recipe)
		end
	end
	for product in CharSettings['favorite-recipes']
		ingredient_list.push(product) unless ingredient_list.include?(product)
	end
	if ingredient_list.empty?
		UserVars.delete('needed_reagents')
	else
		UserVars.needed_reagents = "^#{ingredient_list.join('$|^')}$"
	end
	nil
}

is_reagent_var = nil
is_reagent = proc { |test_name|
	unless is_reagent_var
		reagent_array = Array.new
		known_recipes.each { |recipe|
			recipe[:steps].each { |step|
				if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
					item = $1
					equivalent.find { |r| r.include?(item) }.each { |i| reagent_array.push(i) unless reagent_array.include?(i) }
					reagent_array.push(item) unless reagent_array.include?(item)
				end
			}
		}
		is_reagent_var = /^#{reagent_array.collect { |r| r.sub(/^some /, '(?:some )?').sub('faintly ', '(?:faintly )?') }.join('$|^')}$/
	end
	test_name =~ is_reagent_var
}

do_administrator = proc {
	if gld.call.any? { |type,info| (info[:task] =~ /^(?:no task|promotion|gather alchemy ingredients for the guild's supply)$/ or info[:reps] == 0) and ((type == 'alchemy') or (info[:rank] < gld.call['alchemy'][:rank])) }
		general_ranks = gld.call['alchemy'][:rank]
		loop {
			get_cauldron.call
			if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				did_something = false
				if gld.call['alchemy'].nil?
					dothistimeout "ask #{GameObj.npcs.last.noun} about training alchemy", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				if gld.call['potions'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
					dothistimeout "ask #{GameObj.npcs.last.noun} about training potions", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				if gld.call['trinkets'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
					dothistimeout "ask #{GameObj.npcs.last.noun} about training trinkets", 10, /^#{GameObj.npcs.last.noun} .*?, "/
					invalid_gld.call
				end
				for type,info in gld.call
					next if (type =~ /potions|trinkets/) and (info[:rank] == gld.call['alchemy'][:rank])
					if info[:task] == 'no task'
						result = dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						invalid_gld.call
						unless result =~ /your general alchemy skills are not quite up to snuff/
							did_something = true
						end
					elsif (info[:task] == 'promotion')
						if type != 'alchemy' or info[:rank].to_i != 5 or (gld.call['potions'][:rank].to_i >= 2 and gld.call['trinkets'][:rank].to_i >= 2)
							if type != 'alchemy' or info[:rank].to_i != 10 or (gld.call['potions'][:rank].to_i >= 3 and gld.call['trinkets'][:rank].to_i >= 3)
								if room_id = where_is.call("#{Char.prof.downcase} alchemy guildmaster").first
									start_script 'go2', [ room_id.to_s ]
									wait_while { running?('go2') }
									result = dothistimeout "ask #{GameObj.npcs.last.noun} about next #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
									unless result =~ /you must diversify/
										did_something = true
										invalid_gld.call
										set_needed_reagents.call
									end
									room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
									start_script 'go2', [ room_id.to_s ]
									wait_while { running?('go2') }
								else
									echo 'error: failed to find guildmaster'
								end
							end
						end
					elsif info[:reps] == 0
						dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						invalid_gld.call
						did_something = true
					elsif info[:task] == "gather alchemy ingredients for the guild's supply"
						invalid_gld.call
						dothistimeout "ask #{GameObj.npcs.last.noun} about trade #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
						did_something = true
					end
				end
				break unless did_something
			else
				echo 'error: failed to find training administrator'
				break
			end
		}
	end
}

read_menu = proc {
	status_tags
	clear
	fput 'unhide' if hidden? or invisible?
	fput 'order'
	menu = Hash.new
	while (line = get) and (line !~ /ORDER|BUY/)
		for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
			menu[item[1].sub(/^a /, '')] = item[0]
		end
	end
	status_tags
	clear
	menu
}

check_channel_spirit = proc {
	needed_spirit = 3
	needed_spirit += 1 if Spell[9912].active?
	needed_spirit += 1 if Spell[9913].active?
	needed_spirit += 1 if Spell[9914].active?
	needed_spirit += 3 if Spell[9916].active?
	checkspirit(needed_spirit)
}

ingredient_count = Hash.new
correct_herb_count = Array.new

check_ingredient = proc { |ingredient_name,temp_claimed_ingredients,temp_ingredient_count|
	temp_claimed_ingredients ||= Array.new
	if temp_ingredient_count.nil? or temp_ingredient_count.empty?
		temp_ingredient_count = ingredient_count.dup
	end
	found = false
	equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
	if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) and not temp_claimed_ingredients.include?(obj.id) }
		temp_claimed_ingredients.push(ingredient.id)
		found = true
	elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[bundle.id].nil?
			empty_hand
			dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
			measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
			if measure_result =~ /1 bite/
				temp_ingredient_count[bundle.id] = 1
				ingredient_count[bundle.id] = 1
			elsif measure_result =~ /2 bites/
				temp_ingredient_count[bundle.id] = 2
				ingredient_count[bundle.id] = 2
			elsif measure_result =~ /a few bites/
				temp_ingredient_count[bundle.id] = 3
				ingredient_count[bundle.id] = 3
			elsif measure_result =~ /several bites/
				temp_ingredient_count[bundle.id] = 5
				ingredient_count[bundle.id] = 5
			elsif measure_result =~ /plenty of bites/
				temp_ingredient_count[bundle.id] = 11
				ingredient_count[bundle.id] = 11
			else
				temp_ingredient_count[bundle.id] = 1
				ingredient_count[bundle.id] = 1
				echo "error: unmatched measure result: #{measure_result.inspect}"
			end
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			fill_hand
		end
		temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
		found = true
	elsif jar = all_sack_contents.call.find { |obj| (obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[jar.id].nil?
			if CharSettings['hide-jar-check']
				action = proc { |server_string|
					if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
						DownstreamHook.remove('hide-jar-check')
						nil
					else
						server_string
					end
				}
				DownstreamHook.add('hide-jar-check', action)
			end
			look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
			temp_ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
			ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
		end
		temp_ingredient_count[jar.id] = temp_ingredient_count[jar.id] - 1
		found = true
	elsif bundle = all_sack_contents.call.find { |obj| (obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
		if temp_ingredient_count[bundle.id].nil?
			if CharSettings['hide-bundle-check']
				action = proc { |server_string|
					if server_string =~ /^You.*?total of [0-9]+/
						DownstreamHook.remove('hide-bundle-check')
						nil
					else
						server_string
					end
				}
				DownstreamHook.add('hide-bundle-check', action)
			end
			measure_result = dothis "measure ##{bundle.id}", /^You.*?total of [0-9]+/
			temp_ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
			ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
		end
		temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
		found = true
	end
	[ found, temp_claimed_ingredients, temp_ingredient_count ]
}

get_ingredient = proc { |ingredient_name|
	ingredient = nil
	equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
	if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) }
		dothistimeout "get ##{ingredient.id}", 10, /^You remove|^You already have that/
	elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) }
		dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
		bundle_remove_result = dothistimeout 'bundle remove', 10, /^You (?:carefully )?remove|^Those were the last two|^You only have one/
		if bundle_remove_result =~ /^You only have one/
			correct_herb_count.delete(bundle.id)
			ingredient_count.delete(bundle.id)
			ingredient = bundle
		elsif correct_herb_count.include?(bundle.id)
			ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			if checkleft
				ingredient = GameObj.left_hand
			else
				echo 'error: left hand unexpectedly empty'
			end
		else
			measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
			if measure_result =~ /1 bite/
				min_count = 1
				correct_herb_count.push(bundle.id)
			elsif measure_result =~ /2 bites/
				min_count = 2
				correct_herb_count.push(bundle.id)
			elsif measure_result =~ /a few bites/
				min_count = 3
				if ingredient_count[bundle.id].to_i > 4
					correct_herb_count.push(bundle.id)
				end
			elsif measure_result =~ /several bites/
				min_count = 5
				if ingredient_count[bundle.id].to_i > 10
					correct_herb_count.push(bundle.id)
				end
			elsif measure_result =~ /plenty of bites/
				min_count = 11
			else
				min_count = 0
				echo "error: unmatched measure result: #{measure_result.inspect}"
			end
			if ingredient_count[bundle.id].nil?
				ingredient_count[bundle.id] = min_count
			else
				ingredient_count[bundle.id] = [(ingredient_count[bundle.id] - 1), min_count].max
			end
			dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
			if checkleft
				ingredient = GameObj.left_hand
			else
				echo 'error: left hand unexpectedly empty'
			end
		end
	elsif jar = all_sack_contents.call.find { |obj| obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/ }
		unless ingredient_count[jar.id].nil?
			ingredient_count[jar.id] = ingredient_count[jar.id] - 1
			ingredient_count.delete(jar.id) if ingredient_count[jar.id] < 1
		end
		dothistimeout "get ##{jar.id}", 10, /^You remove|^You already have that/
		dothistimeout "shake ##{jar.id}", 10, /^You .*shake/
		dothistimeout "put ##{jar.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		if checkleft
			ingredient = GameObj.left_hand
		else
			echo 'error: left hand unexpectedly empty'
		end
	elsif bundle = all_sack_contents.call.find { |obj| obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/ }
		unless ingredient_count[bundle.id].nil?
			ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
			ingredient_count.delete(bundle.id) if ingredient_count[bundle.id] < 2
		end
		dothistimeout "get ##{bundle.id}", 10, /^You remove|^You already have that/
		unbundle_result = dothistimeout 'bundle remove', 10, /^You remove|^Those were the last two/
		dothistimeout "put ##{bundle.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		if checkleft
			ingredient = GameObj.left_hand
		else
			echo 'error: left hand unexpectedly empty'
		end
	end
	ingredient
}

put_crap_away = proc {
	if (GameObj.right_hand.name =~ /ayanad crystals$/) or (GameObj.left_hand.name =~ /ayanad crystals$/)
		dothis "get crystal from my crystals", /You separate/
		dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
	end
	if checkright
		if is_reagent.call(GameObj.right_hand.name)
			dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			dothis "put ##{GameObj.right_hand.id} in ##{loot_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
	if checkleft
		if is_reagent.call(GameObj.left_hand.name)
			dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			dothis "put ##{GameObj.left_hand.id} in ##{loot_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
}

recursive_check_recipe = proc { |recipe,tracker,top_level|
	recipe[:steps].each { |step|
		if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
			ingredient_name = $1
			if step =~ /^grind/
				unless all_sack_contents.call.any? { |obj| obj.noun == 'mortar' }
					tracker[:error]['mortar'] = 1
				end
				if Char.prof == 'Wizard'
					tracker[:time] += 5
				else
					tracker[:time] += 25
				end
			elsif step =~ /^extract/
				tracker[:time] += 40
			elsif step =~ /^distill/
				tracker[:time] += 40
			end
			if tracker[:extra_ingredients].include?(ingredient_name)
				tracker[:extra_ingredients].delete_at(tracker[:extra_ingredients].index(ingredient_name))
				tracker[:found][ingredient_name] = tracker[:found][ingredient_name].to_i + 1
			else
				found_this, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name, tracker[:claimed_ingredients].dup, tracker[:ingredient_count].dup)
				if found_this
					tracker[:claimed_ingredients] = temp_claimed_ingredients
					tracker[:ingredient_count] = temp_ingredient_count
					tracker[:found][ingredient_name] = tracker[:found][ingredient_name].to_i + 1
					tracker[:cost] += elusive_reagent_cost[ingredient_name].to_i
				else
					support_recipe_list = known_recipes.find_all { |r| r[:product] == ingredient_name }
					if support_recipe_list.length > 0
						tracker_list = Array.new
						for support_recipe in support_recipe_list
							temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time] }
							temp_tracker = recursive_check_recipe.call(support_recipe.dup, temp_tracker, _top_level=false)
							tracker_list.push(temp_tracker)
							ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
						end
						tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
						unless tracker = tracker_list.find { |t| t[:error].empty? }
							tracker_list.sort! { |a,b|
								ae = 0
								a[:error].values.each { |v| ae += v }
								be = 0
								b[:error].values.each { |v| be += v }
								ae <=> be
							}
							tracker = tracker_list.first
						end
					else
						tracker[:error][ingredient_name] = tracker[:error][ingredient_name].to_i + 1
					end
				end
			end
		elsif step =~ /^buy\s+.*?from\s+(.*)/
			place = $1
			room_list = where_is.call(place)
			if room_list.empty?
				tracker[:error][place] = 1
			else
				unless tracker[:buy].keys.any? { |key| key =~ /^#{place};/ }
					tracker[:time] += tavel_time.call(room_list.first) * 2
				end
				tracker[:cost] += recipe[:cost].to_i
				tracker[:buy]["#{place};#{recipe[:product]}"] = tracker[:buy]["#{place};#{recipe[:product]}"].to_i + 1
			end
		elsif step =~ /^forage/
			room_list = where_is.call(recipe[:product])
			if room_list.empty?
				tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
			else
				if tracker[:forage][recipe[:product]].nil?
					tracker[:time] += tavel_time.call(room_list.first) * 2
				end
				CharSettings['forage time'] ||= Hash.new
				if CharSettings['forage time'][recipe[:product]].nil?
					CharSettings['forage time'][recipe[:product]] = [ 1, 1 ]
				end
				tracker[:time] += CharSettings['forage time'][recipe[:product]][0] / CharSettings['forage time'][recipe[:product]][1].to_f
				tracker[:forage][recipe[:product]] = tracker[:forage][recipe[:product]].to_i + 1
			end
		elsif step =~ /^kill\s+(.*)/
			npc = $1
			room_list = where_is.call(npc)
			if room_list.empty?
				tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
				# tracker[:error][npc] = tracker[:error][npc].to_i + 1
			else
				if CharSettings['attack-script']
					if tracker[:kill_for][recipe[:product]].nil?
						tracker[:time] += tavel_time.call(room_list.first) * 2
					end
					CharSettings['kill time'] ||= Hash.new
					CharSettings['kill time'][npc] ||= Hash.new
					if CharSettings['kill time'][npc][recipe[:product]].nil?
						CharSettings['kill time'][npc][recipe[:product]] = [ 1, 1 ]
					end
					tracker[:time] += CharSettings['kill time'][npc][recipe[:product]][0] / CharSettings['kill time'][npc][recipe[:product]][1].to_f
					tracker[:kill_for][recipe[:product]] = tracker[:kill_for][recipe[:product]].to_i + 1
				else
					tracker[:error]['attack-script'] = 1
				end
			end
		elsif step =~ /^light/
#			unless top_level
#				tracker[:recipe_count][recipe[:product]] = tracker[:recipe_count][recipe[:product]].to_i + 1
#			end
			unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.any? { |obj| obj.noun == 'cauldron' } or GameObj.loot.any? { |obj| obj.noun =~ /^(?:cauldron|vat)$/ } or all_sack_contents.call.any? { |obj| obj.noun =~ /^(?:cauldron|vat)$/ }
				tracker[:error]['cauldron'] = 1
			end
		elsif step =~ /^special/
			if vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
				tracker[:found][vial.name] = 1
			else
				tracker[:error]['vial for sea water'] = 1
			end
			if flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
				tracker[:found][flask.name] = 1
			else
				tracker[:error]['flask for sea water'] = 1
			end
			tracker[:time] += 40
		elsif step =~ /^simmer/
			tracker[:time] += 20
		elsif step =~ /^boil/
			tracker[:time] += 20
		elsif step =~ /^chant/
			tracker[:time] += 30
		elsif step =~ /^infuse/
			tracker[:time] += 15
			unless gld.call['alchemy'][:rank].to_i >= 30
				tracker[:error]['alchemy infuse'] = 1
			end
		elsif step =~ /^channel/
			tracker[:time] += 30
		elsif step =~ /^seal/
			tracker[:time] += 26
		elsif step =~ /^refract (moonlight|sunlight) through (.* lens)$/
			light = $1
			lens = $2
			unless all_sack_contents.call.any? { |obj| obj.name == lens }
				tracker[:error][lens] = 1
			end
			if (light == 'sunlight') and is_moonlight.call
				tracker[:error]['sunlight'] = 1
			elsif (light == 'moonlight') and is_sunlight.call
				tracker[:error]['moonlight'] = 1
			end
			tracker[:time] += 10
		else
			echo "warning: unkown step: #{step}"
		end
	}
	if top_level
		tracker[:recipe_count][recipe[:product]] = tracker[:recipe_count][recipe[:product]].to_i + 1
		recipe[:steps].each { |step| tracker[:finish_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	else
		recipe[:steps].each { |step| tracker[:prepare_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	end
	recipe[:steps].each { |step| tracker[:steps].push(step) unless step =~ /^buy|^forage|^kill/ }
	if recipe[:product] =~ /^(?:s'|t')?ayanad crystal$/
		tracker[:extra_ingredients].push(recipe[:product])
	end
	tracker
}

check_recipe = proc { |recipe_name,repetitions|
	tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0 }
	if recipe_name.class == Array
		recipe_list = known_recipes.find_all { |recipe| recipe_name.include?(recipe[:product]) }
	else
		recipe_list = known_recipes.find_all { |recipe| recipe[:product] == recipe_name }
	end
	repetitions.times {
		if recipe_list.length > 0
			tracker_list = Array.new
			for recipe in recipe_list
				temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time] }
				temp_tracker = recursive_check_recipe.call(recipe, temp_tracker, top_level=true)
				tracker_list.push(temp_tracker)
				ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
			end
			tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
			tracker = tracker_list.find { |t| t[:error].empty? } || tracker_list.first
		else
			tracker[:error][recipe_name] = tracker[:error][recipe_name].to_i + 1
		end
	}
	fixed_buy = Hash.new
	tracker[:buy].each_pair { |where_what,how_many|
		where, what = where_what.split(';')
		fixed_buy[where] ||= Hash.new
		fixed_buy[where][what] = how_many
	}
	tracker[:buy] = fixed_buy
	tracker.delete(:claimed_ingredients)
	tracker.delete(:ingredient_count)
	tracker.delete(:extra_ingredients)
	tracker
}

show_check = proc { |check_info|
	output = "\n"
	output.concat check_info[:recipe_count].collect { |n,c| if c == 1; n; else; "#{n} (#{c})"; end }.join(', ').to_s
	output.concat "\n"
	unless check_info[:found].empty?
		output.concat "   have:\n"
		check_info[:found].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:forage].empty?
		output.concat "   forage:\n"
		check_info[:forage].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:kill_for].empty?
		output.concat "   kill for:\n"
		check_info[:kill_for].each_pair { |n,c|
			output.concat "      #{n.sub(/s*\#.*$/, '')}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	unless check_info[:buy].empty?
		output.concat "   buy:\n"
		check_info[:buy].values.each { |place|
			place.each_pair { |n,c|
				output.concat "      #{n.sub(/s*\#.*$/, '')}"
				output.concat " (#{c})" if c > 1
				output.concat "\n"
			}
		}
	end
	unless check_info[:error].empty?
		output.concat "   #{monsterbold_start}missing:#{monsterbold_end}\n"
		check_info[:error].each_pair { |n,c|
			output.concat "      #{n}"
			output.concat " (#{c})" if c > 1
			output.concat "\n"
		}
	end
	output.concat "\ncost: #{check_info[:cost]}, time: #{(check_info[:time]/60.0).as_time}\n\n"
	puts output
}

do_steps = proc { |steps|
	error = false
	uber_return_room = nil
	while step = steps.shift
		if step == 'light'
			need_empty_flask = false
			wait_spirit = false
			temp_claimed_ingredients = Array.new
			temp_ingredient_count = ingredient_count.dup
			for sub_step in steps
				if sub_step =~ /^add\s+(.*)/
					ingredient_name = $1
					found, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name,temp_claimed_ingredients,temp_ingredient_count)
					unless found
						error = true
						echo "error: missing #{ingredient_name}"
					end
				elsif sub_step == 'channel'
					wait_spirit = true
				elsif sub_step =~ /^(?:buy|forage|kill)/
					echo 'error: out of cheese'
					error = true
					break
				elsif sub_step == 'seal'
					break
				elsif sub_step =~ /^refract (moonlight|sunlight)/
					light = $1
					if (light == 'sunlight') and is_moonlight.call
						echo 'error: missing sunlight'
						error = true
						break
					elsif (light == 'moonlight') and is_sunlight.call
						echo 'error: missing moonlight'
						error = true
						break
					end
					unless is_workshop.call
						uber_return_room = Room.current
						get_cauldron.call
						go_empty_workshop.call
					end
				end
			end
			if error
				break
			else
				if wait_spirit
					unless check_channel_spirit.call
						echo 'waiting for spirit...'
						sleep 0.3 until check_channel_spirit.call
					end
				end
				drop_cauldron.call
				unless mana >= 1
					echo 'waiting for mana...'
					wait_until { mana >= 1 }
				end
				light_result = dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
				if light_result =~ /^But that is already lit!$/
					force_drop_cauldron.call
					dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
				end
			end
		elsif step =~ /^(add|grind|extract|distill|separate)\s+(.*)/
			action = $1
			ingredient_name = $2
			unless ingredient = get_ingredient.call(ingredient_name)
				echo "error: missing #{ingredient_name}"
				error = true
				break
			end
			if action == 'add'
				dothis "put ##{ingredient.id} in #{cauldron.noun || 'cauldron'}", /^You place|^You pour/
				if GameObj.right_hand.name == 'empty flask'
					dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					need_empty_flask = true
				elsif GameObj.left_hand.name == 'empty flask'
					dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					need_empty_flask = true
				end
			elsif action == 'grind'
				if checkright
					dothis 'swap', /^You swap/
				end
				mortar = all_sack_contents.call.find { |obj| obj.noun == 'mortar' }
				dothis "get ##{mortar.id}", /^You remove|^You already have that/
				dothis "put ##{ingredient.id} in ##{mortar.id}", /^You put|^I could not find what you were referring to\./
				loop {
					haste = Spell[506]
					haste.cast if haste.known? and haste.affordable? and not haste.active?
					waitrt?
					grind_result = dothis "grind #{ingredient.noun} from my mortar", /^Roundtime. [0-9]+ sec\.$|appears to be as ground as its going to get|^Grind what|^With what do you intend to grind/
					waitrt?
					if grind_result =~ /^With what do you intend to grind/
						unless pestle = all_sack_contents.call.find { |obj| obj.noun == 'pestle' }
							echo "error: missing pestle"
							error = true
							break
						end
						dothis "_drag ##{pestle.id} ##{mortar.id}", /^You put|^I could not find what you were referring to\./
					elsif grind_result =~ /appears to be as ground as its going to get|^Grind what/
						break
					end
				}
				break if error
				if mortar.contents.nil?
					dothis "look in ##{mortar.id}", /^In the .*? you see/
				end
				for item in mortar.contents
					next if item.noun == 'pestle'
					dothis "_drag ##{item.id} ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				end
				dothis "put ##{mortar.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
			elsif action == 'extract'
				unless checkright
					dothis 'swap', /^You swap/
				end
				return_room = nil
				unless is_workshop.call
					return_room = Room.current
					get_cauldron.call
					go_empty_workshop.call
				end
				if is_workshop.call
					unless mana >= 10
						echo 'waiting for mana...'
						wait_until { mana >= 10 }
					end
					dothis 'alchemy extract', /^You carefully (?:pour|place)/
					result = nil
					900.times { 
						sleep 0.1
						break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
					}
					sleep 1
					waitrt?
					put_crap_away.call
					if return_room
						start_script 'go2', [ return_room.id.to_s ]
						wait_while { running?('go2') }
					end
					if result.nil?
						echo "error: extract failed (game bug)"
						error = true
						break
					end
				else
					echo "error: failed to find workshop"
					error = true
					break
				end
			elsif action == 'distill'
				unless checkright
					dothis 'swap', /^You swap/
				end
				return_room = nil
				unless is_workshop.call
					return_room = Room.current
					get_cauldron.call
					go_empty_workshop.call
				end
				if is_workshop.call
					dothis 'alchemy distill', /^You select an unused/
					waitfor 'Sensing the process nearing its end'
					sleep 1
					waitrt?
					put_crap_away.call
					if return_room
						start_script 'go2', [ return_room.id.to_s ]
						wait_while { running?('go2') }
					end
				else
					echo "error: failed to find workshop"
					error = true
					break
				end
			elsif action == 'separate'
				noun = GameObj.right_hand.noun || GameObj.left_hand.noun
				dothis "get 1 #{noun.sub(/s$/, '')} from my #{noun}", /^You separate/
				put_crap_away.call
			end
		elsif step == 'boil'
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				boil_result = dothis 'alchemy boil', /^You focus on the [\w\s\-]+ (?:cauldron|vat) and push mana into it.  The flame beneath it (flickers briefly, but then dies down|quickly flares up wildly, bringing the contents to a rolling boil)\.$/
				waitrt?
				break if boil_result =~ /^You focus on the [\w\s\-]+ (?:cauldron|vat) and push mana into it.  The flame beneath it quickly flares up wildly, bringing the contents to a rolling boil\.$/
			}
		elsif step == 'simmer'
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				# simmer_result = dothis 'alchemy simmer', /^You focus on the [\w\s\-]+ (?:cauldron|vat) and gently push mana into it\.  The flame beneath it (flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer)\.$/
				simmer_result = dothis 'alchemy simmer', /flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer/
				waitrt?
				break if simmer_result =~ /quickly flares to life, bringing the contents to a slow simmer/
			}
		elsif step =~ /^chant /
			loop {
				unless mana >= 1
					echo 'waiting for mana...'
					wait_until { mana >= 1 }
				end
				chant_result = dothis "alchemy #{step}", /^You extend/
				waitrt?
				break if chant_result =~ /^You extend your hands.*vanish into the solution/
			}
		elsif step =~ /^infuse/
			loop {
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				dothis 'alchemy infuse', /^You focus/
				infuse_result = waitfor 'The translucent thread fades away.  You feel slightly drained from the ordeal.', 'Your concentration lapses and the translucent thread connecting you to the solution fades away.'
				waitrt?
				break if infuse_result == 'The translucent thread fades away.  You feel slightly drained from the ordeal.'
			}
		elsif step == 'channel'
			loop {
				unless check_channel_spirit.call
					echo 'waiting for spirit...'
					sleep 0.3 until check_channel_spirit.call
				end
				channel_result = dothis 'alchemy channel', /^You focus .*? and link your spirit|^You attempt to channel/
				waitrt?
				break if channel_result =~ /^You focus .*? and link your spirit/
			}
		elsif step =~ /^refract (?:moonlight|sunlight) through (.* lens)$/
			# >alchemy refract
			# You select an unused gem lens assembly and set it up on the brushed steel workbench.
			# You carefully set the sapphire lens within the assembly and adjust it, aiming the refracted sunlight into your iron cauldron.
			# The surface of the solution in the iron cauldron shimmers in response!
			lens_name = $1
			unless lens = all_sack_contents.call.find { |obj| obj.name == lens_name }
				echo "error: failed to find #{lens_name}"
				error = true
				break
			end
			dothistimeout "get ##{lens.id}", 10, /^You remove|^You already have that/
			dothistimeout 'alchemy refract', 10, /^The surface of the solution in .* shimmers in response!/
			waitrt?
			dothistimeout "put ##{lens.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
		elsif step == 'seal'
			unless mana >= 20
				echo 'waiting for mana...'
				wait_until { mana >= 20 }
			end
			if need_empty_flask
				dothis "get empty flask from ##{alchemy_sack.call.id}", /^You remove|^Get what\?/
			end
			fput "look in #{cauldron.noun || 'cauldron'}"
			dothis 'alchemy seal', /^You hold your hands over/
			nil until get =~ /You sense (?:that the ritual is complete|something amiss with the solution)/
			sleep 0.5
			waitrt?
			sleep 0.5
			put_crap_away.call
		elsif step == 'special'
			vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
			flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
			dothis "get ##{vial.id}", /^You remove|^You already have that/
			dothis "get ##{flask.id}", /^You remove|^You already have that/
			dothis "open ##{flask.id}", /^You gently twist the stopper on the flask|^It's already open\.$/
			pour_result = dothis "pour ##{flask.id} in ##{vial.id}", /^You pour|^It looks like your glass vial is already full\.$|^But your crystal flask is empty!$/
			if pour_result == 'But your crystal flask is empty!'
				dothis "put ##{vial.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				get_cauldron.call
				if room_id = where_is.call('alchemy sea water').first
					return_room = Room.current
					start_script 'go2', [ room_id.to_s ]
					wait_while { running?('go2') }
					dothis "collect water with ##{flask.id}", /under water until it is filled|is already filled/
					dothis "get ##{vial.id}", /^You remove|^You already have that/
					dothis "collect water with ##{vial.id}", /under water until it is filled|is already filled/
					start_script 'go2', [ return_room.id.to_s ]
					wait_while { running?('go2') }
				else
					echo 'error: failed to find a place to collect sea water'
					error = true
					break
				end
			end
			dothis "close ##{flask.id}", /^You draw up the slick crystal cork|^It's already corked\.$/
			dothis "put ##{flask.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
			unless is_workshop.call
				return_room = Room.current
				get_cauldron.call
				go_empty_workshop.call
			end
			if is_workshop.call
				unless mana >= 10
					echo 'waiting for mana...'
					wait_until { mana >= 10 }
				end
				dothis 'alchemy extract', /^You carefully (?:pour|place)/
				result = nil
				900.times { 
					sleep 0.1
					break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
				}
				sleep 1
				waitrt?
				dothistimeout "put ##{vial.id} in ##{alchemy_sack.call.id}", 3, /^You put|^I could not find what you were referring to\./
				put_crap_away.call
				if return_room
					start_script 'go2', [ return_room.id.to_s ]
					wait_while { running?('go2') }
				end
				if result.nil?
					echo "error: extract failed (game bug)"
					error = true
					break
				end
			else
				echo "error: failed to find workshop"
				error = true
				break
			end
		end
	end
	if uber_return_room
		get_cauldron.call
		start_script 'go2', [ uber_return_room.id.to_s ]
		wait_while { running?('go2') }
	end
	invalid_gld.call
	!error
}

forage = proc { |forage_list|
	get_cauldron.call
	if CharSettings['before-forage-script']
		start_script(CharSettings['before-forage-script'])
		wait_while { running?(CharSettings['before-forage-script']) }
	end
	start_forage_time = Time.now
	used_rooms = Array.new
	forage_result = nil
	sanct = Spell[213]
	for name,num in forage_list.dup
		break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
		for room_num in where_is.call(name)
			break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
			start_script 'go2', [ room_num.to_s ]
			wait_while { running? 'go2' }
			unless checkpcs
				start_time = Time.now
				found_count = 0
				sanct.cast if CharSettings['cast-sanctuary'] and sanct.known? and sanct.affordable?
				fput 'kneel'
				empty_hands
				loop {
					break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
					if haste = Spell[506]
						haste.cast if haste.known? and haste.affordable? and not haste.active?
					end
					if presence = Spell[402]
						presence.cast if presence.known? and presence.affordable? and not presence.active?
					end
					if (id = GameObj.right_hand.id)
						dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
					end
					if (id = GameObj.left_hand.id)
						dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
					end
					forage_result = dothistimeout "forage for #{name.sub(/^(?:cluster|layer|mass) of |^luminescent |^black\-tipped /, '').sub(/^(?:some fetid )/, 'some ')}", 10, /^You forage|^You make so much noise that only the dead would not notice you thrashing about in your unsuccessful search\.$|^You stumble about in a fruitless attempt at foraging\.$|you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\.|^You begin to forage around when your hand comes into contact with something that stabs you in the finger\.$|^As you forage around you suddenly feel a sharp pain in your right hand!|^You begin to forage around when suddenly you feel a burning sensation in your hand\.$|^You fumble about so badly in your search that you can only hope no one was watching you\.$/
					sleep 0.5
					waitrt?
					if forage_result =~ /^You forage briefly and manage to find/
						if id = GameObj.right_hand.id
							dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
						end
						if id = GameObj.left_hand.id
							dothis "put ##{id} in ##{herb_sack.call.id}", /^You put|^I could not find what you were referring to\./
						end
						if herb_doses[name]
							forage_list[name] = forage_list[name] - herb_doses[name]
							found_count += herb_doses[name]
						else
							forage_list[name] = forage_list[name] - 1
							found_count += 1
						end
						if forage_list[name] < 1
							break
						end
					elsif forage_result =~ /^You begin to forage around when your hand comes into contact with something that stabs you in the finger./
						waitrt?
						unpoison = Spell[114]
						unpoison.cast if unpoison.known? and unpoison.affordable?
					elsif forage_result =~ /^As you forage around you suddenly feel a sharp pain in your right hand!/
						start_script 'useherbs'
						wait_while { running? 'useherbs' }
					elsif forage_result.nil?  or (forage_result =~ /you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\./)
						break
					end
				}
				fill_hands
				end_time = Time.now
				CharSettings['forage time'] ||= Hash.new
				if CharSettings['forage time'][name].nil?
					CharSettings['forage time'][name] = [ 1, 1 ]
				end
				CharSettings['forage time'][name][1] += found_count
				CharSettings['forage time'][name][0] += end_time - start_time
				fput 'stand'
				if forage_list[name] < 1
					forage_list.delete(name)
					break
				end
				break if forage_result =~ /though you are fairly certain this is where it can be found/
			end
			break if forage_result =~ /though you are fairly certain this is where it can be found/
		end
	end
	if CharSettings['after-forage-script']
		if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
		end
		start_script(CharSettings['after-forage-script'])
		wait_while { running?(CharSettings['after-forage-script']) }
	end
	forage_list
}

buy = proc { |shopping_list|
	empty_hands
	get_cauldron.call
	for place,hash in shopping_list.dup
		unless note = all_sack_contents.call.find { |obj| obj.name == note_name.call }
			echo 'error: you are too poor for alchemy'
			break
		end
		unless room_id = where_is.call(place).first
			echo "error: don't know where #{place} is"
			break
		end
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		if place =~ /^(?:Icemule|River's Rest) empath guild entrance$/
			get_result = dothis "get ##{note.id}", /^You remove|^You already have that|^Get what\?/
			for name,num in hash.dup
				if name == 'vial of faintly glowing aelotoi tears'
					num.times {
						dothis 'buy aelotoi tears', /^A sales clerk .* Handing it to you/
						dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					}
					shopping_list[place].delete(name)
				end
			end
			dothis "put ##{note.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		else
			menu = read_menu.call
			get_result = dothis "get ##{note.id}", /^You remove|^You already have that|^Get what\?/
			if get_result =~ /^Get what\?/
				echo "error: can't find bank note"
				break
			end
			for name,num in hash.dup
				unless order_number = menu[name].sub(/s*\#.*$/, '')
					if equivalent_names = equivalent.find { |list| list.include?(name) }
						for ingredient_name in equivalent_names
							break if order_number = menu[ingredient_name].sub(/s*\#.*$/, '')
						end
					end
					unless order_number
						echo "error: failed to find #{name} in the menu"
						next
					end
				end
				if herb_doses[name]
					num = (num/herb_doses[name].to_f).ceil
				end
				(num/10).times {
					dothis "order #{10} of #{order_number}", /BUY/
					fput 'buy'
					dothis 'open my package', /^You open|^That is already open/
					# fixme: but nothing will fit
					# fixme: leaving the rest in the package.
					dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
					waitrt?
					dothis 'throw my package', /^You throw away/
					shopping_list[place][name] -= 10
				}
				num = num % 10
				if num > 1
					dothis "order #{num} of #{order_number}", /BUY/
					fput 'buy'
					dothis 'open my package', /^You open|^That is already open/
					dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
					waitrt?
					dothis 'throw my package', /^You throw away/
					shopping_list[place][name] -= num
				elsif num == 1
					dothis "order #{order_number}", /BUY/
					fput 'buy'
					100.times { break if checkleft; sleep 0.1 }
					dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
					shopping_list[place][name] -= 1
				end
				shopping_list[place].delete(name) if shopping_list[place][name] == 0
			end
			dothis "put ##{note.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
		shopping_list.delete(place) if shopping_list[place].empty?
	end
	fill_hands
	shopping_list
}

kill_for = proc { |kill_for_list|
	get_cauldron.call
	if CharSettings['attack-script'].nil?
		echo 'error: no attack script is set up'
	elsif not kill_for_list.empty?
		if CharSettings['before-hunt-script']
			start_script(CharSettings['before-hunt-script'])
			wait_while { running?(CharSettings['before-hunt-script']) }
		end
		for ingredient_name,count in kill_for_list.dup
			recipe_list = known_recipes.find_all { |r| (r[:product] == ingredient_name) and (r[:steps].first =~ /^kill/) }
			target_list = recipe_list.collect { |r| /^kill\s+(.+)/.match(r[:steps].first).captures.first }
			wander_room_list = Array.new
			target_list.each { |t| wander_room_list.concat(where_is.call(t).collect { |num| num.to_s }) }
			seen_targets = Array.new
			start_kill_room = wander_room_list.first
			if start_kill_room
				current_ingredient_count = start_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
				start_script 'go2', [ start_kill_room.to_s ]
				wait_while { running?('go2') }
				start_time = Time.now
				$alchemy_abort_room = false
				$alchemy_abort_hunt = false
				start_hunt_time = Time.now
				while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
					sleep 0.1
					wander.call
					next if checkpcs
					next if GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{Char.name}/) }
					while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
						target_ids = GameObj.npcs.find_all { |npc| target_list.include?(npc.name) and (npc.status !~ /dead/) }.collect { |npc| npc.id }
						if target_ids.length > 0
							if checkrt > 0 or checkcastrt > 0
								sleep 0.1
							else
								seen_targets = (seen_targets | (GameObj.npcs.to_a.collect { |npc| npc.name } & target_list))
								start_script(CharSettings['attack-script'], target_ids)
								wait_while { running?(CharSettings['attack-script']) }
								if $alchemy_abort_room or $alchemy_abort_hunt
									$alchemy_abort_room = false
									break
								end
							end
						else
							break
						end
						if $alchemy_abort_hunt
							$alchemy_abort_hunt = false
							break
						end
					end
					current_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
					break unless current_ingredient_count < start_ingredient_count + count
					break if Time.now - start_time > CharSettings['max-hunt-time']
				end
				end_time = Time.now
				CharSettings['kill time'] ||= Hash.new
				for npc in seen_targets
					CharSettings['kill time'][npc] ||= Hash.new
					if CharSettings['kill time'][npc][ingredient_name].nil?
						CharSettings['kill time'][npc][ingredient_name] = [ 1, 1 ]
					end
					CharSettings['kill time'][npc][ingredient_name][0] += (end_time - start_time) / seen_targets.length.to_f
					CharSettings['kill time'][npc][ingredient_name][1] += (current_ingredient_count - start_ingredient_count) / seen_targets.length.to_f
				end
				kill_for_list[ingredient_name] = kill_for_list[ingredient_name] - (current_ingredient_count - start_ingredient_count)
				kill_for_list.delete(ingredient_name) if kill_for_list[ingredient_name] < 1
			else
				echo 'error: kill: failed to find starting room'
			end
		end
		if CharSettings['after-hunt-script']
			if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
			end
			start_script(CharSettings['after-hunt-script'])
			wait_while { running?(CharSettings['after-hunt-script']) }
		end
	end
	kill_for_list
}

go_get_crap = proc { |check_info|
	error = false
	unless check_info[:forage].empty? and check_info[:kill_for].empty? and check_info[:buy].empty?
		unless check_info[:kill_for].empty?
			check_info[:kill_for] = kill_for.call(check_info[:kill_for])
			unless check_info[:kill_for].empty?
				echo "error: failed to find: #{check_info[:kill_for].keys.join(', ')}"
				error = true
			end
		end
		unless error or check_info[:forage].empty?
			check_info[:forage] = forage.call(check_info[:forage])
			unless check_info[:forage].empty?
				echo "error: failed to find: #{check_info[:forage].keys.join(', ')}"
				error = true
			end
		end
		unless error or check_info[:buy].empty?
			check_info[:buy] = buy.call(check_info[:buy])
			unless check_info[:buy].empty?
				echo "error: failed to buy: #{check_info[:buy].keys.join(', ')}"
				error = true
			end
		end
	end
	!error
}

do_task_assembly = proc {
	error = false
	return_room = Room.current
	empty_hands
	get_cauldron.call
	if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		dothis 'get cloth', /^You take/
	else
		echo 'error: failed to find cleaning supplies'
		error = true
	end
	unless error
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			haste = Spell[506]
			for room_id in room_list
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				haste.cast if haste.known? and haste.affordable? and not haste.active?
				clean_result = dothis 'polish ass', /You have|Perhaps you should check another workshop/
				waitrt?
				break if clean_result =~ /You have completed/
			end
			fput 'put cloth'
		else
			echo 'error: failed to find workshop'
			error = true
		end
	end
	fill_hands
	unless Room.current == return_room
		start_script 'go2', [ return_room.id.to_s ]
		wait_while { running?('go2') }
	end
	invalid_gld.call
	!error
}

do_task_distill = proc {
	room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
	if room_list.length > 0
		if room_list.include?(Room.current.id)
			return_room = nil
		else
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ room_list.first.to_s ]
			wait_while { running?('go2') }
		end
		haste = Spell[506]
		loop {
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "pour alembic", /^You collect/
			sleep 2
			waitrt?
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "light alembic", /^You focus/
			waitfor "pressure within it builds"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "turn alembic", /^Turning a mithril lever/
			waitfor "pressure within it builds"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "turn alembic", /^Turning a mithril lever/
			waitfor "the flame beneath it suddenly dies down"
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "clean alembic", /^Using a barrel of water/
			sleep 2
			waitrt?
			haste.cast if haste.known? and haste.affordable? and not haste.active?
			dothis "get alembic", /^Having cleaned the/
			line = waitfor "You have"
			waitrt?
			break if line == "[You have completed your training task.]"
		}
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		invalid_gld.call
		true
	else
		echo 'error: failed to find workshop'
		false
	end
}

do_task_crucible = proc {
	error = false
	if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		if Room.current.id == room_id
			return_room = nil
		else
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
		end
		empty_hands
		dothistimeout 'get rag', 10, /^You take/
		haste = Spell[506]
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			for room_id in room_list
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				haste.cast if haste.known? and haste.affordable? and not haste.active?
				clean_result = dothistimeout 'clean crucible', 10, /You have|Perhaps you should check another workshop/
				waitrt?
				sleep 0.5
				break if clean_result =~ /You have completed/
			end
		else
			echo 'error: failed to find workshop'
			error = true
		end
		fput 'drop rag'
		fill_hands
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
	else
		echo 'error: failed to find cleaning supplies room'
		error = true
	end
	invalid_gld.call
	!error
}

do_task_sweep = proc {
	error = false
	if cleaning_supplies_room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
		room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
		if room_list.length > 0
			return_room = Room.current
			get_cauldron.call
			start_script 'go2', [ cleaning_supplies_room_id.to_s ]
			wait_while { running?('go2') }
			empty_hands
			dothis 'get broom', /^You take/
			dothis 'get pan', /^You take/
			room_count = 0
			haste = Spell[506]
			location = Room[room_list.first].location
			room_list.delete_if { |room_id| Room[room_id].location != location }
			sweep_result = nil
			loop {
				for room_id in room_list
					start_script 'go2', [ room_id.to_s ]
					wait_while { running?('go2') }
					loop {
						haste.cast if haste.known? and haste.affordable? and not haste.active?
						sweep_result = dothis 'sweep dust', /^Roundtime|^Sweep what|^Your dust pan appears to be full\.|^But your dust pan is already full|^Someone else is already sweeping that pile of dust\.$|^\.\.\.wait|^What did the dust ever do to you\?$/
						sleep 0.5
						waitrt?
						break if sweep_result =~ /^Sweep what|^Your dust pan appears to be full\.$|^But your dust pan is already full|^Someone else is already sweeping that pile of dust|^What did the dust ever do to you\?$/
					}
					break if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
				end
				start_script 'go2', [ cleaning_supplies_room_id.to_s ]
				wait_while { running?('go2') }
				if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
					put_result = dothis 'put my pan in bin', /^.You have/
					fput 'put broom'
					if put_result == '[You have completed your training task.]'
						fput 'put pan'
						break
					end
					dothis 'get broom', /^You take/
				else
					fput 'put broom'
					fput 'get broom'
				end
			}
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
			fill_hands
		else
			echo 'error: failed to find workshop'
			error = true
		end
	else
		echo 'error: failed to find cleaning supplies' 
		error = true
	end
	invalid_gld.call
	!error
}

do_task_grind = proc {
	if room_id = where_is.call("#{Char.prof.downcase} alchemy shop").first
		return_room = Room.current
		get_cauldron.call
		start_script 'go2', [ room_id.to_s ]
		wait_while { running?('go2') }
		haste = Spell[506]
		clerk = checknpcs.find { |npc_name| npc_name =~ /^clerk$|acolyte$|^hobgoblin$|^gnome$|^apothecary$/ } || 'clerk'
		empty_hands
		result = dothis 'get mortars', /^You take|^You already have a stone mortar|^Get what\?/
		if result =~ /^Get what\?/
			result = dothis 'get stone mortar', /^You take|^You already have a stone mortar/
		end
		shelf = GameObj.room_desc.find { |obj| obj.noun == 'shelf' } || GameObj.loot.find { |obj| obj.noun == 'shelf' }
		loop {
			script.want_downstream = false
			script.want_downstream_xml = true
			contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there\./
			if contents_line =~ /There is nothing on there\./
				script.want_downstream = true
				script.want_downstream_xml = false
				dothistimeout "ask #{clerk} about ingredients", 10, /^You ask the .*? about ingredients\.$/
				script.want_downstream = false
				script.want_downstream_xml = true
				contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there$/
			end
			script.want_downstream = true
			script.want_downstream_xml = false
			grindable_id, grindable_noun = /you see .*?<a exist="(.*?)" noun="(.*?)"/.match(contents_line).captures[0..1]
			get_result = dothistimeout "get ##{grindable_id}", 10, /^You take/
			if get_result
				loop {			
					haste.cast if haste.known? and haste.affordable? and not haste.active?
					grind_result = dothistimeout "grind my #{grindable_noun}", 10, /^You take the stone pestle into your free hand and grind|ground as much as possible|^Grind what/
					waitrt?
					break if grind_result =~ /ground as much as possible|^Grind what/
				}
			end
			give_result = dothistimeout "give my mortar to #{clerk}", 10, /^\[You have/
			break unless give_result =~ /\[You have [0-9]+ repetitions? remaining\.\]/
		}
		fput 'put mortar'
		fill_hands
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		invalid_gld.call
		true
	else
		echo 'error: failed to find alchemy shop'
		false
	end
}

do_task_grind_mine = proc {
	$alchemy_grind_history ||= Hash.new
	$alchemy_grind_history.delete_if { |recipe,time| time > Time.now + 600 }
	check_list = Array.new
	recipe_list = known_recipes.find_all { |recipe| (recipe[:steps].first =~ /^grind/) and not $alchemy_grind_history.keys.include?(recipe[:product]) }
	for recipe in recipe_list
		tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0 }
		tracker = recursive_check_recipe.call(recipe, tracker, top_level=true)
		fixed_buy = Hash.new
		tracker[:buy].each_pair { |where_what,how_many|
			where, what = where_what.split(';')
			fixed_buy[where] ||= Hash.new
			fixed_buy[where][what] = how_many
		}
		tracker[:buy] = fixed_buy
		tracker.delete(:claimed_ingredients)
		tracker.delete(:ingredient_count)
		tracker.delete(:extra_ingredients)
		check_list.push(tracker)
	end
	check_list.delete_if { |check| !check[:error].empty? or check[:steps].first !~ /^grind/ }
	check_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
	result = nil
	empty_hands
	for check_info in check_list
		return_room = Room.current
		show_check.call(check_info)
		got_crap = go_get_crap.call(check_info)
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		if got_crap
			do_steps.call(check_info[:steps])
			$alchemy_grind_history[check_info[:recipe_count].keys.first] = Time.now
			result = reget.reverse.find { |line| line =~ /^\[You have|as ground as its going to get/ }
			break unless result =~ /remaining/
		end
	end
	fill_hands
	invalid_gld.call
	if result =~ /You have completed/
		true
	else
		false
	end
}

do_task = proc { |type|
	error = false
	if gld.call[type][:reps] > 0
		empty_hands
		if gld.call[type][:task] == 'visit a skilled master for a lesson'
			if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
				start_script 'go2', [ room_id.to_s ]
				wait_while { running?('go2') }
				if checkpoison
					echo "masters won't talk to you while you're poisoned..."
					wait_while { checkpoison }
				end
				dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
				while line = get
					if line =~ /try a recipe with (.*?) as a component/
						required_step = $1.downcase
						recipe_list = gld_suggestions.call[type][:recipes]
						recipe_list.delete_if { |recipe_name| !known_recipes.any? { |recipe| (recipe[:product] == recipe_name) and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } } }
						check_info = check_recipe.call(recipe_list, 1)
						if !check_info[:error].empty? or check_info[:steps].any? { |step| step =~ /^extract|^distill|^special/ } or not check_info[:buy].empty? or not check_info[:forage].empty? or not check_info[:kill_for].empty?
							move 'out'
							reps = gld.call[type][:reps]
							while reps > 0
								check_info = check_recipe.call(recipe_list, reps)
								break if check_info[:error].empty?
								reps -= 1
							end
							if reps < 1
								echo 'error: failed to find a decent recipe'
								sleep 0.5
								error = true
								break
							end
							show_check.call(check_info)
							break unless go_get_crap.call(check_info)
							go_empty_workshop.call
							unless is_workshop.call
								echo 'error: failed to find a workshop'
								error = true
								break
							end
							do_steps.call(check_info[:prepare_steps])
							get_cauldron.call
							if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
								start_script 'go2', [ room_id.to_s ]
								wait_while { running?('go2') }
								dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
							else
								echo 'error: failed to find alchemy masters'
								error = true
								break
							end
						else
							show_check.call(check_info)
							do_steps.call(check_info[:steps])
						end
					elsif line == '[You have completed your training task.]'
						invalid_gld.call
						move 'out'
						break
					end
				end
			else
				echo 'error: failed to find alchemy masters'
				error = true
			end
		elsif gld.call[type][:task] =~ /^practice creating tough solutions|follow some tough recipes and create some items|^practice (?:distilling|extracting) for reagents/
			check_info = check_recipe.call(gld_suggestions.call[type][:recipes], gld_suggestions.call[type][:reps])
			if check_info[:error].empty?
				get_cauldron.call
				show_check.call(check_info)
				if go_get_crap.call(check_info)
					go_empty_workshop.call
					if is_workshop.call
						do_steps.call(check_info[:steps])
						get_cauldron.call
					else
						echo "error: failed to find workshop"
						error = true
					end
				else
					error = true
				end
			else
				echo "warning: failed to find a decent recipe"
				error = true
			end
		elsif gld.call[type][:task] =~ /^visit the cauldron workshop and practice making solutions/
			check_info = check_recipe.call(gld_suggestions.call[type][:recipes], gld_suggestions.call[type][:reps])
			if check_info[:error].empty?
				if cauldron_room_id = where_is.call("#{Char.prof.downcase} alchemy training cauldron").first
					get_cauldron.call
					show_check.call(check_info)
					if go_get_crap.call(check_info)
						if check_info[:prepare_steps]
							go_empty_workshop.call
							do_steps.call(check_info[:prepare_steps])
							get_cauldron.call
							start_script 'go2', [ cauldron_room_id.to_s ]
							wait_while { running?('go2') }
							do_steps.call(check_info[:finish_steps])
						else
							start_script 'go2', [ cauldron_room_id.to_s ]
							wait_while { running?('go2') }
							show_check.call(check_info)
							fput 'stance offensive' unless stance =~ /offensive/
							do_steps.call(check_info[:steps])
						end
					else
						error = true
					end
				else
					echo "error: failed to find training cauldron"
					error = true
				end
			else
				echo "warning: failed to find a decent recipe"
				error = true
			end
		elsif gld.call[type][:task] == 'practice grinding various ingredients with a mortar and pestle'
			get_cauldron.call
			go_empty_workshop.call
			result = do_task_grind_mine.call
			error = !result
		elsif gld.call[type][:task] == 'polish tarnished lens assemblies and any nearby lenses in alchemy labs'
			result = do_task_assembly.call
			error = !result
		elsif gld.call[type][:task] == "grind some ingredients for the guild's supply"
			result = do_task_grind.call
			error = !result
		elsif gld.call[type][:task] == "distill water for the guild's supply"
			result = do_task_distill.call
			error = !result
		elsif gld.call[type][:task] == 'clean alchemic equipment in the labs'
			result = do_task_crucible.call
			error = !result
		elsif gld.call[type][:task] == 'sweep the alchemy labs'
			result = do_task_sweep.call
			error = !result
		end
		fill_hands
	end
	!error
}

top_off_jars = proc {
	empty_hands
	for jar in alchemy_sack.call.contents.find_all { |obj| obj.after_name =~ /^containing / }
		next if jar.after_name == 'containing fine white powder'
		got_jar = false
		for item in all_sack_contents.call.find_all { |obj| jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
			unless got_jar
				dothis "get ##{jar.id}", /^You remove|^You already have that/
				got_jar = true
			end
			result = dothis "_drag ##{item.id} ##{jar.id}", /^You add|is full/
			if result =~ /is full/
				dothis "put ##{item.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
				break
			else
				ingredient_count[jar.id] = ingredient_count[jar.id] + 1 unless ingredient_count[jar.id].nil?
			end
		end
		if got_jar
			dothis "put ##{jar.id} in ##{alchemy_sack.call.id}", /^You put|^I could not find what you were referring to\./
		end
	end
	fill_hands
}

look_in_jars = proc {
	for jar in all_sack_contents.call.find_all { |obj| obj.after_name =~ /^containing / }
		next if jar.after_name == 'containing fine white powder'
		fput "look in ##{jar.id}"
	end
}

throw_away = proc {
	if room_id = where_is.call('trash').first
		trash_items = loot_sack.call.contents.to_a.find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras)$|^flask of pure water$|^grot t'kel potion$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
		unless trash_items.empty?
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			if trash_container = GameObj.loot.find { |obj| obj.noun =~ /^(?:receptacle|bin|barrel|trashcan)$/ }
				empty_hand
				for item in trash_items
					dothistimeout "get ##{item.id}", 3, /^You remove/
					dothistimeout "put ##{item.id} in ##{trash_container.id}", 3, /^You put|^As you place|^There appears .*? significant value|^Are you crazy\?!\?  Do you know what that's worth!\?!/
					if (GameObj.right_hand.id == item.id) or (GameObj.left_hand.id == item.id)
						dothistimeout "put ##{item.id} in ##{lootsack.call.id}", 3, /^You put/
					end
				end
				fill_hand
			end
		end
	else
		echo 'error: failed to find trash room'
	end
}

sell = proc {
	sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:iron wand)$/ }
	unless sell_items.empty?
		start_script 'go2', [ 'pawnshop', '_disable_confirm_' ]
		wait_while { running?('go2') }
		empty_hand
		for item in sell_items
			fput "get ##{item.id}"
			fput "sell ##{item.id}"
			sleep 0.2
		end
		fill_hand
	end
	sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:silvery potion|pale green potion|dark shimmering oil|iridescent opal wand|some dull silvery dust|rohnuru potion|minor mana potion|sarmoc potion|minor mana potion|lesser mana potion|smooth crystalline wand|lesser health potion|glowing blue potion|clear potion|lesser mana regeneration potion|hazy glass vial|silvery potion)$/ or (obj.noun == 'vial' and obj.after_name == 'containing fine white powder') }
	unless sell_items.empty?
		start_script 'go2', [ 'consignment', '_disable_confirm_' ]
		wait_while { running?('go2') }
		empty_hand
		for item in sell_items
			fput "get ##{item.id}"
			fput "sell ##{item.id}"
			sleep 0.2
		end
		fill_hand
	end
}

buy_elusive = proc {
	unless UserVars.needed_reagents.nil? or UserVars.needed_reagents.empty?
		if note = all_sack_contents.call.find { |obj| obj.name == note_name.call }
			if room_id = where_is.call('reagent shop').first and (adj_room_id = Room[room_id].wayto.keys.first) and (way = Room[adj_room_id].wayto[room_id.to_s]) and (way.class == String)
				start_script 'go2', [ adj_room_id ]
				wait_while { running?('go2') }
				move way
				if table = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun == 'table' }
					count = Hash.new
					dothistimeout "look on ##{table.id}", 3, /^On the .* you see/
					unless table.contents.empty?
						if table.contents.any? { |obj| obj.name =~ /#{UserVars.needed_reagents}/ }
							empty_hands
							dothistimeout "get ##{note.id}", 10, /^You remove|^You already have that\./
							for obj in table.contents
								if obj.name =~ /#{UserVars.needed_reagents}/
									unless count[obj.name]
										count[obj.name] = all_sack_contents.call.find_all { |o| o.name == obj.name }.length
										jar_list = all_sack_contents.call.find_all { |o| o.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
										for jar in jar_list
											if CharSettings['hide-jar-check']
												action = proc { |server_string|
													if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
														DownstreamHook.remove('hide-jar-check')
														nil
													else
														server_string
													end
												}
												DownstreamHook.add('hide-jar-check', action)
											end
											look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
											count[obj.name] += look_result.slice(/[0-9]+/).to_i
										end
									end
									if count[obj.name] < 20
										did_something = true
										count[obj.name] = count[obj.name].to_i + 1
										fput 'unhide' if invisible?
										fput "buy ##{obj.id}"
										dothistimeout "put my #{obj.noun} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
									end
								end
							end
							dothistimeout "put ##{note.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
							sleep 0.05
							top_off_jars.call
							empty_jar_list = alchemy_sack.call.contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ and obj.after_name.nil? }
							unless empty_jar_list.empty?
								important_stuff = all_sack_contents.call.find_all { |obj| elusive_reagent_cost.keys.include?(obj.name) and not all_sack_contents.call.any? { |jar| jar.noun =~ /^(?:jar|beaker|bottle)$/ and jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ } }
								important_stuff_count = Hash.new
								important_stuff.each { |stuff| important_stuff_count[stuff.name] = important_stuff_count[stuff.name].to_i + 1 }
								important_stuff_count = important_stuff_count.sort { |a,b| b[1] <=> a[1] }.collect { |n| n[0] }
								for empty_jar in empty_jar_list
									if name = important_stuff_count.pop
										dothistimeout "get ##{empty_jar.id}", 10, /^You remove|^You already have that/
										for obj in all_sack_contents.call
											if obj.name == name
												result = dothistimeout "_drag ##{obj.id} ##{empty_jar.id}", 10, /^You add|^You put|is full/
												if result =~ /is full/
													dothistimeout "put ##{obj.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
													break
												end
											end
										end
										dothistimeout "put ##{empty_jar.id} in ##{alchemy_sack.call.id}", 10, /^You put|^I could not find what you were referring to\./
									end
								end
							end
							fill_hands
						end
					end
				else
					echo 'error: no table'
				end
			else
				echo 'error: failed to find a reagent shop'
			end
		else
			echo 'error: you are too poor for alchemy'
		end
	end
}

unless script.vars[1].downcase == 'test'
	known_recipes.delete_if { |recipe| !recipe[:for].nil? and !recipe[:for].include?(Char.prof) }
end

#echo known_recipes.length
#exit

if script.vars[1].downcase == 'set'
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	if (script.vars[2] =~ /^(?:hide\-gld\-check|hide\-bundle\-check|hide\-jar\-check|cast\-sanctuary|buy\-crap|throw\-away\-crap|sell\-crap)$/i) and (script.vars[3] =~ /^(?:on|off|yes|no|true|false)$/i)
		CharSettings[script.vars[2].downcase] = fix_option[script.vars[3].downcase]
		echo 'setting saved'
	elsif (script.vars[2] =~ /^(?:max\-travel\-time|max\-hunt\-time|max\-forage\-time|cost\-per\-second)$/i) and (script.vars[3] =~ /^[0-9]+$/)
		CharSettings[script.vars[2].downcase] = script.vars[3].to_i
		echo 'setting saved'
	elsif (script.vars[2] =~ /^(?:attack\-script|before\-hunt\-script|after\-hunt\-script|before\-forage\-script|after\-forage\-script)$/i) and script.vars[3]
		CharSettings[script.vars[2].downcase] = script.vars[3]
		echo 'setting saved'
	else
		echo "you're doing it wrong"
	end		
elsif script.vars[1].downcase == 'add'
	if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
		matching_recipes = known_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = known_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
				if matching_recipes.empty?
					matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
				end
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
			if CharSettings['favorite-recipes'].include?(recipe_name)
				echo "#{recipe_name} is already a favorite recipe."
			else
				CharSettings['favorite-recipes'].push(recipe_name)
				set_needed_reagents.call
				echo "#{recipe_name} is now a favorite recipe."
			end
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
		else
			echo 'no matching recipe found.'
		end
	else
		echo "you're doing it wrong"
	end
elsif script.vars[1].downcase == 'del'
	if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
		matching_recipes = known_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = known_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
				if matching_recipes.empty?
					matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
				end
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
			if CharSettings['favorite-recipes'].include?(recipe_name)
				CharSettings['favorite-recipes'].delete(recipe_name)
				set_needed_reagents.call
				echo "#{recipe_name} is no longer a favorite recipe."
			else
				echo "#{recipe_name} is not favorite recipe."
			end
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
		else
			echo 'no matching recipe found.'
		end
	else
		echo "you're doing it wrong"
	end
elsif script.vars[1].downcase == 'suggest'
	output = "\n"
	for type in [ 'alchemy', 'potions', 'trinkets' ]
		output.concat "\n#{type}:\n"
		if gld_suggestions.call[type][:recipes].nil? or gld_suggestions.call[type][:recipes].empty? or gld_suggestions.call[type][:reps].zero?
			output.concat "   (none)\n"
		else
			max_recipe_name = 0
			gld_suggestions.call[type][:recipes].each { |recipe_name| max_recipe_name = [max_recipe_name,recipe_name.length].max }
			for recipe_name in gld_suggestions.call[type][:recipes]
				recipe = known_recipes.find { |r| r[:product] == recipe_name }
				output.concat "   #{recipe_name.ljust(max_recipe_name)}   ranks: #{recipe[:rank][0].to_s.rjust(2)}-#{recipe[:rank][1].to_s.rjust(2)}"
				check = check_recipe.call(recipe_name, gld_suggestions.call[type][:reps])
				output.concat "   cost: #{check[:cost].to_i.to_s.rjust(5)}   time: #{(check[:time]/60.0).as_time}"
				has_step = Array.new
				recipe[:steps].each { |step| if step =~ /^(boil|infuse|simmer|chant|distill|extract|channel)/ and not has_step.include?($1); has_step.push($1); end }
				output.concat "   includes: #{has_step.join(', ')}" unless has_step.empty?
				unless check[:error].empty?
					missing = check[:error].collect { |a,b| "#{a} (#{b})" }
					output.concat "   #{monsterbold_start}missing:#{monsterbold_end} #{missing.join(', ')}"
				end
				output.concat "\n"
			end
		end
	end
	output.concat "\n"
	puts output
	close_sacks.call
elsif script.vars[1] =~ /^(check|make|prepare)$/i and not script.vars[2].nil?
	if $1.downcase == 'check'
		check_only = true
	else
		check_only = false
	end
	if $1.downcase == 'prepare'
		prepare_only = true
	else
		prepare_only = false
	end
	repetitions = (script.vars[2..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
	script.vars.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }
	search_string = script.vars[2..-1].join(' ')
	unless recipe_name = known_recipes.find { |r| r[:spell] == search_string }[:product]
		matching_recipes = known_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
		if matching_recipes.empty?
			matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
			if matching_recipes.empty?
				matching_recipes = known_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
			end
		end
		matching_recipes = matching_recipes | matching_recipes # remove duplicates
		if matching_recipes.length == 1
			recipe_name = matching_recipes.first
		elsif matching_recipes.length > 1
			output = "\nmatching recipes:\n"
			matching_recipes.each { |name| output.concat "   #{name}\n" }
			output.concat "\n"
			respond output
			exit
		end
	end
	unless recipe_name
		echo 'no matching recipe'
		exit
	end
	check_info = check_recipe.call(recipe_name, repetitions)
	show_check.call(check_info)
	if check_info[:error].empty? and not check_only
		echo 'starting in 3 seconds...'
		sleep 3
		empty_hands
		return_room = Room.current
		exit unless go_get_crap.call(check_info)
		unless Room.current == return_room
			start_script 'go2', [ return_room.id.to_s ]
			wait_while { running?('go2') }
		end
		if prepare_only
			do_steps.call(check_info[:prepare_steps])
		else
			do_steps.call(check_info[:steps])
		end
		get_cauldron.call
		fill_hands
		close_sacks.call
	end
	close_sacks.call
elsif script.vars[1].downcase == 'task' and not script.vars[2].nil?
	if script.vars[2].downcase == 'distill'
		do_task_distill.call
	elsif script.vars[2].downcase == 'assembly'
		do_task_assembly.call
	elsif script.vars[2].downcase == 'crucible'
		do_task_crucible.call
	elsif script.vars[2].downcase == 'grind'
		do_task_grind.call
	elsif script.vars[2].downcase == 'sweep'
		do_task_sweep.call
	elsif script.vars[2].downcase =~ /^grind\-?mine$/
		do_task_grind_mine.call
	elsif script.vars[2].downcase =~ /^(?:alchemy|potions|trinkets)$/
		do_administrator.call
		do_task.call(script.vars[2].downcase)
		do_administrator.call
	else
		echo 'unknown task'
	end
elsif script.vars[1].downcase == 'jar'
	top_off_jars.call
	look_in_jars.call
	close_sacks.call
elsif script.vars[1].downcase == 'buy'
	buy_elusive.call
	look_in_jars.call
	close_sacks.call
elsif script.vars[1].downcase == 'need'
	set_needed_reagents.call
elsif script.vars[1].downcase == 'test'
#	respond gld.call.inspect
#	exit
	all_reagents = Array.new
	known_recipes.each { |recipe|
		recipe[:steps].each { |step|
			if step =~ /^(?:add|extract|distill|grind) (.+)$/
				reagent = $1
				all_reagents.push(reagent) unless all_reagents.include?(reagent)
			end
		}
	}
	all_reagents.delete_if { |reagent|
		elusive_reagent_cost.keys.include?(reagent) or known_recipes.any? { |recipe| recipe[:product] == reagent } or (grind_recipe = known_recipes.find { |recipe| recipe[:steps].first == "grind #{reagent}" } and known_recipes.any? { |recipe| (recipe[:product] == grind_recipe[:product]) and (recipe[:steps].first !~ /^grind/) })
	}
	respond all_reagents
	exit
	results = check_recipe.call('dark translucent crystal', 1)
	show_check.call(results)
	echo results.inspect
elsif script.vars[1].downcase == 'auto'
	if script.vars[2].downcase =~ /^(alchemy|trinkets|potions)$/
		type_list = [ $1 ]
		if script.vars[3].downcase =~ /^(alchemy|trinkets|potions)$/
			type_list.push($1)
		end
	else
		type_list = [ 'alchemy', 'potions', 'trinkets' ]
	end
	set_needed_reagents.call if UserVars.needed_reagents.nil?
	empty_hands
	loop {
		do_administrator.call
		for type in type_list
			do_task.call(type)
		end
		get_cauldron.call
		sleep 0.5
		if CharSettings['throw-away-crap']
			throw_away.call
		end
		if CharSettings['sell-crap']
			sell.call
		end
		# fixme: not sure what the real limit is..
		$last_alchemy_buy ||= Time.now - 481
		if CharSettings['buy-crap'] and (Time.now - $last_alchemy_buy) > 480
			buy_elusive.call
			$last_alchemy_buy = Time.now
		end
		if ((silvers = check_silvers.call) > 0) and room_id = where_is.call('bank').first
			start_script 'go2', [ room_id.to_s ]
			wait_while { running?('go2') }
			fput "deposit #{silvers}"
		end
		sleep 0.5
	}
elsif script.vars[1].downcase == 'list'
	fix_option = { false => 'off', true => 'on' }
	output = "\n"
	output.concat "   cost-per-second:      #{CharSettings['cost-per-second']}\n"
	output.concat "   max-travel-time:      #{CharSettings['max-travel-time']}\n"
	output.concat "   max-hunt-time:        #{CharSettings['max-hunt-time']}\n"
	output.concat "   max-forage-time:      #{CharSettings['max-forage-time']}\n"
	output.concat "   hide-gld-check:       #{fix_option[CharSettings['hide-gld-check']]}\n"
	output.concat "   hide-bundle-check:    #{fix_option[CharSettings['hide-bundle-check']]}\n"
	output.concat "   hide-jar-check:       #{fix_option[CharSettings['hide-jar-check']]}\n"
	output.concat "   cast-sanctuary:       #{fix_option[CharSettings['cast-sanctuary']]}\n"
	output.concat "   buy-crap:             #{fix_option[CharSettings['buy-crap']]}\n"
	output.concat "   trow-away-crap:       #{fix_option[CharSettings['throw-away-crap']]}\n"
	output.concat "   sell-crap:            #{fix_option[CharSettings['sell-crap']]}\n"
	output.concat "   attack-script:        #{CharSettings['attack-script']}\n"
	output.concat "   before-hunt-script:   #{CharSettings['before-hunt-script']}\n"
	output.concat "   after-hunt-script:    #{CharSettings['after-hunt-script']}\n"
	output.concat "   before-forage-script: #{CharSettings['before-forage-script']}\n"
	output.concat "   after-forage-script:  #{CharSettings['after-forage-script']}\n"
	output.concat "\n"
	unless CharSettings['favorite-recipes'].empty?
		output.concat "   favorite-recipes:\n"
		for recipe_name in CharSettings['favorite-recipes']
			output.concat "      #{recipe_name}\n"
		end
		output.concat "\n"
	end
	respond output
else
	output = "\n"
	output.concat "Setup:\n"
	output.concat "   #{$clean_lich_char}set change alchemysack <container>\n"
	output.concat "   #{$clean_lich_char}set change lootsack <container>\n"
	output.concat "   #{$clean_lich_char}set change herbsack <container>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} set cost-per-second <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set max-travel-time <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set max-hunt-time <#>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-gld-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-bundle-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set hide-jar-check <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set cast-sanctuary <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set buy-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set throw-away-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set sell-crap <on|off>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set attack-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set before-hunt-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set after-hunt-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set before-forage-script <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} set after-forage-script <scriptname>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} add fav <scriptname>\n"
	output.concat "   #{$clean_lich_char}#{script.name} del fav <scriptname>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list\n"
	output.concat "\n"
	output.concat "Usage:\n"
	output.concat "   #{$clean_lich_char}#{script.name} make <recipe>\n"
	output.concat "   #{$clean_lich_char}#{script.name} make <recipe> x<repetitions>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe>                  buys, forages, and makes all the requirements, so you\n"
	output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe> x<repetitions>     can make the recipe later without having to run around\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} check <recipe>                    gives the same summary as make, but does nothing\n"
	output.concat "   #{$clean_lich_char}#{script.name} check <recipe> x<repetitions>\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} suggest                           attempts to list the recipes you'll get ranks for\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} jar                               fills your jars with loose items of the same type\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} buy\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} need\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} task alchemy\n"
	output.concat "   #{$clean_lich_char}#{script.name} task potions\n"
	output.concat "   #{$clean_lich_char}#{script.name} task trinkets\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} task distill\n"
	output.concat "   #{$clean_lich_char}#{script.name} task assembly\n"
	output.concat "   #{$clean_lich_char}#{script.name} task grind\n"
	output.concat "   #{$clean_lich_char}#{script.name} task grind-mine\n"
	output.concat "   #{$clean_lich_char}#{script.name} task crucible\n"
	output.concat "   #{$clean_lich_char}#{script.name} task sweep\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} auto                              gain ranks afk (somewhat buggy)\n"
	output.concat "   #{$clean_lich_char}#{script.name} auto <alchemy|potions|trinkets>   only work on the given area\n"
	output.concat "\n"
	respond output 
end
